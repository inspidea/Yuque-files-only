> **Original URL：**[**https://github.com/MisterBooo/LeetCodeAnimation**](https://github.com/MisterBooo/LeetCodeAnimation)
> **Full Code Zip：**[LeetCodeAnimation-master.zip](https://inspidea.yuque.com/attachments/yuque/0/2023/zip/35495747/1693585249598-d74ed391-ea6c-4cb3-8efb-8c946897977c.zip?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Finspidea.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fzip%2F35495747%2F1693585249598-d74ed391-ea6c-4cb3-8efb-8c946897977c.zip%22%2C%22name%22%3A%22LeetCodeAnimation-master.zip%22%2C%22size%22%3A515325811%2C%22ext%22%3A%22zip%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u0e2744ea-dd43-4189-94f0-8b596be539d%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fx-zip-compressed%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u42dcfe50%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D)
> Leetcode URL：[力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台](https://leetcode.cn/problems/two-sum/)
> **Demonstrate all the questions on LeetCode in the form of animation.**


![](https://cdn.nlark.com/yuque/0/2023/webp/35495747/1693575492265-542533e4-fffa-4319-a0e7-a21441b95cf1.webp#averageHue=%23222522&clientId=uaa12aca0-e4f7-4&from=url&id=MWTSb&originHeight=95&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua249bf18-5329-4135-a844-b7f0f2ccbb0&title=)<br />[![](https://camo.githubusercontent.com/d16cd378fa66d1ee88c99ceee85f890c1c77e6fac13cc3a99694c200af9cb77a/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c616e67756167652d432b2b2d7265642e737667#from=url&id=qL8uF&originHeight=20&originWidth=96&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)](https://developer.apple.com/.md) [![](https://camo.githubusercontent.com/cbf33ce86c90568b491fcc638214df9ca82bba879537eaddebad94a4f1d00a63/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c616e67756167652d4a6176612d79656c6c6f772e737667#from=url&id=VolAy&originHeight=20&originWidth=96&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)](https://developer.apple.com/.md)<br />[There is an English version of README here. just click it！](https://github.com/MisterBooo/LeetCodeAnimation/blob/master/README-En.md)<br />我会尽力将 LeetCode 上所有的题目都用动画的形式演示出来，计划用 3 到 4 年时间去完成它，期待与你见证这一天！<br />文章最新首发于微信公众号 吴师兄学算法，您可以关注获取最新的文章。<br />为了帮助大家更好的入门学习算法，经过半年的积累，我给大家整理了《剑指 Offer》系列的四十道题目，都是算法面试的高频题目，每一道题目我都提供详细的分析、精美的配图、易于理解的动画视频，适合那些第一次刷题的同学，当然，也适合重复刷题的老手再次学习巩固基础。
<a name="DutVD"></a>
# Index
| ID | Problem | Article | Animation |
| --- | --- | --- | --- |
| 000 | Ten Classic Sorting Algorithms | [十大经典排序算法动画与解析，看我就够了！（配代码完全版）](https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg) | ![](https://cdn.nlark.com/yuque/0/2023/webp/35495747/1693583359021-99bae26e-3bfc-4d24-b47d-e5eb83ac94e8.webp#clientId=uc1ee30c8-4071-4&id=quHuO&originHeight=538&originWidth=955&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3140c72d-14b7-463a-954b-c489c880172&title=) |
| 001 | Two Sum | [每天一算：Two Sum](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483740&idx=1&sn=1950545589ea9b86ee65fbb6be1f4290&chksm=fa0e6eddcd79e7cb542b7d4dc1304eead516994315fa4f52b575230f0f022c9e0a88ede3714e&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583359122-619929e5-b29b-46f0-bf21-1682bcddfac2.gif#averageHue=%23fdfdfd&clientId=uc1ee30c8-4071-4&id=zkWEi&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u78b408d8-0345-4cb1-a108-c24d56426c9&title=) |
| 002 | Add Two Numbers | [图解LeetCode第 2 号问题：两个数字相加](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484231&idx=2&sn=6a9eb4fd0619c822e4dede69b8d841c8&chksm=fa0e6cc6cd79e5d0c03fffcd65b665fed62db9dca9c97771898f388ea292ce806bfd6eb908b5&token=934487935&lang=zh_CN#rd) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583359174-7f6546f6-fd09-4157-b131-da1a4aa4f559.gif#averageHue=%23fefdfd&clientId=uc1ee30c8-4071-4&id=MymHa&originHeight=528&originWidth=953&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3e5c16dd-fb57-44bb-9f53-e7fdc41b183&title=) |
| 003 | Longest Substring Without Repeating Characters | [图解LeetCode第 3 号问题：无重复字符的最长子串](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484265&idx=2&sn=7f72afb341865923315bd51e1f50beff&chksm=fa0e6ce8cd79e5fe4be925fd5f01f59f59010c6c965fb3daefac79992593a6e58990c212e0bb&token=1412967663&lang=zh_CN#rd) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583359151-9f9fbb7c-c140-411a-842d-eb56b21e5845.gif#averageHue=%23fdfbfb&clientId=uc1ee30c8-4071-4&id=b6LRu&originHeight=479&originWidth=852&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua9acc8eb-a1b4-4b58-a39b-7fa48d8e8eb&title=) |
| 019 | Remove-Nth-Node-From-End-of-List | [每天一算：Remove Nth Node From End of List](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483821&idx=1&sn=11ecccab76cd53163e9dedb75effeb93&chksm=fa0e6e2ccd79e73ae9137c0d91b3533df4ea4ead4ad081834b8d91ff364c0d55c350ddcfa6c4&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583359129-4df64e33-8930-422e-b0fb-3732e3333625.gif#averageHue=%23fdfcfc&clientId=uc1ee30c8-4071-4&id=Ec3Ep&originHeight=539&originWidth=959&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8d65db35-7c40-444f-8751-2ad7e5b72c0&title=) |
| 020 | Valid-Parentheses | [每天一算：Valid Parentheses](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483824&idx=1&sn=ab9362e125dc5e2b3ef1611cad9448c2&chksm=fa0e6e31cd79e727c6e1e0e3c467e193edb6ae841a41e5dc8eef39d0bf3141cc53f63b019cba&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583360283-2b724cc5-b167-428e-94f8-8f225d370b3e.gif#averageHue=%23fdfdfd&clientId=uc1ee30c8-4071-4&id=eKTIv&originHeight=540&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue3eb26ab-7dd0-4d9c-b1eb-caba6061fea&title=) |
| 024 | Swap-Nodes-in-Pairs | [每天一算：Swap Nodes in Pairs](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483773&idx=1&sn=db6cf272df968cd6571eb0bb50ecc721&chksm=fa0e6efccd79e7ea26810d335e6ece9ac23b8e3ac31be00dbd534018737ccb3ef9a00f22aff3&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583360934-cac43dbc-b403-47cb-9ffa-aaa88778bd1a.gif#averageHue=%23fdfdfc&clientId=uc1ee30c8-4071-4&id=t2EJA&originHeight=535&originWidth=956&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8450a5c0-6ad4-40db-a7ac-16ea73f5c4c&title=) |
| 026 | Remove-Duplicates-from-Sorted-Array | [图解LeetCode第 26 号问题：删除排序数组中的重复项](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484284&idx=2&sn=c8af62a82a62a21217d0f0b2b5891e4f&chksm=fa0e6cfdcd79e5ebe8726a61f93b834467d29b7d9e60a44feb990388f9e98605ac1e3f7e723d&token=762342620&lang=zh_CN#rd) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583360924-78abd913-0515-429b-8b04-9ce5ab2a5dc8.gif#averageHue=%23fdfcfc&clientId=uc1ee30c8-4071-4&id=oaazv&originHeight=532&originWidth=952&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3cf40eb4-f402-4b3b-834c-c3cfb61ef93&title=) |
| 075 | Sort-Colors | [每天一算：Sort Colors](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483706&idx=1&sn=905f43c882a91b55fd169d812620f277&chksm=fa0e6ebbcd79e7ad8857b0dad9ad14dbaf17fe557ef56ba600cec26b2bb668df2e171431d74c&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583361176-b29fd4b4-50c2-45ff-b8e0-a9b61c1e52a9.gif#averageHue=%23fdfdfd&clientId=uc1ee30c8-4071-4&id=UEMlh&originHeight=457&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8bdf3e0d-f85f-4aaa-ba33-5eb67215cd8&title=) |
| 086 | Partition-List | [每天一算：Partition List](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483781&idx=1&sn=f31548ebbb2cf9ba56d979d3e51ddde2&chksm=fa0e6e04cd79e712d6cc7ff8e8b7631b7300ac0fa1a3e4c4e3b836de7a01fb5d0d6428a18bc4&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583361034-6580e377-b2c7-44a7-92ef-964d67ee95f2.gif#averageHue=%23fdfdfd&clientId=uc1ee30c8-4071-4&id=OSrcp&originHeight=541&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc26d2698-7352-41d4-b026-835781e6e0a&title=) |
| 092 | Reverse-Linked-List-II | [每天一算：Reverse Linked List II](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483820&idx=1&sn=113e87b55c8ac8e22e9db00673798118&chksm=fa0e6e2dcd79e73b5835a262599b935783de3317a453bc0ed8df9fa5d1532785a085ea663e59&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583361468-448603cc-eb6a-4b7c-96d9-014afed69de4.gif#averageHue=%23fbebea&clientId=uc1ee30c8-4071-4&id=XXfYX&originHeight=535&originWidth=956&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u562d570f-0359-42e4-a059-fd39da21476&title=) |
| 094 | Binary-Tree-Inorder-Traversal | [每天一算：Binary Tree Inorder Traversal ](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483853&idx=1&sn=94cd4b4ee8dc2268290a72334c6af57b&chksm=fa0e6e4ccd79e75a41a6b78397b80cdfccda332823874475b516f997f89e786488599fc5cc1e&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583362453-e4bf39ec-fc79-4368-b4cc-ab42522eebc0.gif#averageHue=%23fdfcfc&clientId=uc1ee30c8-4071-4&id=djpni&originHeight=541&originWidth=963&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud406342b-99dd-40b2-8890-826304b79cd&title=) |
| 102 | Binary-Tree-Level-Order-Traversal | [每天一算：Binary Tree Level Order Traveral](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483868&idx=1&sn=d50041789fcd13a75a2296f620b69d71&chksm=fa0e6e5dcd79e74b0030ac5129f10ec4ba87c98da63c5904affe9f06e06ecf28695c410d3ec7&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583362421-9e9e1884-8531-42ec-aa19-12377646cf8a.gif#averageHue=%23fdfcfc&clientId=uc1ee30c8-4071-4&id=z0auI&originHeight=538&originWidth=961&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u046c1139-f9c5-4581-9ff1-21612ab19be&title=) |
| 103 | Binary Tree Zigzag Level Order Traversal | [图解LeetCode第 103 号问题：二叉树的锯齿形层次遍历](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484290&idx=2&sn=c29c4eefcbe8954cca6b3c8491ebccf1&chksm=fa0e6c03cd79e515581905322a3a22a3f3d10d24ca668a9d5aaef00932f0237eeaeaf3199668&token=1840661183&lang=zh_CN#rd) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583363037-33c483a2-42e6-40db-862d-ab78be5d87f2.gif#averageHue=%23fdfcfc&clientId=uc1ee30c8-4071-4&id=YBYal&originHeight=532&originWidth=952&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u042d37ed-a78f-47c9-8792-28fc8c3e108&title=) |
| 107 | Binary Tree Level Order Traversal II | 每天一算： Binary Tree Level Order Traversal II | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583363121-9f1d0b4f-8010-4c21-96a4-f602f59d5b31.gif#averageHue=%23fdfcfc&clientId=uc1ee30c8-4071-4&id=xa6DF&originHeight=538&originWidth=961&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub10d86ad-421a-4677-8f96-3d3a19e292e&title=) |
| 136 | Single Number | [一道让你拍案叫绝的算法题 ](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484505&idx=1&sn=4c1c056dd4852c3b4b1ead51c90a9b2d&chksm=fa0e6bd8cd79e2ce8188dcdd8843a5d071248906bfb8971c62d513dbd69b816acc191a78e4b2&token=487128715&lang=zh_CN#rd) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583363073-4b2de7e6-5848-43b0-a432-37ef097970ee.gif#averageHue=%23fdfdfd&clientId=uc1ee30c8-4071-4&id=BNkGM&originHeight=537&originWidth=959&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf82d092e-bd53-40b0-87c6-f86b507d85b&title=) |
| 144 | Binary-Tree-Preorder-Traversal | [每天一算：Binary Tree Preorder Traversal](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483843&idx=1&sn=994bf0d42dd9941a879a3a3ed500a4d6&chksm=fa0e6e42cd79e75472404eb5da7ee98f20d303efe230eb4f41efec57164630f555e7111e62ff&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583363661-4b5aaad6-2146-4c3d-9587-37b2d40c26f9.gif#averageHue=%23fdfcfc&clientId=uc1ee30c8-4071-4&id=bPyd4&originHeight=538&originWidth=961&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u64b75263-893a-451b-a976-d9602eb1931&title=) |
| 145 | Binary-Tree-Postorder-Traversal | [每天一算：Binary Tree Postorder Traversal](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483853&idx=1&sn=94cd4b4ee8dc2268290a72334c6af57b&chksm=fa0e6e4ccd79e75a41a6b78397b80cdfccda332823874475b516f997f89e786488599fc5cc1e&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583363794-32f6a060-1d43-49ad-a1a7-e5a12c81df1a.gif#averageHue=%23fdfcfc&clientId=uc1ee30c8-4071-4&id=xfA7c&originHeight=538&originWidth=961&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1fe7cc57-3857-4c94-a3d2-e4b1cda6879&title=) |
| 146 | LRU Cache | LRU缓存机制 | ![](https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20190125143756.gif#clientId=uc1ee30c8-4071-4&id=rcQqg&originHeight=586&originWidth=1088&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uba0b1b9c-0229-48e0-879e-7f3320e7372&title=) |
| 150 | Evaluate-Reverse-Polish-Notation | [每天一算：Evaluate Reverse Polish Notation](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483834&idx=1&sn=27cbff99f10dfcdb56cb37c237d7f2bb&chksm=fa0e6e3bcd79e72dc430bf81aed9dde9bd01634239dcf7820d6befa881efd323d9d58d76d90d&scene=21#wechat_redirect) | ![](https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161304.gif#clientId=uc1ee30c8-4071-4&id=Biiu8&originHeight=544&originWidth=969&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue4f5857d-daf0-4133-bf65-3b883ed46f1&title=) |
| 167 | Two-Sum-II-Input-array-is-sorted | [每天一算：Two Sum II ](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483711&idx=1&sn=3afec74e9e9effa71dc0b22659e14b44&chksm=fa0e6ebecd79e7a84db7861c9b5dbccdc98aa9d9a6994dda49a37edeb729e8242ea6af8f20ad&scene=21#wechat_redirect) | ![](https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161314.gif#clientId=uc1ee30c8-4071-4&id=hYP3w&originHeight=457&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u36a6a151-c713-454d-8bec-51a6659d303&title=) |
| 199 | Binary Tree Right Side View | 每天一算：Binary Tree Right Side View | ![](https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161328.gif#clientId=uc1ee30c8-4071-4&id=BsoLt&originHeight=532&originWidth=952&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufbbf0718-e992-4738-b2cf-6445d889273&title=) |
| 203 | Remove-Linked-List-Elements | [每天一算：Remove Linked List Elements](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483766&idx=1&sn=6721376a65680bf7cf9064cf7b1ae4ae&chksm=fa0e6ef7cd79e7e1665e60fe6ea3f2087bca518c1573bc4c4b9425573f98401bafc59542dca0&scene=21#wechat_redirect) | ![](https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161338.gif#clientId=uc1ee30c8-4071-4&id=XBKQI&originHeight=540&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3a932fb0-3d92-4c13-97a3-0c1c4ff544b&title=) |
| 206 | Reverse Linked List | [每天一算： Reverse Linked List ](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483799&idx=1&sn=c2212c8963809e8d3392abeeb851dbfc&chksm=fa0e6e16cd79e7003c2d30b1a2bb4f23dc56df38e3efedd0ab2cfae291609280a832eabe67de&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583384420-fdda7024-6663-4326-bb24-6a196a6777f6.gif#averageHue=%23fdfdfd&clientId=uc1ee30c8-4071-4&id=rmjh4&originHeight=477&originWidth=847&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u65f13cd6-37e0-4878-a33e-13958bb6431&title=) |
| 209 | Minimum Size Subarray Sum | 每天一算： Minimum Size Subarray Sum | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583384423-bd81e6f0-9a99-42ff-9903-8672b2b0fddf.gif#averageHue=%23fdf5f0&clientId=uc1ee30c8-4071-4&id=urVUb&originHeight=474&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub5b484a9-f4c8-45f7-9022-e112fe90df7&title=) |
| 219 | Contains-Duplicate-II | [每天一算：Contains Duplicate II  ](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483755&idx=1&sn=2501b6ca09c43eaa9fba71a9bd1f5253&chksm=fa0e6eeacd79e7fc192c0a23cf90d98fe6f2c35f9e4f2d0f937ccba45a58cf23a0a9c49d35d5&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583384437-ee28b263-41cc-4d78-9974-f5ed705497da.gif#averageHue=%23fdfcfc&clientId=uc1ee30c8-4071-4&id=GsdME&originHeight=531&originWidth=959&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u57f5b85f-4a97-4d60-8d6d-fe76016d978&title=) |
| 237 | Delete-Node-in-a-Linked-List | 每天一算：Delete Node in a Linked List | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583384436-8ae15305-e7f8-4f46-a22e-e11ea51aa86a.gif#averageHue=%23fdfaf9&clientId=uc1ee30c8-4071-4&id=JkB22&originHeight=528&originWidth=963&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue1786ab2-51ef-475b-9c90-999d10d16d5&title=) |
| 279 | Perfect Squares | [图解LeetCode第 279 号问题： 完全平方数](https://mp.weixin.qq.com/s/53AlHe29fJF1hEwj0cj7ZA) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583384439-fd0308d7-c1da-4cc1-bfef-0fb44408a12d.gif#averageHue=%23fdfcfc&clientId=uc1ee30c8-4071-4&id=grurv&originHeight=535&originWidth=958&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u894b9497-7388-4d61-9423-857e6e65372&title=) |
| 283 | Move-Zeroes | [每天一算：Move Zeros](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483700&idx=1&sn=465f778d60e8560742feab5844d7cac5&chksm=fa0e6eb5cd79e7a357899d378edb532b498cd63e3ce9113f8ac74d397ce4b214ca5aa8198b7d&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583385896-ade29356-32b8-4af9-b7f9-045925b3624f.gif#averageHue=%23fefdfd&clientId=uc1ee30c8-4071-4&id=HUZw6&originHeight=418&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4b14ae03-8d45-43e5-80de-81a96b4563f&title=) |
| 328 | Odd-Even-Linked-List | [每天一算：Odd Even Linked List](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483786&idx=1&sn=f7810950b34675e1c4420361faf5e361&chksm=fa0e6e0bcd79e71d2c6fc6a4a68b6ef7a17abc3dc9897548f8e44b51e9494f52c4cebbc4176e&scene=21#wechat_redirect) | ![](https://diycode.b0.upaiyun.com/photo/2018/94e5c38540029690c93314b3d697caaf.gif#clientId=uc1ee30c8-4071-4&id=Wn2ep&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2400d6d6-f5fc-422b-bb0a-ab914a85919&title=) |
| 344 | Reverse-String | 每天一算：Reverse String | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583385879-4faa6bc3-1a27-44fb-8b42-7a30f8bc028c.gif#averageHue=%23fdfdfd&clientId=uc1ee30c8-4071-4&id=fv7ye&originHeight=529&originWidth=958&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubd96bdf2-93ac-4ef2-88aa-ed0217b5d76&title=) |
| 349 | Intersection-of-Two-Arrays | [每天一算：Intersection of Two Arrays ](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483726&idx=1&sn=a887f6b983058d97c183dd300832ecbb&chksm=fa0e6ecfcd79e7d985587b543622c85aadc83a4d7a074135e1356fb4a0ebfd07e7af13467906&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583386091-0c5f0ad7-90f0-45ac-b4f5-35336b947950.gif#averageHue=%23fdfdfd&clientId=uc1ee30c8-4071-4&id=m1TWs&originHeight=479&originWidth=848&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u99361b6c-816d-440f-baff-e939424a14b&title=) |
| 350 | Intersection-of-Two-Arrays-II | [每天一算：Intersection of Two Arrays II ](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483733&idx=1&sn=946bd6de3251437dd77b43ecab056c82&chksm=fa0e6ed4cd79e7c2a439b5f1853bf5154a3438ed282c7ba5e94948780c426a1f1492c0b201c4&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583385878-228d14bb-bdf3-4199-b7df-a06bb51b897f.gif#averageHue=%23fdfcfc&clientId=uc1ee30c8-4071-4&id=EIQu9&originHeight=458&originWidth=810&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u491c0a1d-e6b4-431c-b5e0-bf768b32100&title=) |
| 445 | Add Two Numbers II | [图解LeetCode第 445 号问题：  两数相加 II](https://mp.weixin.qq.com/s/z8_1dK7mw9gxfhhSZUBVgg) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583386399-d8816e11-ed6e-4874-8248-ee5f061b0e2e.gif#averageHue=%23fdfcfc&clientId=uc1ee30c8-4071-4&id=YtRq9&originHeight=535&originWidth=958&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0d6b7c86-b6a3-43d8-b766-0a77b37f9b3&title=) |
| 447 | Number-of-Boomerangs | [每日一算：Number of Boomerangs](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483747&idx=1&sn=7774eee0b252b311257134f6a52c4e2d&chksm=fa0e6ee2cd79e7f44858c46c3d04859ced9073dbb9de95ce7ee0bcc131e613862ddfd9a6f158&scene=21#wechat_redirect) | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583386870-8a8b7266-36d1-4120-a2eb-004f3d96970b.gif#averageHue=%23fdfdfd&clientId=uc1ee30c8-4071-4&id=QAQsv&originHeight=532&originWidth=959&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue6a4cff1-2869-43d4-92a7-86befc27974&title=) |
| 454 | 4Sum-II | 每日一算：4Sum II | ![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693583388470-97307bb1-fc81-4ba1-9763-34a5bcf13ae3.gif#averageHue=%23fdfcfc&clientId=uc1ee30c8-4071-4&id=A6RG5&originHeight=479&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0b1a1006-4f47-4d85-b762-3ac8cba0c84&title=) |
| 642 | Design Search Autocomplete System | [图解 LeetCode 第 642 号问题：搜索自动完成系统](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484491&idx=1&sn=b329d90370d183b5a58bbf03f6a436ae&chksm=fa0e6bcacd79e2dc05bb5eaabd888561b82c37700b511e4971aa76ec42a630c0a35ef3e4721b&token=397665543&lang=zh_CN#rd) | Made by Jun [Click here](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484491&idx=1&sn=b329d90370d183b5a58bbf03f6a436ae&chksm=fa0e6bcacd79e2dc05bb5eaabd888561b82c37700b511e4971aa76ec42a630c0a35ef3e4721b&token=397665543&lang=zh_CN#rd) |

<a name="IJYrQ"></a>
# #001 [两数之和](https://leetcode.cn/problems/two-sum/)
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 1 号问题：两数之和。题目难度为 Easy，目前通过率为 45.8% 。
<a name="TFcmy"></a>
### 题目描述
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。<br />你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br />**示例:**
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```
<a name="Rn5eC"></a>
### 题目解析
使用查找表来解决该问题。<br />设置一个 map 容器 record 用来记录元素的值与索引，然后遍历数组 nums。

- 每次遍历时使用临时变量 complement 用来保存目标值与当前值的差值
- 在此次遍历中查找 record ，查看是否有与 complement 一致的值，如果查找成功则返回查找值的索引值与当前变量的值 i
- 如果未找到，则在 record 保存该元素与索引值 i
<a name="r9nw2"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=JAYCJ&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="QAyAV"></a>
### 代码实现
<a name="o7sPs"></a>
#### C++
```
// 1. Two Sum
// https://leetcode.com/problems/two-sum/description/
// 时间复杂度：O(n)
// 空间复杂度：O(n)
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> record;
        for(int i = 0 ; i < nums.size() ; i ++){
       
            int complement = target - nums[i];
            if(record.find(complement) != record.end()){
                int res[] = {i, record[complement]};
                return vector<int>(res, res + 2);
            }

            record[nums[i]] = i;
        }
        return {};
    }
};
```
<a name="rpANY"></a>
#### C
```c
// 1. Two Sum
// https://leetcode.com/problems/two-sum/description/
// 时间复杂度：O(n)
// 空间复杂度：O(n)
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    int *ans=(int *)malloc(2 * sizeof(int));
    int i,j;
    bool flag=false; 
    for(i=0;i<numsSize-1;i++)
    {
        for(j=i+1;j<numsSize;j++)
        {
            if(nums[i]+nums[j] == target)
            {
                ans[0]=i;
                ans[1]=j;
                flag=true;
            }
        }
    }
    if(flag){
        *returnSize = 2;
    }
    else{
        *returnSize = 0;
    }
    return ans;
}
```
<a name="WqmNL"></a>
#### Java
```
// 1. Two Sum
// https://leetcode.com/problems/two-sum/description/
// 时间复杂度：O(n)
// 空间复杂度：O(n)
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int l = nums.length;
        int[] ans=new int[2];
        int i,j;
        for(i=0;i<l-1;i++)
        {
            for(j=i+1;j<l;j++)
            {
                if(nums[i]+nums[j] == target)
                {
                    ans[0]=i;
                    ans[1]=j;
                }
            }
        }
        
        return ans;
        
    }
}
```
<a name="tKtT6"></a>
#### Python
```
# 1. Two Sum
# https://leetcode.com/problems/two-sum/description/
# 时间复杂度：O(n)
# 空间复杂度：O(n)
class Solution(object):
    def twoSum(self, nums, target):
        l = len(nums)
        print(nums)
        ans=[]
        for i in range(l-1):
            for j in range(i+1,l):
                if nums[i]+nums[j] == target:
                    ans.append(i)
                    ans.append(j)
                    print([i,j])
                    break
        return ans
```
<a name="gmEVr"></a>
# #002 两数相加
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 2 号问题：两数相加。题目难度为 Medium，目前通过率为 33.9% 。
<a name="xoxev"></a>
### 题目描述
给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。<br />如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br />您可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br />**示例：**
```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```
<a name="WZHIC"></a>
### 题目解析
设立一个表示进位的变量carried，建立一个新链表，把输入的两个链表从头往后同时处理，每两个相加，将结果加上carried后的值作为一个新节点到新链表后面。
<a name="FWjNA"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=qMa08&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="Ug0Vj"></a>
### 代码实现
<a name="ru2Mb"></a>
#### C++
```
/// 时间复杂度: O(n)
/// 空间复杂度: O(n)
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        ListNode *p1 = l1, *p2 = l2;
        ListNode *dummyHead = new ListNode(-1);
        ListNode* cur = dummyHead;
        int carried = 0;
        while(p1 || p2 ){
            int a = p1 ? p1->val : 0;
            int b = p2 ? p2->val : 0;
            cur->next = new ListNode((a + b + carried) % 10);
            carried = (a + b + carried) / 10;

            cur = cur->next;
            p1 = p1 ? p1->next : NULL;
            p2 = p2 ? p2->next : NULL;
        }

        cur->next = carried ? new ListNode(1) : NULL;
        ListNode* ret = dummyHead->next;
        delete dummyHead;
        return ret;
    }
};
```
<a name="i5g5k"></a>
#### Java
```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead;
        int carry = 0;

        while(l1 != null || l2 != null)
        {
            int sum = carry;
            if(l1 != null)
            {
                sum += l1.val;
                l1 = l1.next;
            }
            if(l2 != null)
            {
                sum += l2.val;
                l2 = l2.next;
            }
            // 创建新节点
            carry = sum / 10;
            cur.next = new ListNode(sum % 10);
            cur = cur.next;
    
        }
        if (carry > 0) {
            cur.next = new ListNode(carry);
        }
        return dummyHead.next;
    }
}
```
<a name="R6uDn"></a>
#### Python
```python
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        res=ListNode(0)
        head=res
        carry=0
        while l1 or l2 or carry!=0:
            sum=carry
            if l1:
                sum+=l1.val
                l1=l1.next
            if l2:
                sum+=l2.val
                l2=l2.next
            # set value
            if sum<=9:
                res.val=sum
                carry=0
            else:
                res.val=sum%10
                carry=sum//10
            # creat new node
            if l1 or l2 or carry!=0:
                res.next=ListNode(0)
                res=res.next
        return head
```
<a name="xSdSZ"></a>
# #003 无重复字符的最长子串
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 3 号问题：无重复字符的最长子串。题目难度为 Medium，目前通过率为 29.0% 。
<a name="KsqG3"></a>
### 题目描述
给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。<br />**示例 1:**
```java
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
<a name="JKedt"></a>
### 题目解析
建立一个256位大小的整型数组 freg ，用来建立字符和其出现位置之间的映射。<br />维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。

- （1）如果当前遍历到的字符从未出现过，那么直接扩大右边界；
- （2）如果当前遍历到的字符出现过，则缩小窗口（左边索引向右移动），然后继续观察当前遍历到的字符；
- （3）重复（1）（2），直到左边索引无法再移动；
- （4）维护一个结果res，每次用出现过的窗口大小来更新结果 res，最后返回 res 获取结果。
<a name="SJfX0"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722141986-a2631253-0d9b-4bfc-95c5-0507387fb856.gif#averageHue=%23fdfcfc&clientId=u56574840-1b68-4&from=url&id=U6CsV&originHeight=529&originWidth=957&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5188bc81-dcde-4cf1-b36b-52dc09493a8&title=)
<a name="WENIS"></a>
### 代码实现
```
// 滑动窗口
// 时间复杂度: O(len(s))
// 空间复杂度: O(len(charset))
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int freq[256] = {0};
        int l = 0, r = -1; //滑动窗口为s[l...r]
        int res = 0;
        // 整个循环从 l == 0; r == -1 这个空窗口开始
        // 到l == s.size(); r == s.size()-1 这个空窗口截止
        // 在每次循环里逐渐改变窗口, 维护freq, 并记录当前窗口中是否找到了一个新的最优值
        while(l < s.size()){
            if(r + 1 < s.size() && freq[s[r+1]] == 0){
                r++;
                freq[s[r]]++;
            }else {   //r已经到头 || freq[s[r+1]] == 1
                freq[s[l]]--;
                l++;
            }
            res = max(res, r-l+1);
        }
        return res;
    }
};
```
<a name="OU8RX"></a>
# #004 寻找两个正序数组的中位数
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 4 号问题：寻找两个正序数组的中位数。题目难度为 Hard，目前通过率为 29.0% 。
<a name="Kv420"></a>
#### 题目描述
给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。<br />请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br />你可以假设 nums1 和 nums2 不会同时为空。
```java
示例1：
nums1 = [1, 3]
nums2 = [2]
    
则中位数是 2.0
    
示例2：
nums1 = [1, 2]
nums2 = [3, 4]
    
则中位数是 (2 + 3)/2 = 2.5
```
<a name="OJiEN"></a>
#### 题目解析
这道题网络上的解析都非常“高深”，很难理解。私以为它们都将简单的问题复杂化了。本题在一些处理上确实会有些麻烦，比如数组边界的处理，和偶数个数的中位数的处理。但其核心思想并不复杂。<br />首先，我们可以只考虑数字总个数为奇数的情况。让我们看下下图：<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693391569817-81a0e62d-f520-4de3-962d-7da42bb6d4b9.png#averageHue=%23fdf6f2&from=url&id=ls4mD&originHeight=586&originWidth=1271&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />蓝框是中位数左边的数（包括中位数），而橘框则为中位数右边的数。<br />3个显然的规则：<br />1.两个数组的蓝框总个数=(数字总个数+1)/2;<br />2.所有蓝框内的数都小于橘框内的数<br />3.中位数为蓝框中最大的那一位（即数组1蓝框最后一位，或数组2蓝框最后一位）<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693391569940-a9da584f-882a-4eaa-8bf6-6b51b7a69f05.png#averageHue=%23fcf0e8&from=url&id=U6EQP&originHeight=234&originWidth=1188&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />如图，我们要找到一组A，B，满足上面3条规则。<br />对于规则1，我们在数组1中找任意A，然后根据规则1就能推算出对应的B的位置。<br />对于规则2，由于数组1和2都是有序数组，即X1<A<Y1;X2<B<Y2。我们实际上只需要判断A是否小于Y2，以及B是否小于Y1。<br />对于规则3，由于数组1和2都是有序数组，因此中位数为A,B中较大的那一项。<br />那么具体该如何操作呢?<br />由于数组1和2都是有序数组，且题目要求O(log(m+n))复杂度，我们明显应考虑二分法。<br />**情况1：**<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693391570037-15e70cdc-e539-4d7a-bb71-9f193060d78e.png#averageHue=%23fdf9f6&from=url&id=k4Z6v&originHeight=600&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />首先，我们选择数组1进行操作。取其中间值9 。（因此 A=9) 根据规则1,我们在数组2中找到对应值（B = 4）。（一共有11个数，(11+1) / 2 = 6，因此蓝色框总数为6）<br />紧接着，我们根据规则2判断A(9)是否小于B.next(5)，以及B(4)是否小于A.next(11)。<br />显然，A比B.next,也就是一个橘框还要大。这是不允许的。可见A只能取比9更小的数字了。如果取更大的数字，那B就会更小，更不可能满足规则2。所以这种情况下我们要向左进行二分。<br />**情况2：**<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693391570141-f26764a0-6660-4b7c-86aa-5fbd4f9f9a64.png#averageHue=%23fdf9f6&from=url&id=FsQLO&originHeight=600&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />这种情况下B比A.next,也就是一个橘框还要大。这是不允许的。可见A只能取比9更大的数字了。如果取更小的数字，那B就会更大，更不可能满足规则2。所以这种情况下我们要向右进行二分。<br />**情况3：**<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693391570256-9c4158d2-45c9-4be0-bfd9-9b31da48d7cf.png#averageHue=%23fdf9f6&from=url&id=HfTXu&originHeight=600&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />随着我们不断地二分，中位数显然必然会出现。<br />如图上这种情况，A小于B.next，且B小于A.next。<br />那么，显然，A,B中较大的那一项就是中位数（规则3）。<br />本题算法的核心思想就是这样简单。此外，当数字总数为偶数时，我们需要把我们求得的“中位数"与它下一项相加并除以2即可。由于本题中数字可能相同，所以大小的比较需要使用>=和<=。<br />下面提供了作者的一份代码，leetcode上的结果为：执行用时：2 ms；内存消耗：40.3 MB，都超过了100%的用户。读者可以参考一下。
<a name="Hpdwi"></a>
#### 代码实现
Java语言
```java
public class Solution {
  public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    // 使nums1成为较短数组,不仅可以提高检索速度,同时可以避免一些边界问题
    if (nums1.length > nums2.length) {
      int[] temp = nums1;
      nums1 = nums2;
      nums2 = temp;
    }

    int len1 = nums1.length;
    int len2 = nums2.length;
    int leftLen = (len1 + len2 + 1) / 2; //两数组合并&排序后,左半边的长度
    
    // 对数组1进行二分检索
    int start = 0;
    int end = len1;
    while (start <= end) {
      // 两个数组的被测数A,B的位置(从1开始计算)
      // count1 = 2 表示 num1 数组的第2个数字
      // 比index大1
      int count1 = start + ((end - start) / 2);
      int count2 = leftLen - count1;
      
      if (count1 > 0 && nums1[count1 - 1] > nums2[count2]) {
        // A比B的next还要大
        end = count1 - 1;
      } else if (count1 < len1 && nums2[count2 - 1] > nums1[count1]) {
        // B比A的next还要大
        start = count1 + 1;
      } else {
        // 获取中位数
        int result =  (count1 == 0)? nums2[count2 - 1]: // 当num1数组的数都在总数组右边
                      (count2 == 0)? nums1[count1 - 1]: // 当num2数组的数都在总数组右边
                      Math.max(nums1[count1 - 1], nums2[count2 - 1]); // 比较A,B
        if (isOdd(len1 + len2)) {
          return result;
        }

        // 处理偶数个数的情况
        int nextValue = (count1 == len1) ? nums2[count2]:
                        (count2 == len2) ? nums1[count1]:
                        Math.min(nums1[count1], nums2[count2]);
        return (result + nextValue) / 2.0;
      }
    }

    return Integer.MIN_VALUE; // 绝对到不了这里
  }

  // 奇数返回true,偶数返回false
  private boolean isOdd(int x) {
    return (x & 1) == 1;
  }
}
```
<a name="nhMIr"></a>
#### 动画理解
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=cmKC7&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="QMKFP"></a>
#### 复杂度分析

- 时间复杂度：对数组进行二分查找，因此为O(logN)
- 空间复杂度：O(1)
<a name="ZNMqr"></a>
# #005 最长回文串
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 5 号问题：最长回文串。题目难度为 Medium，目前通过率为 29% 。
<a name="OUGW4"></a>
## 题目描述
给定一个字符串，要求这个字符串当中最长的回文串。
<a name="B6Rs2"></a>
## 示例
```
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
```
```
Input: "cbbd"
Output: "bb"
```
<a name="K4FLb"></a>
## 题目分析
这道题目是典型的看着简单，但是实际上并不简单的问题。<br />我们先从简单的算法开始，最简单的方法当然是暴力。由于我们需要求出最长的回文串，一种方法是求出s串所有的子串，然后一一对比它们是否构成回文。这样当然是可行的，但是我们简单分析一下复杂度就会发现，这并不能接受。对于一个长度为n的字符串来说，我们任意选择其中两个位置，就可以找到它的一个子串，那么我们选择两个位置的数量就是<br />$C_n%5E2%20%3D%20%5Cfrac%7Bn(n-1)%7D%7B2%7D$。对于每一个子串，我们需要遍历一遍才能判断是否回文，所以整体的复杂度是$O(n%5E3)$。<br />但是如果你对回文串非常熟悉的话，会发现其实这是可以优化的。因为我们要求的是最长的回文串，如果我们确定了对称中心的位置，它能够构成的最长回文串就是确定的。所以我们只需要遍历所有的回文串中心，和每个中心能找到的最长回文串。这样我们的复杂度就降低了一维，变成了<br />$O(n%5E2)$。<br />回文串有两种形式，一种是奇回文，也就是回文中心是一个字符，比如aba。还有一种是偶回文，回文中心是两个字符之间，比如abba。这两种情况我们需要分开讨论。<br />我们写出代码：
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        
        ret = ''
        for i in range(n):
            # 奇回文的情况
            l, r = i, i
            while s[l] == s[r]:
                l -= 1
                r += 1
                if l < 0 or r >= n:
                    break
            if r - l - 1 > len(ret):
                ret = s[l+1: r]
            
            # 偶回文的情况
            l, r = i-1, i
            while l >= 0 and s[l] == s[r]:
                l -= 1
                r += 1
                if l < 0 or r >= n:
                    break
            if r - l - 1 > len(ret):
                ret = s[l+1: r]
                
        return ret
```
到这里还没有结束，接下来我们介绍一个经典的回文串求解算法——Manacher，也叫做马拉车算法。<br />首先，我们需要统一奇回文和偶回文这两种情况，这也很方便，我们把原串进行处理，在两个相邻字符当中插入一个分隔字符#，比如abcd转化成#a#b#c#d#。一般我们还会在首尾加入防止超界的字符，比如$&等。之后我们维护两个值，分别是id和mr。mr表示当前能够构成的回文串向右延伸最远的位置，id表示这个位置对应的对称中心。根据这个位置id以及mr我们可以快速地求解出当前位置i能够构成的合法回文串的长度。<br />我们假设每一个位置构成的合法回文串半径是p[i], 那么对于i这个位置，我们可以得到p[i] >= min(mr - i, p[id _ 2 - i])。其中id _ 2 - i是i这个位置关于id的对称位置，并且以i为中心对称的回文串小于mr位置的部分也关于id对称。所以如果p[id _ 2 - i] < mr - i的话，说明i关于id的对称位置没能突破id对称的限制，既然i的对称点没有能突破限制，那么i显然也不行。同理，如果p[id _ 2 - i] > mr - i的话，说明i的对称位置没有被id限制住，但是这恰恰说明i被限制住了。因为如果i也能突破mr这个限制的话，那么说明id的对称范围还能扩大，这和我们的前提假设矛盾了。所以只有p[id * 2 - i] == mr - i的情况，i才有可能继续延伸。<br />如果能理解上面的关系，整个算法已经很清楚了，如果没看懂也没有关系，可以看下下面的动图，会展示得更加清楚。<br />理解了上述的算法过程之后剩下的工作就简单了，我们只需要在求解p[i]的同时维护id和mr即可。<br />最后我们来看下算法的复杂度，为什么这是一个O(n)的算法呢？原因很简单，我们只需要关注mr这个变量即可。mr这个变量是递增的，mr每次递增的大小，其实就是p[i] - (mr - i)的长度。所以虽然看似我们用了两重循环，但是由于mr最多只能递增n次，所以它依然是O(n)的算法。
<a name="lq3MY"></a>
#### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391571566-3cc8e84a-bc6c-47d0-8bc2-8067caf84997.gif#averageHue=%23ffffff&from=url&id=uhByW&originHeight=360&originWidth=480&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="HgHQn"></a>
#### 代码实现
```python
class Solution:
    
    def longestPalindrome(self, s: str) -> str:
        # 在所有字符中间插入#
        def transform(s):
            return '$#' + '#'.join(list(s)) + '#&'
        
        if s == '':
            return s
        # 初始化
        s = transform(s)
        p = [0 for _ in range(len(s)+1)]
        mr, id_ = 0, 0
        # 首尾是特殊字符，所以下标从1到len(s)-2
        for i in range(1, len(s)-1):
            # 计算p[i]
            p[i] = 1 if mr <= i else min(p[2*id_-i], mr - i)

            # 只有当前i已经摆脱id限制，或者是第三种情况时，才有可能继续延伸
            # 这个只是优化，不加这个判断一样可以运行
            if mr <= i or p[2*id_-i] == mr - i:
                while s[i - p[i]] == s[i + p[i]]:
                    p[i] += 1

                if i + p[i] > mr:
                    mr, id_ = i + p[i], i
        # 找到长度最长的下标
        id_ = p.index(max(p))
        # 获得整个回文的字符串
        palindromic = s[id_ - p[id_]+1: id_ + p[id_]]
        # 过滤掉#，还原为原字符
        return ''.join(filter(lambda x: x != '#', list(palindromic)))
```

1. LeetCode 第 6 号问题：蛇形矩阵

本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 6 号问题：蛇形矩阵。题目难度为 Medium，目前通过率为 35.1% 。
<a name="TM3Ry"></a>
## 题目描述
给定一个字符串，和一个整数n，将它排列成一个n行的蛇形返回。
<a name="cgmDU"></a>
## 示例
```
P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);
Example 1:

Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
Example 2:

Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:

P     I    N
A   L S  I G
Y A   H R
P     I
```
给定字符串和蛇形排列占据的行数，要求返回重新排列后的串
<a name="tvQ65"></a>
## 题目解析
这道题是一道模拟题，题目的要求就是答案，我们只需要读懂题意就很容易实现。<br />我们最终要输出的是以蛇形摆放之后的字符串再按行串联在一起之后的结果，也就是说每一个字母摆放的列并不重要，重要的是摆放的行号。我们可以很容易想到通过数组维护每一行当中摆放的字母，最后将每一行的结果串联即可。所以问题就只剩下了，我们如何知道每一个字母应该摆放在哪一行？<br />其实这也是有规律的，我们通过观察样例可以发现，我们每一个字母摆放的行号先是从0递增到n-1，再从n-1递减到0。我们就模拟这个过程，一个字符一个字符的放置即可。<br />比如字符串是“PAYPALISHIRING ”，rowNum=4。我们可以创建四个空串：<br />“”<br />“”<br />“”<br />“”<br />然后我们按照蛇形一个字母一个字母地放进这些空串当中：<br />当放了第一个字母p之后，变成：<br />“p”<br />“”<br />“”<br />“”<br />接着放第二个：<br />“p”<br />“a”<br />“”<br />“”<br />接着第三个：<br />“p”<br />“a”<br />“y”<br />“”<br />当我们把所有字母都放完了之后，可以得到这样的四个串：<br />“PIN”<br />“ALSIG”<br />“YAHR”<br />“PI”<br />然后把这四串拼接在一起就行了。
<a name="x9kSt"></a>
#### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391573523-7d2ebe77-5740-468b-bd0d-6cb6a3560904.gif#averageHue=%23ffffff&from=url&id=BPO7r&originHeight=360&originWidth=480&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="QWzpm"></a>
#### 代码实现
```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        # 记录每一行摆放的字母
        rows = ['' for _ in range(numRows)]
        # 记录当前行号
        cur_row = 0
        # 记录当前摆放顺序是否从上往下， False代表从下往上
        forward = True
        # numRows = 1直接返回
        if numRows == 1:
            return s
        
        for i, c in enumerate(s):
            rows[cur_row] += c
            # 根据顺序变更行号
            if forward:
                cur_row += 1
            else:
                cur_row -= 1
            # 根据行号和当前顺序判断需不需要转向
            if cur_row == numRows - 1 and forward:
                forward = False
            
            if cur_row == 0 and not forward:
                forward = True
            
        ret = ''
        for sc in rows:
            ret += sc
        return ret
```
<a name="MPOBH"></a>
# #009 回文数
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 第 9 号问题：回文数。题目难度为 Easy，目前通过率为 56.0%。
<a name="LyfS8"></a>
## 题目描述
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br />**示例 1:**
```
输入: 121
输出: true
```
**示例 2:**
```
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```
**示例 3:**
```
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```
**进阶:**<br />你能不将整数转为字符串来解决这个问题吗？
<a name="iWAen"></a>
## 题目解析
<a name="WLRia"></a>
### 解法一：普通解法
最好理解的一种解法就是先将 **整数转为字符串** ，然后将字符串分割为数组，只需要循环数组的一半长度进行判断对应元素是否相等即可。
<a name="OnCvj"></a>
#### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722167257-c9eedc0e-20d9-4107-9b3b-515b1d556359.gif#averageHue=%23fdfdfd&clientId=u56574840-1b68-4&from=url&id=kxivN&originHeight=598&originWidth=959&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf6865eeb-51bb-4054-a847-ffdcb1d5193&title=)
<a name="QsCVJ"></a>
#### 代码实现
```java
///简单粗暴，看看就行
class Solution {
    public boolean isPalindrome(int x) {
        String reversedStr = (new StringBuilder(x + "")).reverse().toString();
        return (x + "").equals(reversedStr);
    }
}
```
<a name="OlT7m"></a>
### 解法二：进阶解法---数学解法
通过取整和取余操作获取整数中对应的数字进行比较。<br />举个例子：1221 这个数字。

- 通过计算 1221 / 1000， 得首位1
- 通过计算 1221 % 10， 可得末位 1
- 进行比较
- 再将 22 取出来继续比较
<a name="B6pvE"></a>
#### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722167269-821e41d5-dd50-4084-8e91-d3b8b6d6de5c.gif#averageHue=%23f8bc07&clientId=u56574840-1b68-4&from=url&id=pkEz8&originHeight=712&originWidth=991&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue14e0a7b-cb58-45f5-ae73-b9cb1d42973&title=)
<a name="WxYso"></a>
#### 代码实现
```java
class Solution {
    public boolean isPalindrome(int x) {
        //边界判断
        if (x < 0) return false;
        int div = 1;
        //
        while (x / div >= 10) div *= 10;
        while (x > 0) {
            int left = x / div;
            int right = x % 10;
            if (left != right) return false;
            x = (x % div) / 10;
            div /= 100;
        }
        return true;
    }
}
```
<a name="k6rii"></a>
### 解法三：进阶解法---巧妙解法
直观上来看待回文数的话，就感觉像是将数字进行对折后看能否一一对应。<br />所以这个解法的操作就是 **取出后半段数字进行翻转**。<br />这里需要注意的一个点就是由于回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。<br />具体做法如下：

- 每次进行取余操作 （ %10），取出最低的数字：y = x % 10
- 将最低的数字加到取出数的末尾：revertNum = revertNum * 10 + y
- 每取一个最低位数字，x 都要自除以 10
- 判断 x 是不是小于 revertNum ，当它小于的时候，说明数字已经对半或者过半了
- 最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。
<a name="cXW6L"></a>
#### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693722167489-2d9470e1-352c-48f5-8e7e-7d8c00ade4c9.png#averageHue=%23db412c&clientId=u56574840-1b68-4&from=url&id=NPdKy&originHeight=1366&originWidth=2004&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc07c6e92-3b4e-4543-b07c-f20982285fe&title=)
<a name="gwVvn"></a>
#### 代码实现
```java
class Solution {
    public boolean isPalindrome(int x) {
        //思考：这里大家可以思考一下，为什么末尾为 0 就可以直接返回 false
        if (x < 0 || (x % 10 == 0 && x != 0)) return false;
        int revertedNumber = 0;
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }
        return x == revertedNumber || x == revertedNumber / 10;
    }
}
```
<a name="OPMlk"></a>
## LeetCode第11号问题：盛水最多的容器
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步个人博客：www.zhangxiaoshuai.fun<br />**本题选自leetcode的第11题，medium级别，目前通过率：61.3%**<br />**题目描述：**
```
给你n个非负整数a1，a2，...，an，每个数代表坐标中的一个点(i,ai)。在坐标内画n条垂直线，
垂直线i的两个端点分别为(i,ai)和(i,0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。
说明：你不能倾斜容器，且n的值至少为2。
示例：
输入：[1,8,6,2,5,4,8,3,7]
输出：49
```
我们都应该听说过**木桶原理**，一个木桶可以装入多少水取决于最短的那块板；而这道题也可以与木桶装水的问题对应上。<br />很容易的可以得到---->**容器可以容纳水的容量=两条垂直线中最短的那条_两条线之间的距离_<br />现在的情况是，有很多条线，让你计算两两之间能装的最多的水，其实暴力法之间就能解决这个问题，但是它的时间复杂度也达到了**O(n^2)**<br />ok，那我们先试试用**暴力法**来解 决问题：
<a name="u46Bj"></a>
### 1.暴力法
直接上代码：
```java
public int maxArea(int[] height) {
    int res = 0;
    for(int i = 0;i < height.length;i++){
      for(int j = i+1;j < height.length;j++){
        int temp = Math.min(height[i],height[j]) * (j-i);
        res = Math.max(res,temp);
      }
    }
    return res;
}
```
暴力法是可以通过测试的，但是可以看到**程序执行用时**并不理想
```
执行用时 :440 ms, 在所有 Java 提交中击败了17.44% 的用户
内存消耗 :39.9 MB, 在所有 Java 提交中击败了37.86%的用户
```
<a name="t8Irc"></a>
### 2.双指针
思路：使用两个指针（**resource**和**last**）分别指向数组的第一个元素和最后一个元素，然后我们计算这两条“线”之间能容纳的水的容量，并更新最大容量（初始值为0）；接着我们需要将指向元素值小的那个指针前移一步，然后重复上面的步骤，直到**resource = last**循环截止。<br />**GIF动画演示：**<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391576298-8d499eb3-38ce-45b2-b984-17e0bb4a68be.gif#averageHue=%23ececec&from=url&id=UQoou&originHeight=480&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />**来看看代码：**
```java
public int maxArea(int[] height) {
    int resource = 0;
    int last = height.length - 1;
    int res = 0;
    while (resource < last) {
        if (height[resource] >= height[last]) {
            res = Math.max(res, (last - resource) * height[last]);
            last--;
        } else {
            res = Math.max(res, (last - resource) * height[resource]);
            resource++;
        }
    }
    return res;
}
```
**可以很明显的看到，虽然内存消耗两者是差不多的，但是双指针的速度比暴力解法的速度可是高出好多倍。**<br />时间复杂度：**O(n)**	空间复杂度：**O(1)**
```
执行用时 :3 ms, 在所有 Java 提交中击败了92.69% 的用户
内存消耗 :40.3 MB, 在所有 Java 提交中击败了7.86%的用户
```
[视频演示](https://inspidea.yuque.com/attachments/yuque/0/2023/mp4/35495747/1693391576594-733a9dac-31b5-4af2-9213-abed3f1921ee.mp4)

本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 15 号问题：三数之和。
<a name="Sq1zN"></a>
### 题目描述
给定一个包含 _n_ 个整数的数组 nums，判断 nums 中是否存在三个元素 _a，b，c ，_使得 _a + b + c =_ 0 ？找出所有满足条件且不重复的三元组。
<a name="MtSsY"></a>
### 题目解析
题目需要我们找出三个数且和为 0 ，那么除了三个数全是 0 的情况之外，肯定会有负数和正数，所以一开始可以先选择一个数，然后再去找另外两个数，这样只要找到两个数且和为第一个选择的数的相反数就行了。也就是说需要枚举 a 和 b ，将 c 的存入 map 即可。<br />需要注意的是返回的结果中，不能有有重复的结果。这样的代码时间复杂度是 O(n^2)。在这里可以先将原数组进行排序，然后再遍历排序后的数组，这样就可以使用双指针以线性时间复杂度来遍历所有满足题意的两个数组合。
<a name="OrLuG"></a>
### 动画描述
待补充
<a name="ginLK"></a>
### 代码实现
```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        if (nums.empty() || nums.back() < 0 || nums.front() > 0) return {};
        for (int k = 0; k < nums.size(); ++k) {
            if (nums[k] > 0) break;
            if (k > 0 && nums[k] == nums[k - 1]) continue;
            int target = 0 - nums[k];
            int i = k + 1, j = nums.size() - 1;
            while (i < j) {
                if (nums[i] + nums[j] == target) {
                    res.push_back({nums[k], nums[i], nums[j]});
                    while (i < j && nums[i] == nums[i + 1]) ++i;
                    while (i < j && nums[j] == nums[j - 1]) --j;
                    ++i; --j;
                } else if (nums[i] + nums[j] < target) ++i;
                else --j;
            }
        }
        return res;
    }
};
```
<a name="ViLo8"></a>
# #015 三数之和
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 15 号问题：三数之和。
<a name="E7Xrs"></a>
### 题目描述
给定一个包含 _n_ 个整数的数组 nums，判断 nums 中是否存在三个元素 _a，b，c ，_使得 _a + b + c =_ 0 ？找出所有满足条件且不重复的三元组。<br />**注意：**答案中不可以包含重复的三元组。
<a name="rjUrH"></a>
#### 示例
```
给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```
<a name="uo5MC"></a>
### 题目解析
最容易想到的就是三重循环暴力法搜索，时间复杂度为 O(n^3). 有点高啊，优化一下.<br />通过题目我们了解到，主要问题在于 搜索所有满足条件的情况 和 避免重复项，那么我们可以使用 升序数组 + 双指针 有效处理问题并降低时间复杂度.<br />你可能想知道为啥会选择使用这个方案 ？<br />首先数组排序时间复杂度可以达到 O(NlogN)，这点时间消耗我们是能接受的，另外根据有序数组的特性，数组重复项会挨在一起，不需要额外的空间存储就能跳过重复项，由于是升序，当发现最左边的数值大于0，就可以及时跳出来结束运算.<br />双指针可以用来降维. 通过遍历数组，取当前下标值为定值，双指针代表定值后面子数组的首尾数值，通过不断靠近双指针来判断三个值的和。<br />具体算法流程如下：

1. 特判：对于数组长度 n，如果数组为 null 或者数组长度小于 3，返回[ ] ;
2. 数组升序排序；
3. 遍历数组： 
   - 若 num[i] > 0：因为是升序，所以结果不可能等于0，直接返回结果；
   - 令左指针 L = i + 1，右指针 R = n - 1，当 L < R 时，执行循环： 
      - 当 nums[i] + nums[L] + nums[R] == 0 ，执行循环，判断左指针和右指针是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解；
      - 若和大于 0，说明 nums[R] 太大，R指针 左移
      - 若和小于 0，说明 nums[L] 太小，L指针 右移
<a name="QHpIa"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=YDHiu&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="inZfY"></a>
### 参考代码
```javascript
// lang = JavaScript
var threeSum = function(nums) {
    let res = [];
    if (nums == null || nums.length < 3) {
        return res;
    }
    const len = nums.length;
    nums.sort((a, b) => a - b); // 升序
    for (let i = 0; i < len - 2;) {
        const element = nums[i];
        if (element > 0) {
            // 如果当前数字大于0，则三数之和一定大于0，所以结束循环
            break;
        }  
        let L = i + 1,
            R = len - 1;
        while (L < R) {
            const sum = element + nums[L] + nums[R];
            if (sum == 0) {
                res.push([element, nums[L], nums[R]]);
                // 左右指针去重 & L+1 & R-1
                while (L < R && nums[L] == nums[++L]);
                while (L < R && nums[R] == nums[--R]);
            }else if (sum < 0) {
                while (L < R && nums[L] == nums[++L]);
            }else {
                while (L < R && nums[R] == nums[--R]);
            }
        }
        //  定值去重
        while (nums[i] == nums[++i]);
    }
    return res;
};
```
<a name="COBhi"></a>
### 复杂度分析

- 时间复杂度：O(n^2)数组排序 O(NlogN), 遍历数组O(n), 双指针遍历 O(n), 总体复杂度为 O(NlogN) + O(n) * O(n) ，O(n^2)
- 空间复杂度：O(1)
<a name="tq3fb"></a>
# #019 删除链表的倒数第 N 个节点
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 19 号问题：删除链表的倒数第 N 个节点。题目难度为 Medium，目前通过率为 34.4% 。
<a name="LhAs5"></a>
### 题目描述
给定一个链表，删除链表的倒数第 _n_ 个节点，并且返回链表的头结点。<br />**示例：**
```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```
**说明：**<br />给定的 _n_ 保证是有效的。<br />**进阶：**<br />你能尝试使用一趟扫描实现吗？
<a name="Hu2Sz"></a>
### 题目解析
采取双重遍历肯定是可以解决问题的，但题目要求我们一次遍历解决问题，那我们的思路得发散一下。<br />我们可以设想假设设定了双指针p和q的话，当q指向末尾的NULL，p与q之间相隔的元素个数为n时，那么删除掉p的下一个指针就完成了要求。

- 设置虚拟节点dummyHead指向head
- 设定双指针p和q，初始都指向虚拟节点dummyHead
- 移动q，直到p与q之间相隔的元素个数为n
- 同时移动p与q，直到q指向的为NULL
- 将p的下一个节点指向下下个节点
<a name="dnYaS"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722195180-2a297df7-7e57-4367-81b4-6a47ffb9c252.gif#averageHue=%23fdfcfc&clientId=u56574840-1b68-4&from=url&id=Vvn2S&originHeight=539&originWidth=959&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uad4f6a75-cbc4-4e93-8f3c-6f29da55f01&title=)
<a name="Gp9CI"></a>
### 代码实现
```
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
     ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;

        ListNode* p = dummyHead;
        ListNode* q = dummyHead;
        for( int i = 0 ; i < n + 1 ; i ++ ){
            q = q->next;
        }

        while(q){
            p = p->next;
            q = q->next;
        }

        ListNode* delNode = p->next;
        p->next = delNode->next;
        delete delNode;

        ListNode* retNode = dummyHead->next;
        delete dummyHead;

        return retNode;
        
    }
};
```
<a name="GcC23"></a>
# #020 有效的括号
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 20 号问题：有效的括号。题目难度为 Easy，目前通过率为 37.8% 。
<a name="EYpdq"></a>
### 题目描述
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。<br />有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。<br />**示例 1:**
```
输入: "()"
输出: true
```
**示例 2:**
```
输入: "()[]{}"
输出: true
```
**示例 3:**
```
输入: "(]"
输出: false
```
**示例 4:**
```
输入: "([)]"
输出: false
```
**示例 5:**
```
输入: "{[]}"
输出: true
```
<a name="gUdxT"></a>
### 题目解析
这道题让我们验证输入的字符串是否为括号字符串，包括大括号，中括号和小括号。<br />这里我们使用**栈**。

- 遍历输入字符串
- 如果当前字符为左半边括号时，则将其压入栈中
- 如果遇到右半边括号时，**分类讨论：**
- 1）如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环
- 2）若此时栈为空，则直接返回false
- 3）若不为对应的左半边括号，反之返回false
<a name="IkPXR"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722200481-240c0da1-830d-48dd-87fb-72d271cf3a93.gif#averageHue=%23fdfdfd&clientId=u56574840-1b68-4&from=url&id=oQ24S&originHeight=540&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u00676d9f-f1ac-4c36-a610-382b005da29&title=)
<a name="V4bHb"></a>
### 代码实现
```
class Solution {
public:
    bool isValid(string s) {

        stack<char> stack;
        for( int i = 0 ; i < s.size() ; i ++ )
            if( s[i] == '(' || s[i] == '{' || s[i] == '[')
                stack.push(s[i]);
            else{

                if( stack.size() == 0 )
                    return false;

                char c = stack.top();
                stack.pop();

                char match;
                if( s[i] == ')' ){
                    match = '(';
                }
                else if( s[i] == ']' ){
                    match = '[';
                }
                else{
                    match = '{';
                }

                if(c != match)  return false;
            }

        if( stack.size() != 0 )
            return false;

        return true;
    }
};
```
<a name="RoUrE"></a>
# #021 合并两个有序链表
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 21 号问题：合并两个有序链表。题目难度为 Easy，目前通过率为 45.8% 。
<a name="hCKSA"></a>
### 题目描述
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br />**示例：**
```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```
<a name="mdkKE"></a>
### 题目解析
<a name="zvUwO"></a>
#### 一般方案
<a name="uDfi9"></a>
##### 1.1 解题思想
（1）对空链表存在的情况进行处理，假如 pHead1 为空则返回 pHead2 ，pHead2 为空则返回 pHead1。（两个都为空此情况在pHead1为空已经被拦截）<br />（2）在两个链表无空链表的情况下确定第一个结点，比较链表1和链表2的第一个结点的值，将值小的结点保存下来为合并后的第一个结点。并且把第一个结点为最小的链表向后移动一个元素。<br />（3）继续在剩下的元素中选择小的值，连接到第一个结点后面，并不断next将值小的结点连接到第一个结点后面，直到某一个链表为空。<br />（4）当两个链表长度不一致时，也就是比较完成后其中一个链表为空，此时需要把另外一个链表剩下的元素都连接到第一个结点的后面。
<a name="o1JRQ"></a>
##### 1.2 代码实现
```
ListNode* mergeTwoOrderedLists(ListNode* pHead1, ListNode* pHead2){
    ListNode* pTail = NULL;//指向新链表的最后一个结点 pTail->next去连接
    ListNode* newHead = NULL;//指向合并后链表第一个结点
    if (NULL == pHead1){
        return pHead2;
    }else if(NULL == pHead2){
        return pHead1;
    }else{
        //确定头指针
        if ( pHead1->data < pHead2->data){
            newHead = pHead1;
            pHead1 = pHead1->next;//指向链表的第二个结点
        }else{
            newHead = pHead2;
            pHead2 = pHead2->next;
        }
        pTail = newHead;//指向第一个结点
        while ( pHead1 && pHead2) {
            if ( pHead1->data <= pHead2->data ){
                pTail->next = pHead1;  
                pHead1 = pHead1->next;
            }else {
                pTail->next = pHead2;
                pHead2 = pHead2->next;
            }
            pTail = pTail->next;

        }
        if(NULL == pHead1){
            pTail->next = pHead2;
        }else if(NULL == pHead2){
            pTail->next = pHead1;
        }
        return newHead;
}
```
<a name="ki85k"></a>
#### 2 递归方案
<a name="rRMGT"></a>
##### 2.1 解题思想
（1）对空链表存在的情况进行处理，假如 pHead1 为空则返回 pHead2 ，pHead2 为空则返回 pHead1。<br />（2）比较两个链表第一个结点的大小，确定头结点的位置<br />（3）头结点确定后，继续在剩下的结点中选出下一个结点去链接到第二步选出的结点后面，然后在继续重复（2 ）（3） 步，直到有链表为空。
<a name="hclbB"></a>
##### 2.2 代码实现
```
ListNode* mergeTwoOrderedLists(ListNode* pHead1, ListNode* pHead2){
    ListNode* newHead = NULL;
    if (NULL == pHead1){
        return pHead2;
    }else if(NULL ==pHead2){
        return pHead1;
    }else{
        if (pHead1->data < pHead2->data){
            newHead = pHead1;
            newHead->next = mergeTwoOrderedLists(pHead1->next, pHead2);
        }else{
            newHead = pHead2;
            newHead->next = mergeTwoOrderedLists(pHead1, pHead2->next);
         }
        return newHead;
    }   
}
```
<a name="crmW9"></a>
# #022 生成所有的括号对
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 22 号问题：生成所有的括号对。题目难度为 Medium，目前通过率为 60.9% 。
<a name="kXmL5"></a>
### 题目描述
给定数字n，要求使用n对()括号生成所有合法的组合情况。<br />**示例**
```
3

[
"((()))",
"(()())",
"(())()",
"()(())", 
"()()()"
]
```
<a name="RLih6"></a>
### 题目解析
<a name="Mmvo0"></a>
#### 解法一： 暴力
暴力的解法应该最容易想到，因为n是确定的，也就是说一共有n个左括号和n个右括号。很容易想到，我们可以对这2n个字符进行排列组合，之后再对所有的组合进行过滤。留下合法的且不重复的即可。<br />伪代码很容易写：
```python
def brute_force(str, l, r):
    if l == n and r == n:
        ans.append(str)
    if l < n:
        brute_force(str+'(', l+1, r)
    if r < n:
        brute_force(str+')', l, r+1)
```
写完了再根据结果判断是否合法，留下合法的所有情况即可。<br />这样编码的确不难，而且也很容易想到，但是计算n个字符的排列组合复杂度是 <br />$O(2%5En)$ 是一个指数级的算法，复杂度是我们不能接受的。而且根据上一题当中的结论，在匹配括号的时候是可以取巧的，我们其实没必要把所有的情况都枚举到。因为想要括号匹配合法，必须有一条，对于字符串当中的任何一个位置i，都必须有：前i个字符中所有左括号的数量大于等于右括号的数量。<br />，否则就是非法的。<br />也就是说必须要保证任意一个位置右括号的数量小于等于左括号的数量，不然的话，多余的右括号永远也无法匹配。
<a name="HaAlF"></a>
#### 解法二： 回溯
既然左括号的数量必须大于右括号的数量，我们完全可以据此进行优化。我们在递归的时候对l和r进行大小判断，保证所有时刻都有l >= r即可。<br />代码：
```
class Solution {
public:

    void dfs(int n, int l, int r, string str, vector<string>& vt) {
        if (l+r == 2 *n) {
            vt.push_back(str);
            return ;
        }
        if (l < n) dfs(n, l+1, r, str+"(", vt);
        if (r < l) dfs(n, l, r+1, str+")", vt);
    }

    vector<string> generateParenthesis(int n) {
        vector<string> vt;
        dfs(n, 0, 0, "", vt);
        return vt;
    }
};
```
<a name="FZyc9"></a>
#### 解法三： 构造
这个方法是我原创的，官方的题解当中没有收录。<br />我们直接求解n的答案的时候是比较困难的，这个时候我们可以把问题拆解，大问题变成小问题，通过小问题的答案构造大问题的答案。上述的两种方法本质上也是一样的思路，不过递归替我们做了问题的拆分。<br />实际上我们可以自己拆分问题，n的时候我们一下子不清楚答案。我们可以先从简单的观察一下结果：比如当n1的时候，答案就是”()”。n2有两种：”()()”, “(())”。n==3的时候是5种：”((()))”, “()(())”, “()()()”, “(()())”, “(())()”。<br />细心的读者已经可以总结出规律了，其实并不难想到。<br />solution(n) = solution(i) + solution(n-i) + '(' solution(n-1) ')'<br />解释一下这个公式，这里的solution(n)表示n的所有答案串，也就是说n个括号的答案串是可以通过小于n的答案串进行组合的。比如n=1时答案是()，n=2则有两种，一种是用两个n=1拼接，第二种是在n=1的答案外层加上一个括号：<br />solution(2) = [()(), (())]<br />我们再来看solution(3)，它可以用n=1和n=2拼接，以及通过n=2外层加上单独的括号得到所有答案：<br />solution(3) = [()()(), ()(()), (())(), (()()), ((()))]<br />前面3种是通过solution(2)和solution(1)拼接得到的，后面两种则是在solution(2)外面直接加上括号得到的，这种情况是无法通过拼接得到的情况。我们把这些情况全部汇总，然后去除掉重复的情况就是答案了。<br />这样我们就用小于n的所有结果构造出了n的结果，由于n=0 和n=1的情况是已知的。我们只需要把中间结果存储下来，通过递推就可以获取所有的答案。
<a name="Qx4Ds"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391584090-3e6caf61-35d0-4076-949b-1875206e461c.gif#averageHue=%23ffffff&from=url&id=vJ1MZ&originHeight=360&originWidth=480&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="aKGos"></a>
### 代码实现
```
class Solution {
public:

    vector<string> generateParenthesis(int n) {
          // 存储所有中间结果
        map<int, set<string>> mp;
        set<string> st;
        st.insert("()");
        mp[1] = st;

        for (int i = 2; i <= n; i++) {
              // 使用set来去重
            set<string> cur;
            for (int j = 1; j <= i-1; j++) {
                  // 取出所有solution(j)和solution(i-j)
                set<string> vj = mp[j];
                set<string> vk = mp[i-j];
                for (string str:vj) {
                    for (string stj : vk) {
                        cur.insert(str + stj);
                    }
                }
            }
              // solution(i-1)最外层套上括号
            set<string> vj = mp[i-1];
            for (string str : vj) {
                cur.insert("(" + str + ")");
            }
              // 得到solution(i)
            mp[i] = cur;
        }
        vector<string> vt;
        st = mp[n];
        for (string str : st) vt.push_back(str);
        return vt;
    }
};
```
<a name="sGHue"></a>
# #023 合并 K 个排序链表
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 23 号问题：合并 K 个排序链表。题目难度为 Hard，目前通过率为 45.8% 。
<a name="y0CC1"></a>
### 题目描述
合并 _k_ 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。<br />**示例:**
```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```
**输入**<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1693722219310-a375d3bf-c67b-4493-bd3f-3b9503990352.jpeg#averageHue=%23312f32&clientId=u56574840-1b68-4&from=url&id=scbmM&originHeight=614&originWidth=2360&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7d74ed68-ba13-402c-9535-e9a00360e5b&title=)<br />**输出**<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1693722219389-6b2ffd1b-d52a-4c8c-b6a7-ebb65572d8d8.jpeg#averageHue=%23312f32&clientId=u56574840-1b68-4&from=url&id=TIjR2&originHeight=572&originWidth=2518&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua7d97bbc-4635-4298-ab24-1b8537ab764&title=)
<a name="EWksq"></a>
### 题目解析
<a name="CNd8T"></a>
### 题目分析一
这里需要将这 _k_ 个排序链表整合成一个排序链表，也就是说有多个输入，一个输出，类似于漏斗一样的概念。<br />因此，可以利用最小堆的概念。如果你对堆的概念不熟悉，可以戳这先了解一下~<br />取每个 Linked List 的最小节点放入一个 heap 中，排序成最小堆。然后取出堆顶最小的元素，放入输出的合并 List 中，然后将该节点在其对应的 List 中的下一个节点插入到 heap 中，循环上面步骤，以此类推直到全部节点都经过 heap。<br />由于 heap 的大小为始终为 k ，而每次插入的复杂度是 logk ，一共插入了 nk 个节点。时间复杂度为 O(nklogk)，空间复杂度为O(k)。
<a name="UoTLx"></a>
### 动画演示
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722219004-00f24824-2f89-44ff-ac1d-0e9e87c4f101.gif#averageHue=%232a2a2a&clientId=u56574840-1b68-4&from=url&id=Dl4FE&originHeight=507&originWidth=939&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u88aff4d0-ef31-4015-a390-2da4069c442&title=)
<a name="HldyU"></a>
### 代码实现
```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        //用heap(堆)这种数据结构，也就是 java 里面的 PriorityQueue
        PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
            public int compare(ListNode a, ListNode b) {
                return a.val-b.val;
            }
        });
        ListNode ret = null, cur = null;
        for(ListNode node: lists) {
            if(null != node) {
                pq.add(node);    
            }
        }
        while(!pq.isEmpty()) {
            ListNode node = pq.poll();
            if(null == ret) {
                ret = cur = node;
            }
            else {
                cur = cur.next = node;
            }
            if(null != node.next) {
                pq.add(node.next);    
            }
        }
        return ret;
    }
}
```
<a name="ZkJzL"></a>
### 题目分析二
这道题需要合并 k 个有序链表，并且最终合并出来的结果也必须是有序的。如果一开始没有头绪的话，可以先从简单的开始：**合并 两 个有序链表**。<br />合并两个有序链表：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br />**示例：**
```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```
这道题目按照题目描述做下去就行：新建一个链表，比较原始两个链表中的元素值，把较小的那个链到新链表中即可。需要注意的一点时由于两个输入链表的长度可能不同，所以最终会有一个链表先完成插入所有元素，则直接另一个未完成的链表直接链入新链表的末尾。<br />所以代码实现很容易写：
```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        //新建链表
        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead;
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                cur.next = l1;
                cur = cur.next;
                l1 = l1.next;
            } else {
                cur.next = l2;
                cur = cur.next;
                l2 = l2.next;
            }
        }
        // 注意点：当有链表为空时，直接连接另一条链表
        if (l1 == null) {
            cur.next = l2;
        } else {
            cur.next = l1;
        }
        return dummyHead.next;
    }
```
现在回到一开始的题目：合并 K 个排序链表。<br />**合并 K 个排序链表** 与 **合并两个有序链表** 的区别点在于操作有序链表的数量上，因此完全可以按照上面的代码思路来实现合并 K 个排序链表。<br />这里可以参考 **归并排序 **的分治思想，将这 K 个链表先划分为两个 K/2 个链表，处理它们的合并，然后不停的往下划分，直到划分成只有一个或两个链表的任务，开始合并。<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722219024-352c1d6e-870c-411b-b9a2-3edc2a0be091.gif#averageHue=%232a2a2a&clientId=u56574840-1b68-4&from=url&id=XgrkK&originHeight=507&originWidth=939&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc096483d-f079-4727-b113-cd7542ae35f&title=)
<a name="NhwNm"></a>
### 代码实现
根据上面的动画，实现代码非常简单也容易理解，先划分，直到不能划分下去，然后开始合并。
```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists){
        if(lists.length == 0)
            return null;
        if(lists.length == 1)
            return lists[0];
        if(lists.length == 2){
           return mergeTwoLists(lists[0],lists[1]);
        }

        int mid = lists.length/2;
        ListNode[] l1 = new ListNode[mid];
        for(int i = 0; i < mid; i++){
            l1[i] = lists[i];
        }

        ListNode[] l2 = new ListNode[lists.length-mid];
        for(int i = mid,j=0; i < lists.length; i++,j++){
            l2[j] = lists[i];
        }

        return mergeTwoLists(mergeKLists(l1),mergeKLists(l2));

    }
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;

        ListNode head = null;
        if (l1.val <= l2.val){
            head = l1;
            head.next = mergeTwoLists(l1.next, l2);
        } else {
            head = l2;
            head.next = mergeTwoLists(l1, l2.next);
        }
        return head;
    }
}
```
<a name="JK693"></a>
# #024 两两交换链表中的节点
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 24 号问题：两两交换链表中的节点。题目难度为 Medium，目前通过率为 45.8% 。
<a name="wAFQ9"></a>
### 题目描述
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br />**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。<br />**示例:**
```
给定 1->2->3->4, 你应该返回 2->1->4->3.
```
<a name="da9bK"></a>
### 题目解析
该题属于基本的链表操作题。

- 设置一个虚拟头结点dummyHead
- 设置需要交换的两个节点分别为node1、node2，同时设置node2的下一个节点next
<a name="cK8Vr"></a>
##### 在这一轮操作中

- 将node2节点的next设置为node1节点
- 将node1节点的next设置为next节点
- 将dummyHead节点的next设置为node2
- 结束本轮操作

接下来的每轮操作都按照上述进行。
<a name="dGGcY"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722230732-5d7fc2a6-8909-4d38-9724-6d7d3d7cfba8.gif#averageHue=%23fdfdfc&clientId=u56574840-1b68-4&from=url&id=jkpuV&originHeight=535&originWidth=956&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u09fab6ee-6975-4987-ab8d-bdce0b74df3&title=)
<a name="G6thu"></a>
### 代码实现
```
// 24. Swap Nodes in Pairs
// https://leetcode.com/problems/swap-nodes-in-pairs/description/
// 时间复杂度: O(n)
// 空间复杂度: O(1)
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {

        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;

        ListNode* p = dummyHead;
        while(p->next && p->next->next){
            ListNode* node1 = p->next;
            ListNode* node2 = node1->next;
            ListNode* next = node2->next;
            node2->next = node1;
            node1->next = next;
            p->next = node2;
            p = node1;
        }

        ListNode* retHead = dummyHead->next;
        delete dummyHead;

        return retHead;
    }
};
```

<a name="q59fb"></a>
# #025 K 个一组翻转链表
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 25 号问题：K 个一组翻转链表。题目难度为 Hard
<a name="cuRhu"></a>
### 题目描述
给你一个链表，每 _k_ 个节点一组进行翻转，请你返回翻转后的链表。<br />_k_ 是一个正整数，它的值小于或等于链表的长度。<br />如果节点总数不是 _k_ 的整数倍，那么请将最后剩余的节点保持原有顺序。<br />**示例:**<br />给你这个链表：1->2->3->4->5<br />当 _k_ = 2 时，应当返回: 2->1->4->3->5<br />当 _k_ = 3 时，应当返回: 3->2->1->4->5<br />**说明:**

- 你的算法只能使用常数的额外空间。
- **你不能只是单纯的改变节点内部的值**，而是需要实际进行节点交换。
<a name="ShrCQ"></a>
### 题目解析
这道算法题可以说是 [两两交换链表中的节点]() 的升级版, 区别就是反转的子链表节点个数变成了自定义.<br />总体思路还是一样的, 具体可以分为两个处理模块:

1. 根据 _k_ 划分若干个需要反转的子链表, 连接反转后的子链表, 最后不足 _k_ 的子链表保持不变
   - 设置哨兵 dummy 指向 head , 为了能找到反转后的链表头结点;
   - 循环 _k_ 确定需要 反转子链表 的范围:
      - 循环完成, 确定子链表可以反转假设 _A_ , _B_ 子链表邻接且都可以反转
         - 指针 start 指向 _A_ 的头结点, end 指向 _A_ 的尾结点, nxt 指向 _B_ 的头结点
         - start -> end 反转后, start 变成了 A 的尾结点, start -> next = nxt , 反转后的 _A_ 链表指向了 _B_
         - 重置 start 为 _B_ 的头节点, end 为 _B_ 的尾结点, nxt 为下一个子链表头节点, 反转 _B_ 链表
         - 重复上面动作, 知道 循环终止
      - 循环终止, 剩余节点不足 _k_ , 终止反转, 返回链表
1. 反转子链表假设子链表前三个节点为 _a_, _b_, _c_ ,设置指针 pre, cur, nxt , 初始化 pre 值为 null, cur 值为 _a_ , nxt 值为 _a_ , 这三个指针位置不变且相邻终止条件: cur 不为空将当前节点的指针指向上一个节点
   1. cur 指向 nxt ( nxt 值为 _b_ )
   2. cur 指向 pre ( cur 指向 null )
   3. cur 赋值给 pre ( pre 值为 _a_ ) , nxt 赋值给 cur ( cur 值为 _b_ )
   4. 在执行 步骤 1 ( nxt 值为 _c_ , 到此相当于 pre, cur , nxt 指向依次向后移动 1 位 )
   5. 重复上面动作
<a name="ywB3L"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=nbzNw&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="LTpiN"></a>
### 参考代码
<a name="F7YwA"></a>
#### 反转链表
```javascript
/**
 * JavaScript 描述
 * 反转区间 [start, end) 的元素, 注意不包含 end
 */
function reverse(start, end) {
    let pre = null,
        cur = start,
        nxt = start;
    while (cur != end) {
        nxt = cur.next;
        // 逐个节点反转
        cur.next = pre;
        // 更新指针位置
        pre = cur;
        cur = nxt;
    }
    // 反转后的头结点, start 移到了最后, end 没有发生改变
    return pre;
};
```
<a name="CVahC"></a>
#### 递归解法
```javascript
/**
 * JavaScript 描述
 * 递归
 */
var reverseKGroup = function(head, k) {
    if (head == null) {
        return null;
    }
    let start, end;
    start = end = head;
    for (let i = 0; i < k; i++) {
        // 不足 k 个，不需要反转
        if (end == null) {
            return head;
        }
        end = end.next;
    }
    // 反转前 k 个元素, 不包含 end
    let reverseHead = reverse(start, end);
    // 递归反转后面k个元素 , 并前后连接起来
    start.next = reverseKGroup(end, k);
    return reverseHead;
};
```
<a name="nnCMH"></a>
#### 迭代解法
```javascript
/**
 * JavaScript 描述
 * 迭代
 */
var reverseKGroup = function(head, k) {
    let dummy = new ListNode(0);
    dummy.next = head;
    let pre, start ,end, nxt;
    pre = start = end = nxt = dummy;
    while (end.next != null) {
        for (let i = 0; i < k && end != null; i++) {
            end = end.next;
        }
        if (end == null) {
            // 不足 k 个, 跳出循环
            break;
        }
        start = pre.next;
        nxt = end.next;
        // 反转前 k 个元素, 不包含 nxt
        pre.next = reverse(start, nxt);
        // 链接后面的链表
        start.next = nxt;
        // pre , end 重置到 下一个 k 子链表
        pre = start;
        end = pre;
    }
    return dummy.next;
};
```
<a name="YMynC"></a>
### 复杂度分析

- 时间复杂度: **O( nk )** , 最好情况 O( n ), 最坏情况 O( n^2 )
- 空间复杂度: **O( 1 )**
<a name="XpOhB"></a>
# #025 删除排序数组中的重复项
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 26 号问题：删除排序数组中的重复项。题目难度为 Easy，目前通过率为 48.8% 。
<a name="jqod3"></a>
### 题目描述
给定一个排序数组，你需要在**原地**删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br />不要使用额外的数组空间，你必须在**原地修改输入数组**并在使用 O(1) 额外空间的条件下完成。<br />**示例 1:**
```
给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
```
**示例 2:**
```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```
**说明:**<br />为什么返回数值是整数，但输出的答案是数组呢?<br />请注意，输入数组是以**“引用”**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br />你可以想象内部操作如下:
```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```
<a name="R6aSa"></a>
### 题目解析
使用快慢指针来记录遍历的坐标。

- 开始时这两个指针都指向第一个数字
- 如果两个指针指的数字相同，则快指针向前走一步
- 如果不同，则两个指针都向前走一步
- 当快指针走完整个数组后，慢指针当前的坐标加1就是数组中不同数字的个数
<a name="SFj8H"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722245648-cb3c9377-5298-4d80-9cf6-2903815cf244.gif#averageHue=%23fdfcfc&clientId=u56574840-1b68-4&from=url&id=I6teA&originHeight=532&originWidth=952&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7b9a9bcd-fd7e-4b4b-b515-5d5d3c061ad&title=)
<a name="B3Mp8"></a>
### 代码实现
```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) return 0;
        int pre = 0, cur = 0, n = nums.size();
        while (cur < n) {
            if (nums[pre] == nums[cur]){
              cur++;  
            } else{
                ++pre;
                nums[pre] = nums[cur];
                cur++;
            } 
        }
        return pre + 1;
    }
};
```
<a name="TRtgp"></a>
# #034 在排序数组中查找元素的第一个和最后一个位置
题目来源于 LeetCode 上第 34 号问题：find-first-and-last-position-of-element-in-sorted-array。题目难度为 中等。
<a name="ardn3"></a>
### 题目描述
给定一个按照升序排列的整数数组 **nums**，和一个目标值 **target**。找出给定目标值在数组中的开始位置和结束位置。<br />你的算法时间复杂度必须是 **O(log n)** 级别。<br />如果数组中不存在目标值，返回 [-1, -1]。<br />**示例:**
```
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```
```
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```
<a name="inkDe"></a>
### 题目解析
题目中要求了时间复杂度为O(log n),这就很清楚要使用二分查找法了。<br />首先定义两个指针变量，分别存储左右两个位置的索引。首先去找目标值的最左面的索引,通过循环为了防止元素丢失,每次保留最右面的元素,左侧的指针移动时+1。在循环结束的时候判断一下数组中是否包括目标值,不包括的话直接退出。<br />右面的跟左侧相同，只不过正好相反。
<a name="EW5fL"></a>
### 动画描述
![](..%5CAnimation%5C%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.gif#from=url&id=EoeGh&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="CEpWi"></a>
### 代码实现
```java
// 34. 下一个排列
// https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/
// 时间复杂度：O(n)
// 空间复杂度：O(1)
class Solution {
    public int[] searchRange(int[] nums, int target) {
		int[] res = new int[] { -1, -1 };
		int left = 0;
		int right = nums.length - 1;
		int l = left;
		int r = right;
		while (left < right) {
			int mid = (left + right) / 2;
			if (nums[mid] < target) {
				left = mid + 1;
			} else {
				right = mid;
			}
		}
		if (left>right||nums[left]!=target) {
			return new int[]{-1,-1};
		}
		while (l < r) {
			int mid = (l + r) / 2 + 1;
			if (nums[mid] > target) {
				r = mid - 1;
			} else {
				l = mid;
			}
		}
		if (left > right || left > r) {
			return new int[] { -1, -1 };
		} else {
			return new int[] { left, r };
		}
	}
}
```
<a name="v43aL"></a>
# #035 搜索插入位置
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 第 35 号问题：搜索插入位置.
<a name="WKVO0"></a>
## 题目
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br />你可以假设数组中无重复元素。<br />示例 1:
```
输入: [1,3,5,6], 5
输出: 2
```
示例 2:
```
输入: [1,3,5,6], 2
输出: 1
```
示例 3:
```
输入: [1,3,5,6], 7
输出: 4
```
示例 4:
```
输入: [1,3,5,6], 0
输出: 0
```
<a name="sZrHw"></a>
## 思路解析
<a name="juatf"></a>
### 暴力循环法
这个题看起来就是很简单的，就是一道考验查找算法的题目。最简单的就是暴力查找了。
<a name="uYHll"></a>
#### 思路
遍历这个数组，然后如果当前值和目标值target一致或小于目标值target，那么就return 当前下标。这种解法的时间复杂度是O(N)
<a name="Zb1i1"></a>
### 动画理解
![](../Animation/%E6%9A%B4%E5%8A%9B%E6%9F%A5%E6%89%BE.gif#from=url&id=qcjc1&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="HPISW"></a>
#### 代码实现
```java
//时间复杂度：O(n)
//空间复杂度：O(1)
class Solution {
    public int searchInsert(int[] nums, int target) {
        int i=0;
        for(;i<nums.length;i++){
            if (nums[i]>=target){
                break;
            }
        }
        return i;
    }
}
```
<a name="zcQCk"></a>
### 二分法
<a name="MzExa"></a>
#### 思路
除了暴力法，我们在排序数组中查找值还可以用的一种方法是二分法，思路还是和改良的暴力循环法一样，先找到左右边界，然后计算，每次可以省出一半的时间。时间复杂度为O(logn)
<a name="Kqufe"></a>
#### 代码实现
```java
//时间复杂度：O(lon(n))
//空间复杂度：O(1)
class Solution {
    public int searchInsert(int[] nums, int target) {
        if (target>nums[nums.length-1]) {
            return nums.length;
        }
        int left=0;
        int right=nums.length-1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;

    }
}
```
<a name="UWZOx"></a>
# #036 有效的数独
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 第 36 号问题：有效的数独.
<a name="IOujx"></a>
## 题目
判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
```
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
```
示例 1:
```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```
示例 2:
```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```
示例 3:
```
输入: [1,3,5,6], 7
输出: 4
```
示例 4:
```
输入: [1,3,5,6], 0
输出: 0
```
<a name="IfjPE"></a>
## 思路解析
<a name="X92Ta"></a>
### 一次遍历法
<a name="yWflO"></a>
#### 思路
这道题因为需要判断数值是否存在，所以用Hash Map是一个很好的选择。<br />因为每一行、每一列、每一格都是需要单独进行判断的，所以需要建立三个长度为9的HashMap数组，分别存放行、列、格的数值。<br />通过一个二层循环遍历这个9*9的数组,把当前格的数值存放到对应的HashMap中，判断之前是否已经存放过了，如果已经存放过那就退出，返回false，如果是.的话那就跳过，这样只需要遍历一边就可以了。
<a name="NNHdZ"></a>
### 动画理解
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391594743-612ed9eb-42ea-4f83-9fc7-508a8f1edb6f.gif#averageHue=%23f6f5f5&from=url&id=gulUX&originHeight=480&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="ZGRcc"></a>
#### 代码实现
```java
//时间复杂度：O(n)
//空间复杂度：O(1)
class Solution {
    public boolean isValidSudoku(char[][] board) {
        HashMap[] row = new HashMap[9];
        HashMap[] column = new HashMap[9];
        HashMap[] box = new HashMap[9];
        for (int i = 0; i < 9; i++) {
            row[i] = new HashMap(9);
            column[i] = new HashMap(9);
            box[i] = new HashMap(9);
        }
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.') {
                    continue;
                }
                int boxIndex=i / 3 * 3 + j / 3;
                if ((boolean) row[i].getOrDefault(board[i][j], true)) {
                    return false;
                }
                if ((boolean) column[j].getOrDefault(board[i][j], true)) {
                    return false;
                }
                if ((boolean) box[boxIndex].getOrDefault(board[i][j], true)) {
                    return false;
                }
                row[i].put(board[i][j], false);
                column[j].put(board[i][j], false);
                box[boxIndex].put(board[i][j], false);
            }
        }

        return true;
    }
}
```
<a name="dQKLZ"></a>
## LeetCode第42号问题：接雨水
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />个人博客：www.zhangxiaoshuai.fun<br />**本题选择leetcode中第42题，hard级别，目前通过率50.8%#**
<a name="PqvFy"></a>
### 题目描述：
```
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
示例:
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```
![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693391596223-3470cbe6-639c-4e31-9610-bf7f68564ca8.png#averageHue=%23bfbfbf&from=url&id=yRJ5p&originHeight=161&originWidth=412&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="ULO5l"></a>
### 题目分析：
通过题意，一个“凹槽”可以存储的雨水的容量取决于它前后的柱子。
<a name="Priwv"></a>
### 解法一：
仔细想想，其实这跟木桶原理是有相似的地方的，针对每一个柱子，我们需要往前看和往后看，分别找出当前柱子前面最高的柱子和后面最高的柱子。<br />这里有**三种情况**我们需要了解：

- **当前柱子小于前后两个柱子中最矮的那个**<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693391596344-de62e67a-fd08-4df2-ba80-bc1e95520e4b.png#averageHue=%23cfcecc&from=url&id=xaiTw&originHeight=314&originWidth=618&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)**当前位置可以存储的雨水容量 = leftMax - curr = 1**
- **当前柱子等于前后两个柱子中最矮的那个**<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693391596458-7f7ff558-ac9c-4bfa-9efe-72c35e453a9f.png#averageHue=%23cccbca&from=url&id=KeNJl&originHeight=314&originWidth=618&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)**当前位置可以存储的雨水容量为0**
- **当前柱子大于前后两个柱子中最矮的那个**![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693391596554-a160e733-9a04-4344-95c5-193ef39c6c3b.png#averageHue=%23d0cfcd&from=url&id=XLp3Z&originHeight=314&originWidth=618&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)**因为curr < leftMax，所以当前位置无法存储雨水**

**GIF动画演示：**<br />![](../Animation/0042-trap.gif#from=url&id=WIQVi&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="LHAiO"></a>
### 代码：
```java
public int trap02(int[] height) { 
    int sum = 0;   
    //最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2    
    for (int i = 1; i < height.length - 1; i++) { 
        int max_left = 0;       
        //找出左边最高        
        for (int j = i - 1; j >= 0; j--) {  
            if (height[j] > max_left) {  
                max_left = height[j];  
            }       
        }        
        int max_right = 0;       
        //找出右边最高       
        for (int j = i + 1; j < height.length; j++) { 
            if (height[j] > max_right) {  
                max_right = height[j];   
            }       
        }       
        //找出两端较小的       
        int min = Math.min(max_left, max_right); 
        //只有较小的一段大于当前列的高度才会有水，其他情况不会有水  
        if (min > height[i]) { 
            sum = sum + (min - height[i]);       
        }   
    }   
    return sum;
}
```
可以看到，上面方法的时间复杂度达到了**O(n^2)**<br />**那么有没有更好的办法来解决这个问题？**<br />下面的方法巧妙的使用了**双指针**来解决问题：<br />与上述解法的思路大致是相同的，都是单个地求出当前墙可以存储雨水的容量；这种解法也是非常的巧妙，是在浏览解题区的时候碰见的，大佬还做了视频（链接放在文末），讲解的非常清楚，我大概用自己的思路来作一文字叙述：<br />既然使用的是**twoPointers**的思路，那么我们需要分别从数组的最前面和最后面开始，这两个指针是互不影响，都是各走各的，但是如何确定当前指针走过的地方能存放多少雨水量呢？<br />这个时候，我们就需要两块挡板**leftMax**和**rightMax**，这两块挡板最开始都是挡在最外面的墙边，随着两个指针前进，**leftMax**代表的是**left**走过的路中最高的墙，**rightMax**同理。<br />**那么如何计算雨水量呢？**<br />比较左右两个挡板的高度，然后根据两个挡板各自的指针配合计算。

- 如果左边挡板的高度小于右边的挡板高度，那么左边指针之前的雨水量取决于**leftMax**和height[left]的大小关系，如果前者大于后者，那么容量等与前者减去后者；反之，容量为0（可以参考解法一中的图来理解）
- 如果左边挡板的高度大于等于右边挡板的高度，与上一种情况基本相同，只不过是求的右边的雨水量。
- 在每次移动指针之后，我们要将挡板更新到最大值。

**其实道理也是比较简单，用宏观的思维去看待整个问题，最起码先保证两边的墙的高度（两块挡板），然后依次去到其中各个墙之间能装多少雨水的问题上。（求每次更新最高的挡板和指针指向的墙之间可以存储的雨水量）**
<a name="vX8eU"></a>
### 代码：
```java
public int trap(int[] height) {
    if (height.length == 0) return 0;
    int left = 0;
    int right = height.length-1;
    int leftMax = 0;
    int rightMax = 0;
    int result = 0;
    while (left <= right) {
      if (leftMax < rightMax) {
        result += leftMax - height[left] > 0 ?
            leftMax - height[left] : 0;
        leftMax = Math.max(leftMax, height[left]);
        left++;
      } else {
        result += rightMax - height[right] > 0 ?
            rightMax - height[right] : 0;
        rightMax = Math.max(rightMax, height[right]);
        right--;
      }
    }
    return result;
  }
```
**时间复杂度：O(n) 空间复杂度：O(1)**<br />[leetcode配套视频入口](https://leetcode-cn.com/problems/trapping-rain-water/solution/javashi-pin-jiang-jie-xi-lie-trapping-rain-water-b/)
<a name="P5gGY"></a>
# #048 旋转图像
<a name="Kfq4B"></a>
## 题目描述
给定一个 n × n 的二维矩阵表示一个图像。<br />将图像顺时针旋转 90 度。<br />**说明：**<br />你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。<br />**示例 1:**
```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```
**示例 2:**
```
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```
<a name="SWOIB"></a>
## 题目解析
这道题的主要难点在于如何**原地**旋转矩阵。<br />我们发现，矩阵中的一个元素旋转四次之后会回到原先的位置。也就是说，这四个元素在旋转时位置互相交换了。例如元素 (i, j) 对应的四个位置分别是：

- (i, j)
- (N-1-j, i)
- (N-1-i, N-1-j)
- (j, N-1-i)

为了旋转这四个元素，我们可以用一个临时变量保存其中一个元素，然后让几个元素依次赋值。<br />那么，一共有多少个这样的四元素组呢？这要分情况来看。如果 <br />$n$ 是偶数的话，这相当于把矩阵均分成四块，每块的元素个数是 $ (n/2) \times (n/2)$。如果 $n$ 是奇数，矩阵的中心元素是不随旋转移动的，而剩下的元素均分成四块，每块的元素个数是 $%5Clfloor%20n%2F2%20%5Crfloor%20%5Ctimes%20%5Clceil%20n%2F2%20%5Crceil$。我们对一块中的所有元素做一次四元素旋转即可。
<a name="BuUFl"></a>
## 动画理解
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=D5hLx&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="gVCWX"></a>
## 参考代码
```
class Solution {
    public void rotate(int[][] matrix) {
        int N = matrix.length;
        for (int i = 0; i < N/2; i++) {
            for (int j = 0; j < (N+1)/2; j++) {
                int t = matrix[i][j];
                matrix[i][j] = matrix[N-1-j][i];
                matrix[N-1-j][i] = matrix[N-1-i][N-1-j];
                matrix[N-1-i][N-1-j] = matrix[j][N-1-i];
                matrix[j][N-1-i] = t;
            }
        }
    }
}
```
<a name="LpgMg"></a>
## 复杂度分析

- 时间复杂度：$O(n%5E2)$。
- 空间复杂度：$O(1)$。
<a name="cXD1V"></a>
# #053 在排序数组中查找数字 I
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上 面试题53 - I. 在排序数组中查找数字 I. 是算法入门的一道题。
<a name="cW0eI"></a>
## 题目
统计一个数字在排序数组中出现的次数。<br />示例 1:
```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```
示例 2:
```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```
限制：
```
0 <= 数组长度 <= 50000
```
<a name="Qles5"></a>
## 思路解析
<a name="vG39A"></a>
### 暴力循环法
题目看上去是很简单，就是找到一个目标数字在数组中出现的次数，不管数组是有序还是无序的，我们都可以用的一种方法就是暴力循环法
<a name="S0F05"></a>
#### 思路
定义一个count来记录目标值出现的次数，初始值为0，然后遍历这个数组，然后如果当前值和目标值target一致，那么count就加一，最后return count。这种解法的时间复杂度是O(N)
<a name="tFgoN"></a>
#### 代码实现
```
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let count = 0;
    for(let i of nums) {
    	if (i === target) {
    		count++
    	}
    }
    return count
};
```
<a name="tEafa"></a>
### 改良的暴力循环
<a name="vffDP"></a>
#### 思路
因为数组已排序了，所以我们其实可以不用遍历全部，用双指针分别从头部和尾部开始同时遍历，然后找到目标值的左右边界的位置，然后通过计算得到count。其实就是比全部遍历少了目标值出现的次数，它的算法复杂度还是O(n)
```
count = 右边界的index - 左边界的index + 1
```
<a name="ENVEY"></a>
#### 代码实现
```
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let [left,  right] = [0, nums.length - 1]
    while(left <= right && (nums[left] !== target || nums[right] !== target)) {
    	if (left === right && nums[left] !== target) {
    		return 0;
    	}else if (nums[left] !== target) {
    		left++;
    	}else if (nums[right] !== target){
    		right--;
    	}
    }
    return right - left + 1;
};
```
<a name="iRqK9"></a>
### 二分法
<a name="mTuVy"></a>
#### 思路
除了遍历，我们在排序数组中查找值还可以用的一种方法是二分法，思路还是和改良的暴力循环法一样，先找到左右边界，然后做计算。时间复杂度为O(logn)
<a name="ng0vx"></a>
#### 代码实现
```
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let start = 0;
    let mid = 0;
    let end =  nums.length - 1;
    let left = 0;
    let right = 0;
  	// 查找右边界
    while(start <= end) {
        mid = Math.ceil((start + end) / 2)
        if (nums[mid] <= target) {
            start = mid + 1
        } else {
            end = mid -1
        }
    }
    right = start - 1; // 右边界
  	// 查找左边界
    start = 0;
    mid = 0; 
    end =  nums.length - 1;
    while(start <= end) {
        mid = Math.ceil((start + end) / 2)
        if (nums[mid] < target) {
            start = mid + 1
        } else {
            end = mid -1
        }
    }
    left = end + 1
    return right - left + 1
};
```
<a name="Gxge6"></a>
## 动画理解
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=RKz9P&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="ZMcdb"></a>
## LeetCode第58号问题：最后一个单词的长度
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />个人博客：www.zhangxiaoshuai.fun<br />**本题选自leetcode第58题，easy难度，目前通过率33.0%**
<a name="FRJoU"></a>
### 题目描述：
```
给定一个仅包含大小写字母和空格' '的字符串s，返回其最后一个单词的长度。
如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。
如果不存在最后一个单词，请返回0。
说明：一个单词是指仅由字母组成、不包含任何空格字符的最大子字符串。

示例:
输入:"Hello World"
输出:5
```
<a name="tjkSW"></a>
### 题目分析：
既然需要求出最后一个单词的长度，那我们直接从**字符串的末尾**开始好了；<br />这里末尾有两种情况：有空格和没有空格
```
（1）有空格：我们从末尾忽略掉空格，然后找到第一个遇见的字符（遇到第一个空格或者遍历完整个字符串为止）
（2）无空格：直接从末尾往前寻找即可（遇到第一个空格或者遍历完整个字符串为止）
```
<a name="N6cI2"></a>
### 动画gif演示：
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391600766-d548d55e-7b3a-49c6-aabe-863d2fb9b7cf.gif#averageHue=%23fefefe&from=url&id=j3xsc&originHeight=480&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="moqjh"></a>
### 代码：
**The first version**
```java
public int lengthOfLastWord(String s) {
    if (s.length()==0) {
        return 0;
    }
    int index = 0;
    int temp = 0;
    int p = s.length()-1;
    while ((p-index >=0) && s.charAt(p-index) == 32) index++;
    for (int i = p-index;i >= 0;i--) {
        if (s.charAt(i) != 32){
            temp++;
            continue;
        }
        break;   
    }
    return temp;
}
```
**2.代码：**<br />**The second version**
```java
public int lengthOfLastWord(String s) {
    int len = 0;
    for (int i = s.length() - 1; i >= 0; i--) {
        if (s.charAt(i) != ' ') {
            len++;
        } else if (len != 0) {
            return len;
        }
    }
    return len;
}
```
<a name="pkc0I"></a>
# #066 加一
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />今天分享的题目来源于 LeetCode 上第 66 号问题：加一。题目难度为 Easy，目前通过率为 39.0% 。
<a name="umi4j"></a>
### 题目描述
给定一个由**整数**组成的**非空**数组所表示的非负整数，在该数的基础上加一。<br />最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。<br />你可以假设除了整数 0 之外，这个整数不会以零开头。<br />**示例 1:**
```
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
```
**示例 2:**
```
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```
**示例 3:**
```
//为了更好理解题意，根据 LeetCode 评论区评论新增一个示例
输入: [9,9]
输出: [1，0，0]
解释: 输入数组表示数字 100。
```
<a name="alMH9"></a>
### 题目解析
本题很简单，题目意思也很好理解，注意的点就是 **进位问题**。

- 如果数组末位（个位）小于 9 ，直接个位加 1 返回即可
- 如果数组末位（个位）等于 9，将该位（个位）设置为 0 ，并且产生了进位，接下来观察前一位（十位）
   - 如果前一位（十位）小于 9 ，直接十位加 1 返回即可
   - 如果前一位（十位）等于 9，将该位（十位）设置为 0 ，并且产生了进位，接下来观察前一位（百位）
- 以此类推，最后观察运算完的第一位是否为 0 ，如果为 0 ，则在最前面加 1 （**示例 3**）
<a name="FaKVF"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722290299-b1699b7e-3902-4ea3-acfb-8be3ded198c5.gif#averageHue=%23fdfdfd&clientId=u56574840-1b68-4&from=url&id=HlrSF&originHeight=327&originWidth=769&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u04a28bb0-ffa2-43c9-894e-12ff53aa1b7&title=)<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722290286-da170b08-27ee-4286-8f10-7305112a94b3.gif#averageHue=%23fdfdfd&clientId=u56574840-1b68-4&from=url&id=GZxEo&originHeight=327&originWidth=769&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub85db342-dcf1-422b-8d27-40a5320c9ed&title=)
<a name="jg66v"></a>
### 代码实现
```java
public class Solution {
    public int[] plusOne(int[] digits) {
        int n = digits.length;
        //从数组末尾开始向前遍历
        for (int i = digits.length - 1; i >= 0; --i) {
            if (digits[i] < 9) {
                digits[i]++;
                //没有进位，直接返回
                return digits;
            }
            //产生进位，需要将该位赋值为 0 
            digits[i] = 0;
        }
        //整体产生了进位，数组长度需要变化加 1
        int[] res = new int[n + 1];
        res[0] = 1;
        return res;
    }
}
```
<a name="Jsifh"></a>
## **LeetCode 第 70 号问题：爬楼梯**
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一.<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 70 号问题：爬楼梯。题目难度为 Easy。
<a name="EbsHi"></a>
### 题目描述
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br />每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br />**注意：给定 n 是一个正整数。**
<a name="wOrCR"></a>
### 示例1
输入： 2<br />解释： 有两种方法可以爬到楼顶。

1. 1 阶 + 1 阶
2. 2 阶
<a name="JI3st"></a>
### 题目解析
试着倒推想一下,就能发现这个问题可以被分解为一些包含最优子结构的子问题,它的最优解可以从其子问题<br />的最优解来有效地构建,因此我们可以使用动态规划解决这个问题.<br />第 i 阶可以由以下两种方法得到：<br />在第 (i - 1) 阶后向上爬 1 阶。<br />在第 (i - 2) 阶后向上爬 2 阶<br />所以到达第 i 阶的方法总数就是到第 (i - 1) 阶和第 (i - 2) 阶的方法数之和。<br />dp[i]dp[i] 表示能到达第 i 阶的方法总数,那么DP推导公式就是:<br />$dp%5Bi%5D%20%3D%20dp%5Bi%20%E2%88%92%201%5D%20%2B%20dp%5Bi%20%E2%88%92%202%5D%0A$
<a name="YALhD"></a>
### 动画理解
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=WXPSM&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="wJgLU"></a>
### 参考代码
```javascript
/**
 * JavaScript 描述
 */
var climbStairs = function(n) {
    let temp = new Array(n+1);
    temp[1] = 1;
    temp[2] = 2;
    for (let i = 3; i < temp.length; i++) {
        temp[i] = temp[i-1] + temp[i-2];
    }
    return temp[n];
}
```
<a name="DBHif"></a>
#### 复杂度分析

- 时间复杂度：O(n)，单循环到 n。
- 空间复杂度：O(n)，dpdp 数组用了 n 的空间。
<a name="pxWVH"></a>
### 进一步优化
根据推导公式不难发现,我们要求的结果就是数组的最后一项,而最后一项又是前面数值叠加起来的,那么我们只需要两个变量保存 i - 1 和 i - 2 的值就可以了.
```javascript
/**
 * JavaScript 描述
 */
var climbStairs = function(n) {
    if (n == 1) {
        return 1;
    }
    let first = 1,
        second = 2;
    for (let i = 3; i <= n; i++) {
       let third = first + second;
       first = second;
       second = third;
    }
    return second;
}
```
<a name="PpTS3"></a>
#### 复杂度分析

- 时间复杂度：O(n)，单循环到 n。
- 空间复杂度：O(1)，用到了常量的空间。
<a name="rGgI9"></a>
# #075 颜色分类
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 75 号问题：颜色分类。题目难度为 Medium，目前通过率为 51.8% 。
<a name="ZiDy7"></a>
### 题目描述
给定一个包含红色、白色和蓝色，一共 _n_ 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br />此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br />**注意:**<br />不能使用代码库中的排序函数来解决这道题。<br />**示例:**
```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```
**进阶：**

- 一个直观的解决方案是使用计数排序的两趟扫描算法。<br />首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
- 你能想出一个仅使用常数空间的一趟扫描算法吗？
<a name="MFTjq"></a>
### 题目解析
结合三路快排 partition 思路的应用。<br />设定两个索引，一个从左往右滑动zero，一个从右往左滑动two。

- 遍历nums，当nums[i]的值为1时，i++；
- 当nums[i]的值为2时，two的值先减1，而后交换nums[i]与nums[two]，此时在观察nums[i]的值；
- 当nums[i]的值为0时，zero++，而后交换nums[i]与nums[zero]，i++;当 i = two时，结束循环。
<a name="eFjNk"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722309851-3519d7db-56fc-456d-8a84-b50b2a648bb1.gif#averageHue=%23fdfdfd&clientId=u56574840-1b68-4&from=url&id=SxWMW&originHeight=457&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u01da0d8b-eaed-48de-a49b-b5e0f94b495&title=)
<a name="IB4MZ"></a>
### 代码实现
```
// 三路快速排序的思想
// 对整个数组只遍历了一遍
// 时间复杂度: O(n)
// 空间复杂度: O(1)
class Solution {
public:
    void sortColors(vector<int> &nums) {

        int zero = -1;          // [0...zero] == 0
        int two = nums.size();  // [two...n-1] == 2
        for(int i = 0 ; i < two ; ){
            if(nums[i] == 1){
                 i ++;
            }else if (nums[i] == 2){
                 two--;
                 swap( nums[i] , nums[two]);
            }else{ // nums[i] == 0
                 zero++;
                 swap(nums[zero] , nums[i]);
                 i++;
            }
        }
    }
};
```
<a name="dhwZ4"></a>
# #084 柱状图中的最大矩形
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 84 号问题：柱状图中的最大矩形。题目难度为 Hard，目前通过率为 39.2% 。<br /> 

<a name="PF86a"></a>
### 题目描述
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br />求在该柱状图中，能够勾勒出来的矩形的最大面积。<br />**示例 1:**<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693391605747-127a4e26-b4b3-4506-990b-6c6df45cac74.png#averageHue=%23fbfafa&from=url&id=hyTNU&originHeight=1084&originWidth=864&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br /> 

<a name="ey7K6"></a>
### 题目解析
给一个条形图，让你找出这里面面积最大的矩形，条形图中每一个位置的高度不固定，但是宽度都是 1。因为矩形的方向，大小都不确定，直观去看的话思路并不明显，但是有一点很明确，一段区间形成的矩形总是和最短的高度有关，我们还是来看看题目给的例子:
```
[2,1,5,6,2,3]

我们假定矩形可以由一个区间 [start, end] 确定，
那么这个区间的矩形的高度其实是由这个区间的最小值决定

[0,1] 区间内的矩形的高度是 1，面积 1 * 2 = 2
[2,3] 区间内的矩形的高度是 5，面积 5 * 2 = 10
[0,5] 区间内的矩形的高度是 1，面积 1 * 6 = 6
[2,5] 区间内的矩形的高度是 2，面积 2 * 4 = 8
...
```
如果你明白了上面的例子，这道题目思路就有了，也就是 “**找出数组的所有区间(子数组)，区间中 最小元素的值 _ 区间的长度 就是当前区间表示的矩形的面积，在所有区间中找最大面积的矩形即可_”。这个思路非常的直接，这么样下来，找出数组的所有子数组，这个时间复杂度是 O(n^2)，有没有办法优化呢？<br />上面的解法，你直观上看就是一个暴力的解法，因为我们不断地去找子数组，这里面其实有很多的重复计算，比如，还是刚刚那个例子：
```
[2,1,5,6,2,3]

[2,1,5,6,2] 我们遍历了一遍，得到矩阵的高度的最小值，然后求出面积
[1,2,6,2] 我们又接着重新遍历一遍，得到矩阵的高度的最小值，然后求出面积

求第二个区间的时候，我们完全没有借鉴第一个区间的答案，存在着重复计算
```
这个时候，我们可能需要换一个思路来看待这个问题，从上面的分析，我们已经得知，矩阵的高都来自于数组中元素的值，可以思考 “**如果以当前位置的元素作为矩形的高，最多向左向右分别延伸多少个位置**”，比如：
```
[2,1,5,6,2,3]

如果我们取数组中第 2 个元素，也就是 1，作为矩阵的高
它向左可以延伸到 2，向右可以延伸到 3，于是面积就是 1 * 6 = 6

如果我们取数组中第 5 个元素，也就是 2，作为矩阵的高
它向左可以延伸到 5，向右可以延伸到 3，于是面积就是 2 * 4 = 8

如果我们取数组中第 3 个元素，也就是 5，作为矩阵的高
它向左可以延伸到 5（它自己），向右可以延伸到 6，于是面积就是 5 * 2 = 10

...
```
好了，思路分析完了，现在如何实现这么一个思想呢？我们需要确定一个元素可以延伸到的左边界和右边界，这么说你可能不太好理解，换种说法，其实我们需要找 “**左边第一个比当前元素小的元素所在的位置，右边第一个比当前元素小的元素所在位置**”，还是来看看例子：
```
[2,1,5,6,2,3]

数组第 2 个元素 1，左右均没有比它小的元素，因此它所确定的区间就是整个数组

数组第 5 个元素 2，左边第一个比它小的元素是 1，右边第一个比它小的元素是 -1（表示没有）
因此它所确定的区间就是 [2, 5]

数组第 3 个元素 5，左边第一个比它小的元素是 1，右边第一个比它小的元素是 6
因此它所确定的区间就是 [2, 3]

...
```
在实现上面我们需要利用栈这个数据结构，栈里面存放的元素对应的值都是**单调递增**的，这样可以保证从左向右遍历数组，前一个入栈的元素是后一个入栈的元素的左边界，另外，如果下一个准备入栈的元素比栈顶元素的值小，说明栈顶元素的右边界也找到了，左右边界都找到了，栈顶元素出栈进行计算。这样下来，一个元素只会进栈一次，出栈一次，因此时间复杂度是 O(2 * n) 也就是 O(n)<br />**单调栈**这个数据结构应用还是比较广泛的，如果发现题目中需要针对数组中一个元素向左右两边延伸去确定区间，而且延伸的条件跟元素的值有关，那么就可以考虑使用单调栈。<br /> 

<a name="XM5ju"></a>
### 代码实现（暴力解法）
```java
public int largestRectangleArea(int[] heights) {
    if (heights == null || heights.length == 0) {
        return 0;
    }
    
    int n = heights.length;
    int result = 0;
    
    for (int i = 0; i < n; ++i) {
        int curMin = heights[i];
        
        for (int j = i; j < n; ++j) {
            curMin = Math.min(curMin, heights[j]);
            result = Math.max(result, (j - i + 1) * curMin);
        }
    }
    
    return result;
}
```
 

<a name="rsnVJ"></a>
### 代码实现（单调栈）
```java
public int largestRectangleArea(int[] heights) {
    if (heights == null || heights.length == 0) {
        return 0;
    }

    int n = heights.length;
    
    Stack<Integer> stack = new Stack<>();
    
    int result = 0;
    
    for (int i = 0; i <= n; ++i) {
        // curElement 表示当前元素的值，用 -1 表示数组的结束
        int curElement = (i == n) ? -1 : heights[i];
        
        // 元素的出栈操作，表明当前栈顶元素找到了右边界
        // 加上栈内存放的元素是单调递增的，因此左边界也找到了
        // while 里面针对栈顶元素这个高度的矩形计算面积即可
        while (!stack.isEmpty() && heights[stack.peek()] >= curElement) {
            int high = heights[stack.pop()];
            int width = stack.isEmpty() ? i : i - stack.peek() - 1;
            
            result = Math.max(result, high * width);
        }
        
        stack.push(i);
    }
    
    return result;
}
```
 

<a name="dIJ0v"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391605852-d54afa8a-2211-4aca-aba1-16469a34aa9e.gif#from=url&id=u8HRo&originHeight=608&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br /> 

<a name="uGrvj"></a>
### 复杂度分析
暴力解法的时间复杂度是 O(n^2)，这个从上面的描述中不难看出。在单调栈的代码实现中，你可能会觉得这里有两个嵌套循环，因此时间复杂度是 O(n^2)，但其实不是这样，考虑时间复杂度仅仅看代码的形式是不够的，你可以这样考虑，因为数组中的每个元素仅入栈一次，出栈一次，因此正确的时间复杂度是 O(2n)，忽略常数项，也就是 O(n)，单调栈的解法中用到了栈，因此空间复杂度是 O(n)。<br /> 

<a name="NLUoN"></a>
# #086 分割链表
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 86 号问题：分割链表。题目难度为 Easy，目前通过率为 47.8% 。
<a name="i1KGk"></a>
### 题目描述
给定一个链表和一个特定值 _x_，对链表进行分隔，使得所有小于 _x_ 的节点都在大于或等于 _x_ 的节点之前。<br />你应当保留两个分区中每个节点的初始相对位置。<br />**示例:**
```
输入: head = 1->4->3->2->5->2, x = 3
输出: 1->2->2->4->3->5
```
<a name="B1Hoj"></a>
### 题目解析
这道题要求我们划分链表，把所有小于给定值的节点都移到前面，大于该值的节点顺序不变，相当于一个局部排序的问题。

- 设定两个虚拟节点，dummyHead1用来保存小于于该值的链表，dummyHead2来保存大于等于该值的链表
- 遍历整个原始链表，将小于该值的放于dummyHead1中，其余的放置在dummyHead2中
- 遍历结束后，将dummyHead2插入到dummyHead1后面
<a name="E6rwF"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722333324-900919f5-6d78-43e6-9c04-009b5624d210.gif#averageHue=%23fdfdfd&clientId=u56574840-1b68-4&from=url&id=jX9vc&originHeight=541&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2e33311a-97d4-4dcf-817e-1f72188005e&title=)
<a name="M9Kvg"></a>
### 代码实现
```
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {

        ListNode* dummyHead1 = new ListNode(-1);
        ListNode* dummyHead2 = new ListNode(-1);
        ListNode* prev1 = dummyHead1;
        ListNode* prev2 = dummyHead2;

        for(ListNode* cur = head ; cur != NULL ;){
            if(cur->val < x){
                prev1->next = cur;
                cur = cur->next;
                prev1 = prev1->next;
                prev1->next = NULL;
            }
            else{
                prev2->next = cur;
                cur = cur->next;
                prev2 = prev2->next;
                prev2->next = NULL;
            }
        }

        prev1->next = dummyHead2->next;
        ListNode* ret = dummyHead1->next;

        delete dummyHead1;
        delete dummyHead2;
        return ret;
    }
};
```
<a name="To9zC"></a>
# #088 合并两个有序数组
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 88 号问题：合并两个有序数组。题目难度为 Easy
<a name="p1gCr"></a>
### 题目描述
给你两个有序整数数组 _nums1_ 和 _nums2_，请你将 _nums2_ 合并到 _nums1_ 中_，_使 _nums1_ 成为一个有序数组。<br />**说明:**

- 初始化 _nums1_ 和 _nums2_ 的元素数量分别为 _m_ 和 _n_ 。
- 你可以假设 _nums1_ 有足够的空间（空间大小大于或等于 _m_ + _n_）来保存 _nums2_ 中的元素。

**示例:**
```
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```
<a name="WXtQ0"></a>
### 题目解析
将这个题目放到现实中就容易多了, 不信你看看.<br />假如你是玩具店的老板, 其中两个货架依次摆放了形状相同大小不同的小汽车, 这些小汽车都按照从小到大摆放着, 现在你想把第二个货架的小汽车移到第一个货架上, 为了顾客看起来直观, 这些小汽车要摆放的有序, 你会怎么做呢?<br />**很显现, 你不会把所有小汽车放到一起, 然后在一个个排序好放到第一个货架上.**<br />你肯定会比较两个货架小汽车的大小, 把第二个货架小汽车移到第一个货架的相应位置上.<br />那么问题来了, 是从小的比较呢还是从大的比较呢?<br />**先从小的比较来看**, 现在第二个货架第一个汽车是最小的, 那么你得把第一个货架所有玩具往后挪一位, 然后才能放下这个汽车, **好像有点费力了**.<br />不想费力, 我们可以先把第一个货架的玩具移到第三个货架, 比较第二个货架和第三个货架, 把比较小的汽车放到第一个货架上. 看来还得先搬移第一个货架, **需要占用其他空间了**.<br />**如果从后面比较呢**, **也就是先比较大的汽车**, 现在第二个货架最后一个是最大的汽车, 我只需要把最大的汽车拿到第一货架的最后面就可以了, 是不是很轻松, 这样依次比较, **不费力也不用费空间**就挪到了第一个货架后面了. 和第一个货架都比较完了, 发现第二个货架还剩一个最小的汽车, 这个时候你会发现第一个货架的第一个位置是空的, 我们直接拿过去就可以啦.<br />故事讲完啦, 通过这几种方法的尝试, 你也许已经发现了:<br />第一种方法 对应的算法是 **' 合并后排序 '**, 时间复杂度比较大;<br />第二种方法 对应的算法是 **' 双指针 + 从前向后比较 '**

- 往后挪动汽车时间复杂度高
- 移到第三个货架空间复杂度高

第三种方法 对应的算法是 **' 双指针 + 从后向前比较 '** , 省时又不占空间, 完美!<br />下面说下 **' 双指针 + 从后向前比较 '** 的具体思路:

1. 设置双指针, 分别指向有序数组的最后一位;
2. 从后向前
   - 终止条件: 其中一个指针不在指向数组
   - 比较双指针指向的值
   - 大的或相同的值放到 _num1_ 空间的尾部( 尾部从后向前依次填充 ), 对应的指针向前挪一位
   - 循环上面步骤
3. 遍历完成后检查
   - 若指向 _num2_ 的指针还有效, 说明 _num2_ 中还有小于 _num1_ 最小值的存在
   - 将这些值搬移到 _num1_ 最前面
<a name="fivQK"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=ES5fz&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="vs8td"></a>
### 参考代码
C++ Code:
```
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i=m-1, j=n-1, k=m+n-1;
        // 合并
        while(i>=0 && j>=0)
        {
            if(nums1[i] > nums2[j])
            {
                nums1[k--] = nums1[i--];
            }
            else
            {
                nums1[k--] = nums2[j--];
            }
        }
        // 合并剩余的nums2
        while(j>=0)
        {
            nums1[k--] = nums2[j--];
        }
    }
};
```
Java Code:
```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i=m-1, j=n-1, k=m+n-1;
        // 合并
        while(i>=0 && j>=0)
        {
            if(nums1[i] > nums2[j])
            {
                nums1[k--] = nums1[i--];
            }
            else
            {
                nums1[k--] = nums2[j--];
            }
        }
        // 合并剩余的nums2
        while(j>=0)
        {
            nums1[k--] = nums2[j--];
        }
    }
}
```
Python Code:
```python
class Solution(object):
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: None Do not return anything, modify nums1 in-place instead.
        """
        i,j,k = m-1, n-1, m+n-1

        while i >= 0 and j >= 0:
            # print(i,j,k, nums1)
            # print(nums1[i], nums2[j])
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                k-=1
                i-=1
            else:
                nums1[k] = nums2[j]
                k-=1
                j-=1
        while j >= 0:
            nums1[k] = nums2[j]
            k-=1
            j-=1
```
JavaScript Code:
```javascript
/**
 * JavaScript 描述
 * 双指针 + 从后向前
 */
var merge = function(nums1, m, nums2, n) {
    let len = m + n;
    while(m > 0 && n > 0){
        // '>=' 相比 '>' 在某些值相同的情况下能少比较一次
        nums1[--len] = nums2[n-1] >= nums1[m-1] ? nums2[--n]: nums1[--m];
    }
    if(n > 0){
        nums1.splice(0,n,...nums2.slice(0,n));
    }
};
```
<a name="UPH9k"></a>
### 复杂度分析

- 时间复杂度: **O( m+n )**
- 空间复杂度: **O( 1 )**

<a name="RXuAk"></a>
# #092 反转链表 II
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 92 号问题：反转链表 II。题目难度为 Medium，目前通过率为 43.8% 。
<a name="pJMLv"></a>
### 题目描述
反转从位置 _m_ 到 _n_ 的链表。请使用一趟扫描完成反转。<br />**说明:**<br />1 ≤ _m_ ≤ _n_ ≤ 链表长度。<br />**示例:**
```
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```
<a name="R9ZPV"></a>
### 题目解析
[Reverse Linked List](https://xiaozhuanlan.com/topic/7513064892)的延伸题。<br />可以考虑取出需要反转的这一小段链表，反转完后再插入到原先的链表中。<br />**以本题为例：**<br />变换的是 2，3，4这三个点，那么我们可以先取出 2 ，用 front 指针指向 2 ，然后当取出 3 的时候，我们把 3 加到 2 的前面，把 front 指针前移到 3 ，依次类推，到 4 后停止，这样我们得到一个新链表 4 -> 3 -> 2 , front 指针指向4。<br />对于原链表来说，**有两个点的位置很重要**，需要用指针记录下来，分别是 1 和 5 ，把新链表插入的时候需要这两个点的位置。

- 用 pre 指针记录 1 的位置
- 当 4 结点被取走后，5 的位置需要记下来
- 这样我们就可以把倒置后的那一小段链表加入到原链表中
<a name="nAGGJ"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722372257-2b21985d-41be-49e2-80c9-6ed2d3d2956c.gif#averageHue=%232a2928&clientId=u56574840-1b68-4&from=url&id=tkyXT&originHeight=584&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua3804559-db4d-4227-ba16-927ed17c729&title=)
<a name="jmcSm"></a>
### 代码实现
```
class Solution {
public:
    ListNode *reverseBetween(ListNode *head, int m, int n) {
        ListNode *dummy = new ListNode(-1);
        dummy->next = head;
        ListNode *cur = dummy;
        ListNode *pre, *front, *last;
        for (int i = 1; i <= m - 1; ++i) cur = cur->next;
        pre = cur;
        last = cur->next;
        for (int i = m; i <= n; ++i) {
            cur = pre->next;
            pre->next = cur->next;
            cur->next = front;
            front = cur;
        }
        cur = pre->next;
        pre->next = front;
        last->next = cur;
        return dummy->next;
    }
};
```
<a name="ae9Lh"></a>
# #094 二叉树的中序遍历
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 94 号问题：二叉树的中序遍历。题目难度为 Medium，目前通过率为 35.8% 。
<a name="mNF4o"></a>
### 题目描述
给定一个二叉树，返回它的_中序_ 遍历。<br />**示例:**
```
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```
**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？
<a name="dftnX"></a>
### 题目解析
用**栈(Stack)**的思路来处理问题。<br />中序遍历的顺序为**左-根-右**，具体算法为：

- 从根节点开始，先将根节点压入栈
- 然后再将其所有左子结点压入栈，取出栈顶节点，保存节点值
- 再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中
<a name="Ob7uZ"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722378765-c5bcac6c-9db2-4699-9241-44c6974f213d.gif#averageHue=%23fdfcfc&clientId=u56574840-1b68-4&from=url&id=d86Z5&originHeight=541&originWidth=963&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufa255d19-aa83-4a31-8203-e5a8b402b70&title=)
<a name="JPhmh"></a>
### 代码实现
```
class Solution {
        public List<Integer> inorderTraversal(TreeNode root) {
            List<Integer> list = new ArrayList<>();
            Stack<TreeNode> stack = new Stack<>();
            TreeNode cur = root;
            while (cur != null || !stack.isEmpty()) {
                if (cur != null) {
                    stack.push(cur);
                    cur = cur.left;
                } else {
                    cur = stack.pop();
                    list.add(cur.val);
                    cur = cur.right;
                }
            }
            return list;
        }
}
```
<a name="WMqXn"></a>
## LeetCode 第 94 号问题：二叉树的中序遍历
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 94 号问题：二叉树的中序遍历。题目难度为 Medium
<a name="fqizr"></a>
### 题目描述
给定一个二叉树，返回它的 **中序** 遍历.
<a name="OXFMd"></a>
#### 示例:
```
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```
**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？
<a name="LRGkh"></a>
### 题目解析
<a name="OP2Jg"></a>
#### 第一种方法: 递归
二叉树的中序遍历相信大家已经很熟悉了.操作流程就是 **左 -> 打印 -> 右**.<br />那就按照 **左 -> 打印 -> 右** 这种顺序遍历树就可以了，递归函数实现

- 终止条件:当前节点为空时
- 函数内: 递归的调用左节点，打印当前节点，再递归调用右节点
<a name="TQJ5h"></a>
##### 参考代码
```javascript
// lang=javascript
var inorderTraversal = function(root) {
    let res = [];
    handle(root,res);
    return res;
};
function handle(root, res) {
    if (root !== null) {
        handle(root.left, res);
        res.push(root.val);
        handle(root.right, res);
    }
}
```
<a name="T9pZB"></a>
##### 复杂度分析

- 时间复杂度: O(n),
- 空间复杂度: O(h)，h是树的高度
<a name="pcLJS"></a>
#### 第二种方法: 迭代
这题的真正难点在于如何用非递归的方式实现。<br />递归的调用过程是不断往左边走，当左边走不下去了，就打印节点，并转向右边，然后右边继续这个过程，是函数自己调用自己，一层层的嵌套下去，操作系统/虚拟机自动帮我们用 **栈 **来保存了每个调用的函数，现在我们需要自己模拟这样的调用过程。<br />栈的特性是**后进先出**, 那么我们将遍历左子树的节点压栈, 当找不到左子树时, 栈顶就是最底层的左子树, 出栈打印出来; 接着转向右子树父节点, 继续遍历父节点的左子树并压栈,循环如此.<br />因此遍历的过程就是:

1. 压栈根节点
2. 遍历左子树, 压栈, 直到左子树为空
3. 出栈栈顶元素, 打印
4. 转向右子树, 重复 1, 2, 3步骤
<a name="dV6Xh"></a>
##### 动画理解
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391588346-3336cd2d-55d8-4022-a957-28b863b4e816.gif#averageHue=%23ffffff&from=url&id=kCpJO&originHeight=540&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="DMnlz"></a>
##### 参考代码
```javascript
// lang=javascript
var inorderTraversal = function(root) {
    let res = [],
        stack = [],
        node  = root;
    while (stack.length > 0 || node !== null) {
        while (node) {
            stack.push(node);
            node = node.left;
        }
        node = stack.pop();
        res.push(node.val);
        node = node.right;
    }
    return res;
}
```
<a name="tRIG0"></a>
##### 复杂度分析

- 时间复杂度：O(n)
- 空间复杂度：O(n)
<a name="qgvkb"></a>
# #101 对称二叉树
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 第 101 号问题：对称二叉树。
<a name="fAcYb"></a>
### 题目描述
给定一个二叉树，检查它是否是镜像对称的。<br />例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
```
1
   / \
  2   2
 / \ / \
3  4 4  3
```
<a name="M1HHL"></a>
### 题目解析
用递归做比较简单：一棵树是对称的**等价**于它的左子树和右子树两棵树是对称的，问题就转变为判断两棵树是否对称。
<a name="oBuUO"></a>
### 代码实现
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        //把问题变成判断两棵树是否是对称的
        return isSym(root.left, root.right);
    }
    //判断的是根节点为r1和r2的两棵树是否是对称的
    public boolean isSym(TreeNode r1, TreeNode r2){
        if(r1 == null && r2 == null) return true;
        if(r1 == null || r2 == null) return false;
        //这两棵树是对称需要满足的条件：
        //1.俩根节点相等。 2.树1的左子树和树2的右子树，树2的左子树和树1的右子树都得是对称的
        return r1.val == r2.val && isSym(r1.left, r2.right) 
                            && isSym(r1.right, r2.left);
    }
}
```
<a name="OTIWI"></a>
# #102 二叉树的层序遍历
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 102 号问题：二叉树的层序遍历。题目难度为 Medium，目前通过率为 55.8% 。
<a name="GJK1W"></a>
### 题目描述
给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。<br />例如:<br />给定二叉树: [3,9,20,null,null,15,7],
```
3
   / \
  9  20
    /  \
   15   7
```
返回其层次遍历结果：
```
[
  [3],
  [9,20],
  [15,7]
]
```
<a name="iHnzI"></a>
### 题目解析
该问题需要用到**队列**

- 建立一个queue
- 先把根节点放进去，这时候找根节点的左右两个子节点
- 去掉根节点，此时queue里的元素就是下一层的所有节点
- 用for循环遍历，将结果存到一个一维向量里
- 遍历完之后再把这个一维向量存到二维向量里
- 以此类推，可以完成层序遍历
<a name="XSEka"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722398411-07f9cabf-1781-4269-901d-92d3b45f0410.gif#averageHue=%23fdfcfc&clientId=u56574840-1b68-4&from=url&id=x8RMu&originHeight=538&originWidth=961&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u37d3d535-9148-43f0-b841-60c98f6cd61&title=)
<a name="ab0Y5"></a>
### 代码实现
```
/// BFS
/// Time Complexity: O(n), where n is the number of nodes in the tree
/// Space Complexity: O(n)
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {

        vector<vector<int>> res;
        if(root == NULL)
            return res;

        queue<pair<TreeNode*,int>> q;
        q.push(make_pair(root, 0));

        while(!q.empty()){

            TreeNode* node = q.front().first;
            int level = q.front().second;
            q.pop();

            if(level == res.size())
                res.push_back(vector<int>());
            assert( level < res.size() );

            res[level].push_back(node->val);
            if(node->left)
                q.push(make_pair(node->left, level + 1 ));
            if(node->right)
                q.push(make_pair(node->right, level + 1 ));
        }

        return res;
    }
};
```
<a name="VpOoI"></a>
# #103 二叉树的锯齿形层次遍历
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 103 号问题：二叉树的锯齿形层次遍历。题目难度为 Medium，目前通过率为 43.8% 。
<a name="cAN72"></a>
### 题目描述
给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br />例如：<br />给定二叉树 [3,9,20,null,null,15,7],
```
3
   / \
  9  20
    /  \
   15   7
```
返回锯齿形层次遍历如下：
```
[
  [3],
  [20,9],
  [15,7]
]
```
<a name="LxUzv"></a>
### 题目解析
该问题需要用到**队列**，与之前的[二叉树的层次遍历](https://xiaozhuanlan.com/topic/8579460312)类似，不同点在于在偶数层需要翻转一下。

- 建立一个queue
- 先把根节点放进去，这时候找根节点的左右两个子节点
- 去掉根节点，此时queue里的元素就是下一层的所有节点
- 循环遍历，将结果存到一个一维向量里
- 遍历完之后再把这个一维向量存到二维向量里
- 如果该层为偶数层，则reverse翻转一下
- 以此类推，可以完成层序遍历
<a name="UhLvo"></a>
### 动画描述

<a name="RuETe"></a>
### 代码实现
![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693722406762-18358cfc-da1f-4677-998b-41f640fcd023.png#averageHue=%23f9f9f9&clientId=u56574840-1b68-4&from=url&id=itWYf&originHeight=1846&originWidth=2048&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u628416a4-bc71-47d8-85bd-172b27f3b1b&title=)
<a name="zaVLI"></a>
# #104 二叉树的最大深度
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />今天分享的题目来源于 LeetCode 上第 104 号问题：二叉树的最大深度。题目难度为 Easy 。
<a name="QQXy4"></a>
### 题目描述
给定一个二叉树，找出其最大深度。<br />二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br />**说明:** 叶子节点是指没有子节点的节点。<br />**示例 ：**<br />给定二叉树 [3,9,20,null,null,15,7]，
```
3
   / \
  9  20
    /  \
   15   7
```
返回它的最大深度 3 。
<a name="Vuzpp"></a>
### 题目解析 - DFS
最直接的办法就是使用DFS ( 深度优先搜索 ) 策略计算树的高度. 具体算法流程如下:

- **终止条件：**当前节点为空
- **返回值：**
   - 节点为空时，所以返回 0
   - 节点不为空时, 返回左右子树高度的最大值 + 1
<a name="jhYo7"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391588090-80418c8a-6b3a-4e68-961e-bc6532cb1a47.gif#averageHue=%23ffffff&from=url&id=R3KS6&originHeight=540&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="Q1cyq"></a>
### 代码实现
```javascript
/**
 * JavaScript 描述
 * DFS
 */
var maxDepth = function(root) {
    if (root == null) {
        return 0;
    }
    let leftHeight = maxDepth(root.left);
    let rightHeight = maxDepth(root.right);
    return Math.max(leftHeight, rightHeight) + 1;
};
```
**精简版**
```javascript
var maxDepth = function(root) {
    return !root ? 0 : Math.max(maxDepth(root.left) + 1, maxDepth(root.right) + 1) ;
};
```
<a name="JMAHm"></a>
### 复杂度分析

- 时间复杂度：**O(n)**, 我们每个结点只访问一次，因此时间复杂度为 O(N)
- 空间复杂度： 
   - 最坏情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。
   - 最好情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O(log(N))
<a name="W4uA2"></a>
### 题目解析 - BFS
求二叉树的深度也就是求二叉树有几层了, 采用 BFS ( 广度优先搜索 ) 策略对二叉树按层遍历.<br />实现 BFS 就要用到 '先进先出' 的队列了, 具体算法流程如下:

- 遍历二叉树节点，依次将当前节点 和它的左右子节点入队
- 依次出队, 出队子节点重复上一步操作
<a name="qJ1Ih"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391588346-3336cd2d-55d8-4022-a957-28b863b4e816.gif#averageHue=%23ffffff&from=url&id=EUW1w&originHeight=540&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="Wviq9"></a>
### 代码实现
```javascript
/**
 * JavaScript 描述
 * BFS
 */
var maxDepth = function(root) {
    let level = 0;
    if (root == null) {
        return level;
    }
    let queue = [root];
    while (queue.length) {
        let len = queue.length;
        while (len--) {
            let curNode = queue.pop();
            curNode.left && queue.unshift(curNode.left);
            curNode.right && queue.unshift(curNode.right);
        }
        level++;
    }
    return level;
};
```
<a name="IwOxa"></a>
### 复杂度分析

- 时间复杂度：**O(n)**
- 空间复杂度：**O(N)**
<a name="yXfit"></a>
# #107 二叉树的层次遍历 II
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 107 号问题：二叉树的层次遍历 II。题目难度为 Easy，目前通过率为 55.8% 。
<a name="CDrH5"></a>
### 题目描述
给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）<br />例如：<br />给定二叉树 [3,9,20,null,null,15,7],
```
3
   / \
  9  20
    /  \
   15   7
```
返回其自底向上的层次遍历为：
```
[
  [15,7],
  [9,20],
  [3]
]
```
<a name="Ex7QN"></a>
### 题目解析
该问题需要用到**队列**，解法与上篇[每天一算：Binary Tree Level Order Traversal](https://xiaozhuanlan.com/topic/8579460312)类似，区别在于最后存储方式的不同。

- 建立一个 queue
- 先把根节点放进去，这时候找根节点的左右两个子节点
- 去掉根节点，此时queue里的元素就是下一层的所有节点
- 用 for 循环遍历，将结果存到一个一维向量里
- 遍历完之后再把这个一维向量**插入**到二维向量里
- 以此类推，可以完成层序遍历
<a name="h5emd"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722419231-c7a63204-acb8-49aa-be24-1e70aab9cdb0.gif#averageHue=%23fdfcfc&clientId=u56574840-1b68-4&from=url&id=N7rAK&originHeight=538&originWidth=961&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u66c9cc88-b0b2-4bdf-b8cc-3ad2ea9bfcb&title=)
<a name="xieZ1"></a>
### 代码实现
![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693722419861-46981939-9021-42d5-bbfb-f364a8fc0435.png#averageHue=%23bae07e&clientId=u56574840-1b68-4&from=url&id=Fit1n&originHeight=1340&originWidth=1496&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u31e5c998-39b5-4f36-b3ff-fb3160ff999&title=)
<a name="okwMv"></a>
# #110 平衡二叉树
同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 110 号问题：平衡二叉树。
<a name="H1cI5"></a>
### 题目描述
给定一个二叉树，判断它是否是高度平衡的二叉树。
<a name="oCj4O"></a>
### 题目解析
采取**后序遍历**的方式遍历二叉树的每一个结点。<br />在遍历到一个结点之前已经遍历了它的左右子树，那么只要在遍历每个结点的时候记录它的深度（某一结点的深度等于它到叶结点的路径的长度），就可以一边遍历一边判断每个结点是不是平衡的。
<a name="Hy5v5"></a>
### 动画描述
待补充
<a name="wap2I"></a>
### 代码实现
```java
class Solution {
    private boolean isBalanced = true;
    public boolean isBalanced(TreeNode root) {
        getDepth(root);
        return isBalanced;
    }
      public int getDepth(TreeNode root) {
      if (root == null)
			return 0;
		int left = getDepth(root.left);
		int right = getDepth(root.right);
		if (Math.abs(left - right) > 1) {
			isBalanced = false;
		}
		return right > left ? right + 1 : left + 1;
      }
}
```

本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 110 号问题：平衡二叉树。
<a name="uWXKv"></a>
### 题目描述
给定一个二叉树，判断它是否是高度平衡的二叉树。<br />本题中，一棵高度平衡二叉树定义为：<br />一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过1。<br />**示例 1:**
```
3
   / \
  9  20
    /  \
   15   7
```
返回 true 。<br />**示例 2:**<br />给定二叉树 [1,2,2,3,3,null,null,4,4]
```
1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```
返回 false 。
<a name="JsyBL"></a>
### 题目解析 - 自顶向下
这道题可以算是递归的充分使用了, 每一个子树都是子问题.<br />根据题意, 直观的想法就是计算当前节点左右子树的高度差了, 具体算法流程如下:<br />_定义_ 方法 depth(root) 计算 root 最大高度

- **终止条件：** 当 root 为空，即越过叶子节点，则返回高度 0
- **返回值：** Max(左子树高度, 右子树高度 ) + 1

_定义_ 方法 isBalanced(root) 判断树 root 是否平衡

- **特例处理：** 若树根节点 root 为空，则直接返回 true
- **返回值：** 所有子树都需要满足平衡树性质，因此以下三者使用与 逻辑与 连接 
   - abs(depth(root.left) - depth(root.right)) < 2 ：判断 **当前子树** 是否是平衡树
   - isBalanced(root.left) ： 先序遍历递归，判断 **当前子树的左子树** 是否是平衡树；
   - isBalanced(root.right) ： 先序遍历递归，判断 **当前子树的右子树** 是否是平衡树；

通过流程能发现, 暴力法虽然容易想到, 但是会产生大量冗余计算, 因此时间复杂度也就会高;<br />想避免这种情况, 移步向下看 自底向上 方法
<a name="OBajq"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391588090-80418c8a-6b3a-4e68-961e-bc6532cb1a47.gif#averageHue=%23ffffff&from=url&id=ukimq&originHeight=540&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="yczvz"></a>
### 参考代码
```javascript
/**
 * JavaScript 描述
 * 自顶向下递归
 */
function depth(root) {
    if (root == null) {
        return 0;
    }
    return Math.max(depth(root.left), depth(root.right)) + 1;
};
var isBalanced = function(root) {
    if (root == null) {
        return true;
    }
    return Math.abs(depth(root.left) - depth(root.right)) < 2 &&
           isBalanced(root.left) &&
           isBalanced(root.right);
};
```
<a name="cfUKo"></a>
### 复杂度分析

- 时间复杂度: **O(Nlog_2 N)**最差情况下， isBalanced(root) 遍历树所有节点，占用 O(N)O(N) ；判断每个节点的最大高度 depth(root) 需要遍历 各子树的所有节点 ，子树的节点数的复杂度为 O(log_2 N)
- 空间复杂度: **O(N)**最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间
<a name="zmq2I"></a>
### 题目解析 - 自底向上
**自顶向下** 计算 depth 存在大量冗余, 每次调用 depth 时，要同时计算其子树高度。<br />**自底向上** 计算每个子树的高度只会计算一次。先递归计算当前节点的子节点高度，然后再通过子节点高度判断当前节点是否平衡，从而消除冗余。<br />**自底向上** 与 **自顶向下** 的逻辑相反，首先判断子树是否平衡，然后比较子树高度判断父节点是否平衡。算法如下：<br />_定义_ 方法 recur(root): : 判断子树是否平衡 | 返回当前节点高度

- **递归终止条件：**
   - 当越过叶子节点时, 返回高度 0
   - 当左（右）子树高度 left== -1 时，代表此子树的 **左（右）子树** 不是平衡树, 因此直接返回 -1
- **递归返回值：**
   - 当节点 root 左 / 右子树的高度差 < 2：返回以节点 root 为根节点的子树的最大高度Max( left, right ) + 1
   - 当节点 root 左 / 右子树的高度差 >= 2 ：则返回 -1 , 代表 **此子树不是平衡树**

_定义_ 方法 isBalanced(root) : 判断当前树是否平衡

- **返回值：** 若 recur(root) != 1 , 则说明此树平衡, 返回 true , 否则返回 false
<a name="Wpi99"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391588346-3336cd2d-55d8-4022-a957-28b863b4e816.gif#averageHue=%23ffffff&from=url&id=lVsja&originHeight=540&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="upNEw"></a>
### 参考代码
```javascript
/**
 * JavaScript 描述
 * 自底向上递归
 */
function recur(root) {
    if (root == null) {
        return 0;
    }
    let leftHeight = recur(root.left);
    if (leftHeight == -1) {
        return -1;
    }
    let rightHeight = recur(root.right);
    if (rightHeight == -1) {
        return -1;
    }
    return Math.abs(leftHeight - rightHeight) < 2 ? 
           Math.max(leftHeight,rightHeight) + 1 : -1;
};
var isBalanced = function(root) {
    return recur(root) != -1;
};
```
<a name="zi8Lc"></a>
### 复杂度分析

- 时间复杂度 **O(N)**： N为树的节点数；最差情况下，需要递归遍历树的所有节点。
- 空间复杂度 **O(N)**： 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。

<a name="ryUeF"></a>
# #118 杨辉三角
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />个人博客：www.zhangxiaoshuai.fun<br />**本题选自leetcode第118题，easy级别，目前通过率66.4%**
<a name="GwJe1"></a>
## 题目描述
```
给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
示例:

输入: 5
输出:
[
    	 [1],
   	 	[1,1],
  	   [1,2,1],
  	  [1,3,3,1],
 	 [1,4,6,4,1]
]
```
<a name="So5hG"></a>
## 题目分析
初中时候学习的杨辉三角想不到又在这里出现了，题意很容易理解，每一行中的第一个数字和最后一个数字都是1，中间的数字都是通过上面相邻的两个数字相加得到。题目给我们一个杨辉三角的非负行数，然后我们生成对应的杨辉三角（集合）。<br />既然返回的是一个List<List>，那么我们用一个大集合来放置每一行的数，每一行的数我们分别用一个小集合来存放，最后将每一个小集合添加进大集合中。
<a name="BZNov"></a>
### gif动画演示：
官方中已经有做的非常好的gif图解，这里直接展示：<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391623308-4a8c572c-40ec-4cbe-b826-c14d2884554b.gif#averageHue=%2382786d&from=url&id=zsPnf&originHeight=240&originWidth=260&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="hRYWg"></a>
### 代码：
```java
public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> triangle = new ArrayList<List<Integer>>();
    //给定的numRows为0时直接返回空集合即可
    if (numRows == 0) {
        return triangle;
    }

    //因为杨辉三角的第一行总是1，所以先新建一个list，并将1加入该list中
    triangle.add(new ArrayList<>());
    triangle.get(0).add(1);

    //从第二行开始，新建表示当前行的list，拿到当前行的前一行的list
    for (int rowNum = 1; rowNum < numRows; rowNum++) {
        List<Integer> row = new ArrayList<>();
        List<Integer> prevRow = triangle.get(rowNum-1);

        //一行中的第一个元素
        row.add(1);

        //针对每一行，都是上一行的相邻的两个元素相加得到两个1中间的数
        for (int j = 1; j < rowNum; j++) {
            row.add(prevRow.get(j-1) + prevRow.get(j));
        }

        //一行中的最后一个元素
        row.add(1);

        //最后将“整行添加到大集合中”
        triangle.add(row);
    }
	return triangle;
}
```
<a name="CvR2k"></a>
# #124 二叉树中的最大路径和
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 124 号问题：二叉树中的最大路径和。题目难度为 Hard，目前通过率为 39.9% 。<br /> 

<a name="Td2mi"></a>
### 题目描述
给定一个非空二叉树，返回其最大路径和。<br />本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。<br />**示例 1:**
```
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```
**示例 2:**
```
输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42
```
 

<a name="DdSHQ"></a>
### 题目解析
二叉树问题，题目要求出一个二叉树的最大路径和，路径和就是把一条路径上面节点的值加起来，这一题的难点在于路径的方向不固定，只要是任意两点间的通路都算是有效路径，如果不提前列出合理的规划，这道题将无从下手。一般来说，解决树的问题都需要用到递归，**树上的搜索，本质上也是深度优先搜索**，但是这里会有两种考虑方式，一个是**自底向上的分治**，也就是进入递归，一开始不做任何节点上面的计算或者是处理，直接进入到下一层递归，直到到了最底层，然后再开始计算并返回答案，然后上层树节点的递归函数就会收到下层返回的结果，这样做的好处是，一个节点可以获知其子树的局部答案；另外一个是**自顶向下的遍历搜索**，这个和之前的思路完全相反，也就是先处理当前节点的内容，处理完后去到下一层节点，这种方法一般没有返回值，但是一般会有一个全局或者是引用变量，用来记录遍历过程中的内容。<br />我们再回过头来看这道题，在递归遍历的过程中，对于当前节点，其在路径中可以是路径尾，路径头（假设路径是从上到下的，其实在这道题中，没有头尾的概念），也可以是路径中的一个节点。那怎么判断呢？这时我们得需要当前节点左右子树的信息，所以我们可以考虑使用之前提到的 **自底向上** 的分治，有了当前节点，左右子树到当前节点的最大路径，我们可以看看这里会有几种情况，我用 **root** 表示当前节点，**left** 表示左子树到 root 的最大和的路径，**right** 表示右子树到 root 的最大和的路径：

- root 和左右路径形成路径（left - root - right）
- root 和左路径形成路径（left - root）
- root 和右路径形成路径（root - right）
- root 自成路径（root）

你可以看到这四种情况都会把当前节点考虑在内，我们可以更新这里的最大值。但是需要注意的是，我们返回的时候，第一种情况是不能返回的，因为对于上一层节点来说，其无法形成有效的路径，因此我们只需要将 2，3，4 中的最大值返回即可，当然，更新全局答案的时候，这 4 种情况都需要考虑在内的。<br /> 

<a name="zkrgf"></a>
### 代码实现
```java
private int maximum = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) {
    if (root == null) {
        return 0;
    }
    
    helper(root);
    
    return maximum;
}

private int helper(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 如果左右子树返回的最大路径值小于 0
    // 直接将值设为 0，也就是不考虑对应的路径
    int leftMax = Math.max(0, helper(root.left));
    int rightMax = Math.max(0, helper(root.right));
    
    maximum = Math.max(root.val + leftMax + rightMax, maximum);
    
    return Math.max(leftMax + root.val, rightMax + root.val);
}
```
 

<a name="cw2eK"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391626025-ae8e77cd-a71d-482d-8276-d5c041b3df6c.gif#from=url&id=O2qLJ&originHeight=810&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="xnFyB"></a>
# #125 验证回文串
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 第 125 号问题：验证回文串。这道题目是 **初级程序员** 在面试的时候经常遇到的一道算法题，而且面试官喜欢面试者手写！
<a name="tGWfq"></a>
### 题目描述
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<br />**说明：**本题中，我们将空字符串定义为有效的回文串。<br />**示例 1:**
```
输入: "A man, a plan, a canal: Panama"
输出: true
```
**示例 2:**
```
输入: "race a car"
输出: false
```
<a name="qqZCi"></a>
### 题目解析
先理解一个概念：所谓回文，就是一个正读和反读都一样的字符串。<br />先假设是验证单词 level 是否是回文字符串，通过概念涉及到 正 与 反 ，那么很容易想到使用双指针，从字符的开头和结尾处开始遍历整个字符串，相同则继续向前寻找，不同则直接返回 false。<br />而这里与单独验证一个单词是否是回文字符串有所区别的是加入了 空格 与 非字母数字的字符，但实际上的做法一样的：<br />一开始先建立两个指针，left 和 right , 让它们分别从字符的开头和结尾处开始遍历整个字符串。<br />如果遇到非字母数字的字符就跳过，继续往下找，直到找到下一个字母数字或者结束遍历，如果遇到大写字母，就将其转为小写。<br />当左右指针都找到字母数字时，可以进行比较的时候，比较这两个字符，如果相等，则两个指针向它们的前进方向挪动，然后继续比较下面两个分别找到的字母数字，若不相等，直接返回 false。
<a name="B8LAo"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391628422-b94c6928-2a95-4094-a55e-868bab40f680.gif#averageHue=%23fdfdfd&from=url&id=Fov39&originHeight=525&originWidth=944&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="iOUaU"></a>
### 代码实现
注：isLetterOrDigit 方法确定指定的字符是否为字母或数字。
```java
class Solution {
    public boolean isPalindrome(String s) {
        if(s.length() == 0)
             return true;
        int l = 0, r = s.length() - 1;
        while(l < r){
            //确定指定的字符是否为字母或数字
            if(!Character.isLetterOrDigit(s.charAt(l))){
                l++;
            }else if(!Character.isLetterOrDigit(s.charAt(r))){
                r--;
            }else{
                if(Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r)))
                    return false;
                l++;
                r--;
            } 
        }
        return true;
    }
}
```
<a name="FMW4c"></a>
# #126 最长连续序列
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 128 号问题：最长连续序列。题目难度为 Hard，目前通过率为 48.5% 。<br /> 

<a name="vCozx"></a>
### 题目描述
给定一个未排序的整数数组，找出最长连续序列的长度。<br />要求算法的时间复杂度为 O(n)。<br />**示例 1:**
```
输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```
 

<a name="oU2AY"></a>
### 题目解析
题目直接明了，给你一个未排序的数组，让你从中找出一些元素，使这些元素能够组成最长 **连续的递增序列**，输出这个序列的长度，元素的先后没有关系，比如：
```
[100, 4, 200, 1, 3, 2]

可以找出 4, 1, 3, 2 组成连续递增序列 1, 2, 3, 4

输出这个序列长度 4
```
很直接的想法是把数组排序一下，然后遍历一遍就可以找到答案，但是这道题目的难点在于它限制时间复杂度为 O(n)，这样一来，排序这条路走不通。<br />这道题目其实有一个特征，就是这道题目隐含着 **连通性** 这个性质在里面，怎么讲？我们还是拿上面那个例子来举例：
```
[100, 4, 200, 1, 3, 2]

我们从左向右枚举数组里面的元素，你可以认为枚举过的元素是有效的：
................100    枚举第一个元素，此时有 1 个连通区域
...4............100    枚举第二个元素，第二个元素和前面的元素互不相连，此时有 2 个连通区域
...4............100............200   枚举第三个元素，三个元素互不相连，此时有 3 个连通区域
1..4............100............200   枚举第四个元素，四个元素互不相连，此时有 4 个连通区域
1.34............100............200   枚举第五个元素，这个元素和之前第二个连通区域相连，连通区域维持在 4 个
1234............100............200   枚举第六个元素，这个元素和两个连通区域相连，连通区域变成 3 个

最后包含元素最多的那个连通区域所包含的元素个数就是我们要的答案
```
知道了这些东西对我们解题有什么帮助呢？关于连通性的问题，首先要想到的一个数据结构就是 **并查集**，这个数据结构的设计初衷就是为了解决连通性的问题，而且它的两个操作，查找以及合并的时间复杂度可以近似看成是 O(1)，因此用来解决这道题目再适合不过了。<br />如果你能想到并查集，那么这道题目其实就没有更多的难点，但我想说的是，这道题目其实还有一个比较有趣的解法，是利用 HashMap 来记录边界点所涵盖的连通区块长度，还是跟着例子走一遍：
```
[100, 4, 200, 1, 3, 2]

我们还是从左向右枚举数组里面的元素，每次遍历都去看这个元素的左右是否存在，并更新 HashMap：
100   此时 99 以及 101 都没有任何区块，Map {100=1}，表示 100 这个区块大小为 1
4     此时 3 以及 5 都没有任何区块，Map {100=1, 4=1}
200   此时 199 以及 201 都没有任何区块，Map {100=1, 4=1, 200=1}
1     此时 0 以及 2 都没有任何区块，Map {100=1, 4=1, 200=1, 1=1}
3     发现 4 是存在的，4，3 形成一个新的区块，
      这个区块的左边界是 3，右边界是 4，区块大小是 2，
      Map 中更新边界元素所代表的区块大小，Map {100=1, 4=2, 200=1, 1=1, 3=2}
2     发现左右边界同时存在，1, 2, 3, 4 形成一个新的区块
      这个区块的左边界是 1，右边界是 4，区块大小是 4，
      Map 中更新边界元素所代表的区块大小，并记录当前元素避免重复访问，
      Map {100=1, 4=4, 200=1, 1=4, 3=2, 2=4}
```
可以看到，每次记录的时候，我们只需要保证区块的边界元素所表示的区块大小是正确的即可，至于区块中间的元素其实无所谓，因为这些元素并不会被再次访问到<br />这个方法其实挺巧妙的，通过利用哈希表的元素向左右延伸来确定区块的大小。<br /> 

<a name="gPvSF"></a>
### 代码实现（并查集）
```java
class Solution {
    // roots 用来记录一个连通区域的代表元素
    private Map<Integer, Integer> roots = new HashMap<>();
    
    // counts 用来记录一个连通区域的元素个数
    private Map<Integer, Integer> counts = new HashMap<>();
    
    private int find(int a) {
        if (roots.get(a) == a)  {
            return a;
        }
        
        int root = find(roots.get(a));
        
        // 路径压缩
        roots.put(a, root);
        
        return root;
    }
    
    private void union(int a, int b) {
        int rootA = find(a);
        int rootB = find(b);
        
        if (rootA != rootB) {
            roots.put(rootA, rootB);
            
            // 两个连通区域合并，更新整个区域的元素个数
            counts.put(rootB, counts.get(rootA) + counts.get(rootB));
        }
    }
    
    public int longestConsecutive(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        for (int i = 0; i < nums.length; ++i) {
            if (roots.containsKey(nums[i])) {
                continue;
            }
            
            roots.put(nums[i], nums[i]);
            counts.put(nums[i], 1);
            
            // 查看相邻元素是否存在连通区块
            if (roots.containsKey(nums[i] - 1) && roots.containsKey(nums[i] + 1)) {
                int root = find(roots.get(nums[i] - 1));
                
                // 左右都存在连通区域，合并这三个区域
                union(nums[i], root);
                union(root, roots.get(nums[i] + 1));
            } else if (roots.containsKey(nums[i] - 1)) {
                int root = find(roots.get(nums[i] - 1));
                
                // 左边存在连通区域，合并这这两个区域
                union(nums[i], root);
            } else if (roots.containsKey(nums[i] + 1)) {
                int root = find(roots.get(nums[i] + 1));
                
                // 右边存在连通区域，合并这这两个区域
                union(nums[i], root);
            }
        }
        
        int result = 1;
        
        // 遍历所有连通区块，找到包含元素最多的区块
        for (int i : counts.keySet()) {
            result = Math.max(result, counts.get(i));
        }
        
        return result;
    }
}
```
 

<a name="nYW8s"></a>
### 动画描述（并查集）
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391629718-bf01846b-8c49-4929-8338-a46f7e16944c.gif#averageHue=%23fefefe&from=url&id=dV0gz&originHeight=608&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br /> 

<a name="VHkNz"></a>
### 代码实现（哈希表）
```java
public int longestConsecutive(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    
    Map<Integer, Integer> distances = new HashMap<>();
    
    int result = 1;
    
    for (int num : nums) {
        if (distances.containsKey(num)) {
            continue;
        }
        
        // 查找向左能够延伸的最长距离
        int left = distances.getOrDefault(num - 1, 0);
        
        // 查找向右能够延伸的最长距离
        int right = distances.getOrDefault(num + 1, 0);
        
        // 更新此时的左右边界所表示的区块大小
        distances.put(num - left, left + right + 1);
        distances.put(num + right, left + right + 1);
        
        // 数组中可能存在重复元素，记录当前元素，避免再次访问
        distances.put(num, left + right + 1);

        result = Math.max(result, left + right + 1);
    }
    
    return result;
}
```
 

<a name="ev7Sg"></a>
### 动画描述（哈希表）
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391630104-3bd955a1-f314-445c-ac2d-f008383c8656.gif#averageHue=%23fdfdfd&from=url&id=ElCdA&originHeight=608&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br /> 

<a name="RUiIl"></a>
# #131 分割回文串
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 131 号问题：分割回文串。题目难度为 Medium，目前通过率为 45.8% 。
<a name="v1Vv3"></a>
### 题目描述
给定一个字符串 _s_，将 _s_ 分割成一些子串，使每个子串都是回文串。<br />返回 _s_ 所有可能的分割方案。<br />**示例:**
```yaml
输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]
```
<a name="dWhvf"></a>
### 题目解析
首先，对于一个字符串的分割，肯定需要将所有分割情况都遍历完毕才能判断是不是回文数。不能因为 **abba** 是回文串，就认为它的所有子串都是回文的。<br />既然需要将所有的分割方法都找出来，那么肯定需要用到DFS（深度优先搜索）或者BFS（广度优先搜索）。<br />在分割的过程中对于每一个字符串而言都可以分为两部分：左边一个回文串加右边一个子串，比如 "abc" 可分为 "a" + "bc" 。 然后对"bc"分割仍然是同样的方法，分为"b"+"c"。<br />在处理的时候去优先寻找更短的回文串，然后回溯找稍微长一些的回文串分割方法，不断回溯，分割，直到找到所有的分割方法。<br />举个🌰：分割"aac"。

1. 分割为 a + ac
2. 分割为 a + a + c，分割后，得到一组结果，再回溯到 a + ac
3. a + ac 中 ac 不是回文串，继续回溯，回溯到 aac
4. 分割为稍长的回文串，分割为 aa + c 分割完成得到一组结果，再回溯到 aac
5. aac 不是回文串，搜索结束
<a name="OUa4G"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=fFrxk&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="mhtry"></a>
### 代码实现
```java
class Solution {
    List<List<String>> res = new ArrayList<>();
    
    public List<List<String>> partition(String s) {
        if(s==null||s.length()==0)
            return res;
        dfs(s,new ArrayList<String>(),0);
        return res;
    }
    
    public void dfs(String s,List<String> remain,int left){
        if(left==s.length()){  //判断终止条件
            res.add(new ArrayList<String>(remain));  //添加到结果中
            return;
        }
        for(int right=left;right<s.length();right++){  //从left开始，依次判断left->right是不是回文串
            if(isPalindroom(s,left,right)){  //判断是否是回文串
                remain.add(s.substring(left,right+1));   //添加到当前回文串到list中
                dfs(s,remain,right+1);  //从right+1开始继续递归，寻找回文串
                remain.remove(remain.size()-1);  //回溯，从而寻找更长的回文串
            }
        }
    }
    /**
    * 判断是否是回文串
    */
    public boolean isPalindroom(String s,int left,int right){
        while(left<right&&s.charAt(left)==s.charAt(right)){
            left++;
            right--;
        }
        return left>=right;
    }
}
```
<a name="632988d0"></a>
# #133 克隆图

> 本文首发于公众号「图解面试算法」，是 [图解 LeetCode ](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。
>  
> 同步博客：[https://www.algomooc.com](https://www.algomooc.com)


题目来源于 LeetCode 上第 133 号问题：克隆图。题目难度为 Medium，目前通过率为 54.8% 。

<a name="273a27cc"></a>
### 题目描述

给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（int）和其邻居的列表（list[Node]）。

**示例 1:**

```
输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
输出：[[2,4],[1,3],[2,4],[1,3]]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
```

**示例 2:**

```
输入：adjList = [[]]
输出：[[]]
解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。
```

**示例 3:**

```
输入：adjList = [[2],[1]]
输出：[[2],[1]]
```

<a name="a3567729"></a>
### 题目解析

给你一个图，让你完整地拷贝一份。这道题目不难，但是在实际的工作项目中却时常遇到。这道题目有很多种解法，但是建议站在实际工作的角度去思考。

图是由一个个节点组成的，完整地拷贝一份图，那么就意味着我们要对每个节点进行拷贝，而且节点与节点的关系也要拷贝过来。做到这一点也不难，我们只需要遍历一遍图就可以了，这里的关键点在于题目强调是 **无向图**，也就是说我们可以从图上的任意点出发到达图上的所有节点。那么问题从而就转换到了如何遍历图，我们可以使用广度优先搜索，也可以使用深度优先搜索，从工作的角度出发，比较推荐广度优先搜索，因为理解容易，实现简单，而且不涉及栈溢出的问题，处理大规模数据比较安全。


<a name="d8609d39"></a>
### 动画演示

![](../Animation/133.gif#id=rz94Y&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)


<a name="05d8bbc0"></a>
### 复杂度分析

一般使用广度优先搜索遍历图，时间复杂度是 `O(n + m)`，其中这里的 n 表示的是图上的节点数，m 表示的图上的边的数量。从广度优先搜索的 **由点及面** 的性质，你不难理解这个结果。极端情况下，当这张图是一张全联通的图，时间复杂度就会是 `O(n^2)`，解释起来也很容易，因为你每访问完一个节点，下面都会去访问相邻的节点，一个节点和所有的节点相连，那么在一个节点上花费的时间就是 n，在 n 节点上花费的时间就是 n^2。因为我们使用了队列存放接下来需要遍历的节点，空间复杂度就是 `O(n)`。

![](../../Pictures/qrcode.jpg#id=XrTv7&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="MwYqg"></a>
# #134 只出现一次的数字
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 136 号问题：只出现一次的数字。题目难度为 Easy，目前通过率为 66.8% 。
<a name="Op69y"></a>
### 题目描述
给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br />**说明：**<br />你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br />**示例 1:**
```
输入: [2,2,1]
输出: 1
```
**示例 2:**
```
输入: [4,1,2,1,2]
输出: 4
```
<a name="fwtnB"></a>
### 题目解析
根据题目描述，由于加上了时间复杂度必须是 O(n) ，并且空间复杂度为 O(1) 的条件，因此不能用排序方法，也不能使用 map 数据结构。<br />程序员小吴想了一下午没想出来，答案是使用 **位操作Bit Operation** 来解此题。<br />将所有元素做异或运算，即a[1] ⊕ a[2] ⊕ a[3] ⊕ …⊕ a[n]，所得的结果就是那个只出现一次的数字，时间复杂度为O(n)。
<a name="s0Afk"></a>
### 异或
异或运算A ⊕ B的真值表如下：

| A | B | ⊕ |
| --- | --- | --- |
| F | F | F |
| F | T | T |
| T | F | T |
| T | T | F |

<a name="ezNgg"></a>
### 动画演示
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391634761-71936c1a-a928-4f1a-8ceb-f2afa4aadadd.gif#averageHue=%23fdfdfd&from=url&id=brUji&originHeight=537&originWidth=959&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="FXync"></a>
### 代码实现
<a name="LT7VJ"></a>
#### C
```c
int singleNumber(int* nums, int numsSize){
    int res=0;
    for(int i=0;i<numsSize;i++)
    {
        res ^= nums[i];
    }
    
    return res;
}
```
<a name="sQ2jo"></a>
#### C++
```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res=0;
        for(auto n:nums)
        {
            // 异或
            res ^= n;
        }
        return res;
    }
};
```
<a name="o50Vx"></a>
#### Java
```java
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for(int n:nums)
        {
            // 异或
            res ^= n;
        }
        return res;
    }
}
```
<a name="oXocO"></a>
#### pyton
```python
class Solution(object):
    def singleNumber(self, nums):
        return reduce(lambda x,y:x^y, nums)
# reduce用法举例
# 计算列表和：1+2+3+4+5
# 使用 lambda 匿名函数
# reduce(lambda x, y: x+y, [1,2,3,4,5])
```
<a name="cFigJ"></a>
### 进阶版
有一个 n 个元素的数组，除了两个数只出现一次外，其余元素都出现两次，让你找出这两个只出现一次的数分别是几，要求时间复杂度为 O(n) 且再开辟的内存空间固定(与 n 无关)。
<a name="T1yn0"></a>
#### 示例 :
输入: [1,2,2,1,3,4]<br />输出: [3,4]
<a name="UhLBh"></a>
### 题目再解析
根据前面找一个不同数的思路算法，在这里把所有元素都异或，那么得到的结果就是那两个只出现一次的元素异或的结果。<br />然后，因为这两个只出现一次的元素一定是不相同的，所以这两个元素的二进制形式肯定至少有某一位是不同的，即一个为 0 ，另一个为 1 ，现在需要找到这一位。<br />根据异或的性质 任何一个数字异或它自己都等于 0，得到这个数字二进制形式中任意一个为 1 的位都是我们要找的那一位。<br />再然后，以这一位是 1 还是 0 为标准，将数组的 n 个元素分成两部分。

- 将这一位为 0 的所有元素做异或，得出的数就是只出现一次的数中的一个
- 将这一位为 1 的所有元素做异或，得出的数就是只出现一次的数中的另一个。

这样就解出题目。忽略寻找不同位的过程，总共遍历数组两次，时间复杂度为O(n)。
<a name="w5Ohf"></a>
### 动画再演示
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722489920-745ee39e-10bc-489d-be8a-66a86263b347.gif#averageHue=%23fdfdfd&clientId=u56574840-1b68-4&from=url&id=KhkWf&originHeight=535&originWidth=958&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf08795b8-d801-4413-9140-ed555da913b&title=)
<a name="LJq0N"></a>
# #137 只出现一次的数字 II
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 137 号问题：只出现一次的数字 II。题目难度为 Medium，目前通过率为 66.7% 。
<a name="pxjQZ"></a>
### 题目描述
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。<br />说明：<br />你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br />**示例 1:**
```
输入: [2,2,3,2]
输出: 3
```
**示例 2:**
```
输入: [0,1,0,1,0,1,99]
输出: 99
```
<a name="eBddj"></a>
### 题目解析
相比 [Single Number](https://leetcode.com/problems/single-number/)，输入数组的条件变了，数组中除了其中的一个元素只出现了一次，其余的元素都出现了 **三** 次，最后的问题还是让你找出这个只出现一次的元素。这道题目，一开始看起来从位运算思考貌似是不可能的，但如果你从集合的角度去思考或许可以想到解法。如果我们遍历数组里面的元素，在遍历的过程中，我们会发现 **对于每个元素来说只有三种情况，出现一次，出现两次，出现三次**。因为我们要找的是出现一次的那个元素，而且最终除了我们要找的元素，其他所有的元素都会出现三次，因此我们需要想办法排除掉出现三次的元素。一开始的时候可以想，我们用两个集合，集合 1 用于存放出现一次的元素，集合 2 用于存放出现两次的元素，于是我们可以发现下面的逻辑对应关系：
```
如果遍历到的元素不在集合 1 中，也不在集合 2 中： 该元素第一次出现，加入集合 1
如果遍历到的元素在集合 1 中，不在集合 2 中： 该元素第二次出现，移出集合 1，加入集合 2
如果遍历到的元素不在集合 1 中，在集合 2 中： 该元素第三次出现，移出集合 2
```
上面的逻辑对应关系你应该很容易理解，但是我想说的是通过位操作可以做到这一点，我们不需要真正的集合，我们只需要用一个整数来代替集合即可。怎么解释呢？假设我们用整数 ones 表示集合 1，整数 twos 表示集合 2，这两个整数的值初始化均为 0。ones ^ ele[i] 表示把元素 ele[i] 加入到集合 1 中，如果说下一个元素 ele[i + 1] 来了，并且 ele[i] != ele[i + 1]，那么 ones ^ ele[i] ^ ele[i + 1] 肯定会产生一个不为零的值，至于这个值是多少，你不用关心。但如果 ele[i] == ele[i + 1]，那么 ones ^ ele[i] ^ ele[i + 1] 的结果肯定为 0，到这里，你应该知道通过异或运算，我们已经可以做到，将出现一次的元素加入集合 1，将出现两次的元素移出集合 1。但是这还不够，因为元素还有可能出现三次，如果仅仅是上面的异或表达式，第三次出现的元素还是会被加入到集合 1，我们还需要保证该元素不在集合 2 中，(ones ^ ele[i]) & (~twos) 就可以保证这一点。对集合 2 来说也是一样的，(twos ^ ele[i]) & (~ones) 保证将不存在于集合 1 中，且不存在集合 2 中的元素加入到集合 2。如果我们先更新集合 1，再更新集合 2，就可以实现我们之前说的逻辑对应关系。说到这里，如果你还是不理解，那么你 **可以尝试把一个元素看作是一堆值为 1 的 bit 位的组合**，比如 12 的二进制是 0001 0100，如果说 12 出现了三次，那么从右往左数第三位和第五位 bit 的就出现了三次。我们把这个结论放在数组中也是一样的，对于那些出现了 3 的整数倍次的 bits 位我们要进行消除，找到那些出现了 3 * n + 1 次的 bit 位，将它们组合在一起就是我们要找的元素，上面的位运算做的就是这个事情，与其说把元素放入集合中，我们也可以说 **将元素的所有值为 1 的 bit 位放入集合中**，这样会更好理解些。<br /> 

<a name="uNiRW"></a>
### 动画演示
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391636120-3214cfe6-2c2d-4bdc-bb04-20d35b0bccf3.gif#averageHue=%23fefefe&from=url&id=UWvJb&originHeight=608&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="fMFPC"></a>
### 代码实现
<a name="Fwpok"></a>
#### C++
```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int one=0, two=0;
        for(int n:nums)
        {
            one = (one ^ n) & (~two);
            two = (two ^ n) & (~one);
        }
        return one;
    }
};
```
<a name="qqj6L"></a>
#### Java
```java
class Solution {
    public int singleNumber(int[] nums) {
        int one=0, two=0;
        for(int n:nums)
        {
            one = (one ^ n) & (~two);
            two = (two ^ n) & (~one);
        }
        return one;
    }
}
```
<a name="j4Cj1"></a>
#### Python
```python
class Solution(object):
    def singleNumber(self, nums):
        one = two = 0
        for n in nums:
            one = (one ^ n) & (~two)
            two = (two ^ n) & (~one)
        return one
```
<a name="thAgu"></a>
# #138 复制带随机指针的链表
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 138 号问题：复制带随机指针的链表。题目难度为 Medium，目前通过率为 40.5% 。
<a name="XcI7H"></a>
### 题目描述
给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。<br />要求返回这个链表的**深拷贝**。<br />**示例：**
```
输入：
{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}

解释：
节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。
节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。
```
<a name="Ihov1"></a>
### 题目解析

1. 在原链表的每个节点后面拷贝出一个新的节点
2. 依次给新的节点的随机指针赋值，而且这个赋值非常容易 cur->next->random = cur->random->next
3. 断开链表可得到深度拷贝后的新链表

之所以说这个方法比较巧妙是因为相较于一般的解法（如使用 Hash map ）来处理，上面这个解法 **不需要占用额外的空间**。
<a name="OfIy4"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=w0QoS&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="lCd6G"></a>
### 代码实现
我发现带指针的题目使用 C++ 版本更容易描述，所以下面的代码实现是 C++ 版本。
```
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        if (!head) return NULL;
        RandomListNode *cur = head;
        while (cur) {
            RandomListNode *node = new RandomListNode(cur->label);
            node->next = cur->next;
            cur->next = node;
            cur = node->next;
        }
        cur = head;
        while (cur) {
            if (cur->random) {
                cur->next->random = cur->random->next;
            }
            cur = cur->next->next;
        }
        cur = head;
        RandomListNode *res = head->next;
        while (cur) {
            RandomListNode *tmp = cur->next;
            cur->next = tmp->next;
            if(tmp->next) tmp->next = tmp->next->next;
            cur = cur->next;
        }
        return res;
    }
};
```
<a name="vCkp1"></a>
# #139 单词拆分
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 139 号问题：单词拆分。
<a name="LnLNI"></a>
### 题目描述
给定一个**非空**字符串 _s_ 和一个包含**非空**单词列表的字典 _wordDict_，判定 _s_ 是否可以被空格拆分为一个或多个在字典中出现的单词。<br />**说明：**

- 拆分时可以重复使用字典中的单词。
- 你可以假设字典中没有重复的单词。
<a name="fFdqF"></a>
### 题目解析
与 **分割回文串** 有些类似，都是拆分，但是如果此题采取 深度优先搜索 的方法来解决的话，答案是超时的，不信的同学可以试一下~<br />为什么会超时呢？<br />因为使用 深度优先搜索 会重复的计算了有些位的可拆分情况，这种情况的优化肯定是需要 动态规划 来处理的。<br />如果不知道动态规划的，可以看一下小吴之前的万字长文，比较详细的介绍了动态规划的概念。<br />在这里，只需要去定义一个数组 boolean[] memo，其中第 i 位 memo[i] 表示待拆分字符串从第 0 位到第 i-1 位是否可以被成功地拆分。<br />然后分别计算每一位是否可以被成功地拆分。
<a name="l4AMd"></a>
### 动画描述
暂无~
<a name="l2ErN"></a>
### 代码实现
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int n = s.length();
        int max_length=0;
        for(String temp:wordDict){
            max_length = temp.length() > max_length ? temp.length() : max_length;
        }
        // memo[i] 表示 s 中以 i - 1 结尾的字符串是否可被 wordDict 拆分
        boolean[] memo = new boolean[n + 1];
        memo[0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = i-1; j >= 0 && max_length >= i - j; j--) {
                if (memo[j] && wordDict.contains(s.substring(j, i))) {
                    memo[i] = true;
                    break;
                }
            }
        }
        return memo[n];
    }
}
```
<a name="zKDiE"></a>
# #142 环形链表 II
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />今天分享的题目来源于 LeetCode 上第 142 号问题：环形链表II。题目难度为 Medium 。
<a name="KXUD2"></a>
### 题目描述
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br />为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br />**示例 1：**
```
输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。
```
![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693722506295-9c644c64-9b9e-4bf3-9ee0-7842387cd1d3.png#averageHue=%23f9f9f9&clientId=u56574840-1b68-4&from=url&id=tcsxs&originHeight=171&originWidth=531&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u38df9e2b-ce41-402a-b88f-b6794373a49&title=)<br />**示例 2：**
```
输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。
```
![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693722506442-1cd1eabe-7911-49b6-8124-bc602ac6a2a2.png#averageHue=%23f7f7f7&clientId=u56574840-1b68-4&from=url&id=HhMgb&originHeight=105&originWidth=201&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc0cb1072-bfe1-4a54-a16d-d7a9733d15d&title=)<br />**示例 3：**
```
输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。
```
![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693722506434-7a849639-8341-44e8-b93c-2847dba1225e.png#averageHue=%23f4f4f4&clientId=u56574840-1b68-4&from=url&id=XNJur&originHeight=65&originWidth=65&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u86a4b011-2f6f-42c5-8753-448a94cfd0a&title=)<br />**进阶：**<br />你是否可以不用额外空间解决此题？
<a name="lidv6"></a>
### 题目解析 - 哈希表
普通解法就是利用哈希表保存访问过的节点, 同时遍历过程中检查哈希表中是否已存在相同的节点
<a name="IzrVL"></a>
### 代码实现
```javascript
/**
 * JavaScript 描述
 * 哈希表方法
 */
var detectCycle = function(head) {
    let res = [ ];
    while (head !== null) {
        if (res.includes(head)) {
            return head;
        }
        res.push(head);
        head = head.next;
    }
    return null;
};
```
<a name="wYtSY"></a>
### 复杂度分析

- 时间复杂度：**O(n)**
- 空间复杂度：**O(n)**
<a name="tSJ1p"></a>
### 题目解析 - Floyd 算法
Floyd算法 可以达到常量空间解决此问题.<br />我在维基百科找到了这个算法描述, 在此引用一下.<br />**Floyd判圈算法**(**Floyd Cycle Detection Algorithm**)，又称 **龟兔赛跑算法**(**Tortoise and Hare Algorithm**)，是一个可以在[有限状态机](https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA)、[迭代函数](https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%87%BD%E6%95%B0)或者[链表](https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8)上判断是否存在[环](https://zh.wikipedia.org/wiki/%E7%92%B0_(%E5%9C%96%E8%AB%96))，求出该环的起点与长度的算法。<br />如果有限状态机、迭代函数或者链表存在环，那么一定存在一个起点可以到达某个环的某处 ( 这个起点也可以在某个环上 )。<br />初始状态下，假设已知某个起点节点为节点 _S_。现设两个指针 t 和 h ，将它们均指向 _S_。<br />接着，同时让 t 和 h 往前推进，但是二者的速度不同：t 每前进 1 步， h 前进 2 步。只要二者都可以前进而且没有相遇，就如此保持二者的推进。当 h 无法前进，即到达某个没有后继的节点时，就可以确定从 _S_ 出发不会遇到环。反之当 t 与 h 再次相遇时，就可以确定从 S 出发一定会进入某个环，设其为环 _C_。<br />如果确定了存在某个环，就可以求此环的起点与长度。<br />上述算法刚判断出存在环 _C_ 时，显然 t 和 h 位于同一节点，设其为节点 _M_。显然，仅需令 h 不动，而t不断推进，最终又会返回节点 _M_，统计这一次t推进的步数，显然这就是环 _C_ 的长度。<br />为了求出环 _C_ 的起点，只要令h仍均位于节点 _M_ ，而令t返回起点节点 _S_ ，此时h与t之间距为环 _C_ 长度的整数倍。随后，同时让 t 和 h 往前推进，且保持二者的速度相同：t 每前进 1 步，h 前进 1 步。持续该过程直至 t 与 h 再一次相遇，设此次相遇时位于同一节点 _P_，则节点 _P_ 即为从节点 _S_ 出发所到达的环 _C_ 的第一个节点，即环 _C_ 的一个起点。<br />**看完之后是不是很多疑点, 觉得为什么会这样呢?**<br />下面用数学简单证明一下<br />假设 链表的节点数为 num, 从 head 到链表环入口节点数为 m (不包含入口节点), 环的节点数为 n, 链表环入口设点为 _P_<br />由此可得 num = m + n<br />假设 慢指针 Tortoise (乌龟) 每次走 1 个节点, 走了 x 步<br />假设 快指针 Hare (兔子) 每次走 2 个节点, 走了 f 步<br />那么 f = 2x<br />当第一次相遇时, 必然是在环内, 设其点为 _M_, 兔子第一次到达 _M_ 点后至少又在环内饶了一圈后追上乌龟,<br />假设绕了 k 圈, 那么可以得到<br />f = x + kn<br />兔子到达 _P_ 点的步数为<br />f = m + kn<br />由 f = 2x 和 f = x + kn 两个等式可以得到 x = kn<br />由 f = m + kn 和 x = kn 可知, 乌龟到达 _P_ 点还需要走 m 步<br />而 m 的长度正是从 head 到链表环入口节点数的长度, 这是未知的,<br />那么让兔子从 head 以乌龟的速度走, 乌龟在 _M_ 点走, 当兔子和乌龟相遇时即走了 m 步, 也就到达了 _P_ 节点.
<a name="DcdPd"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=wPz7C&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="PNmfW"></a>
### 代码实现
```java
/**
 * JavaScript 描述
 * Floyd判圈算法
 */
var detectCycle = function(head) {
    if (head == null) {
        return head;
    }
    // 设置快慢指针
    let tortoise = head,
        hare = head;
    // 检查链表是否有环
    while (true) {
        if (hare == null || hare.next == null) {
            return null;
        }
        hare = hare.next.next;
        tortoise = tortoise.next;
        if (hare == tortoise) {
            break;
        }
    }
    // 兔子和乌龟第二次相遇找到环入口
    hare = head;
    while (hare != tortoise) {
        hare = hare.next;
        tortoise = tortoise.next;
    }
    return hare;
};
```
<a name="M2hZJ"></a>
### 复杂度分析

- 时间复杂度：**O(n)**
   - 有环情况下, 第一次和第二次相遇, 乌龟步数都小于链表节点数, 因此与链表节点数成线性关系;
   - 无环情况下, 兔子大约需要 n/2 步数到达最后, 因此也与链表节点数成线性关系.
- 空间复杂度：**O(1)** , 双指针使用常数大小的额外空间
<a name="mRJcF"></a>
# #144 二叉树的前序遍历
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 144 号问题：二叉树的前序遍历。题目难度为 Medium，目前通过率为 59.8% 。
<a name="phqtb"></a>
### 题目描述
给定一个二叉树，返回它的 _前序_ 遍历。<br />**示例:**
```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
```
**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？
<a name="QLEm2"></a>
### 题目解析
用**栈(Stack)**的思路来处理问题。<br />前序遍历的顺序为**根-左-右**，具体算法为：

- 把根节点 push 到栈中
- 循环检测栈是否为空，若不空，则取出栈顶元素，保存其值
- 看其右子节点是否存在，若存在则 push 到栈中
- 看其左子节点，若存在，则 push 到栈中。
<a name="DisVT"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=wCLOT&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="i1kFA"></a>
### 代码实现
```
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        //非递归前序遍历，需要借助栈
        Stack<TreeNode> stack = new Stack<>();
        List<Integer> list = new LinkedList<>();
        //当树为空树时，直接返回一个空list
        if(root == null){
            return list;
        }
        //第一步是将根节点压入栈中
        stack.push(root);
        //当栈不为空时，出栈的元素插入list尾部。
        //当它的孩子不为空时，将孩子压入栈，一定是先压右孩子再压左孩子
        while(!stack.isEmpty()){
            //此处的root只是一个变量的复用
            root = stack.pop();
            list.add(root.val);
            if(root.right != null) stack.push(root.right);
            if(root.left != null) stack.push(root.left);
        }
        return list;
    }
}
```
<a name="exv8v"></a>
# #145 二叉树的后序遍历
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 145 号问题：二叉树的后序遍历。题目难度为 Hard，目前通过率为 25.8% 。
<a name="MvqUT"></a>
### 题目描述
给定一个二叉树，返回它的 _后序_ 遍历。<br />**示例:**
```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```
**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？
<a name="i835C"></a>
### 题目解析
用**栈(Stack)**的思路来处理问题。<br />后序遍历的顺序为**左-右-根**，具体算法为：

- 先将根结点压入栈，然后定义一个辅助结点 head
- while 循环的条件是栈不为空
- 在循环中，首先将栈顶结点t取出来
- 如果栈顶结点没有左右子结点，或者其左子结点是 head，或者其右子结点是 head 的情况下。我们将栈顶结点值加入结果 res 中，并将栈顶元素移出栈，然后将 head 指向栈顶元素
- 否则的话就看如果右子结点不为空，将其加入栈
- 再看左子结点不为空的话，就加入栈
<a name="t9lYO"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=hkInt&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="IFiVa"></a>
### 代码实现
```
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    if(root == null)
        return res;
    Stack<TreeNode> stack = new Stack<TreeNode>();
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode node = stack.pop();
        if(node.left != null) stack.push(node.left);//和传统先序遍历不一样，先将左结点入栈
        if(node.right != null) stack.push(node.right);//后将右结点入栈
        res.add(0,node.val);                        //逆序添加结点值
    }     
    return res;
   }
}
```
<a name="kUpf1"></a>
# #146 LRU缓存机制
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 146 号问题：LRU缓存机制。题目难度为 Hard，目前通过率为 15.8% 。
<a name="cOA16"></a>
### 题目描述
运用你所掌握的数据结构，设计和实现一个 [LRU (最近最少使用) 缓存机制](https://baike.baidu.com/item/LRU)。它应该支持以下操作： 获取数据 get 和 写入数据 put 。<br />获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br />写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。<br />**进阶:**<br />你是否可以在 **O(1)** 时间复杂度内完成这两种操作？<br />**示例:**
```
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```
<a name="LEs9Y"></a>
### 题目解析
这道题是让我们实现一个 LRU 缓存器，LRU是Least Recently Used的简写，就是最近最少使用的意思。<br />这个缓存器主要有两个成员函数，get和put。<br />其中 get 函数是通过输入 key 来获得 value，如果成功获得后，这对 (key, value) 升至缓存器中最常用的位置（顶部），如果 key 不存在，则返回 -1 。<br />而 put 函数是插入一对新的 (key, value)，如果原缓存器中有该 key，则需要先删除掉原有的，将新的插入到缓存器的顶部。如果不存在，则直接插入到顶部。<br />若加入新的值后缓存器超过了容量，则需要删掉一个最不常用的值，也就是底部的值。<br />具体实现时我们需要三个私有变量，cap , l 和 m，其中 cap 是缓存器的容量大小，l 是保存缓存器内容的列表，m 是 HashMap，保存关键值 key 和缓存器各项的迭代器之间映射，方便我们以 O(1) 的时间内找到目标项。<br />然后我们再来看 get 和 put 如何实现。<br />其中，get 相对简单些，我们在 m 中查找给定的key，若不存在直接返回 -1；如果存在则将此项移到顶部。<br />对于 put ，我们也是现在 m 中查找给定的 key，如果存在就删掉原有项，并在顶部插入新来项，然后判断是否溢出，若溢出则删掉底部项(最不常用项)。
<a name="LWQnS"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=WBGtG&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="hXTqm"></a>
### 代码实现
```
class LRUCache{
public:
    LRUCache(int capacity) {
        cap = capacity;
    }
    
    int get(int key) {
        auto it = m.find(key);
        if (it == m.end()) return -1;
        l.splice(l.begin(), l, it->second);
        return it->second->second;
    }
    
    void put(int key, int value) {
        auto it = m.find(key);
        if (it != m.end()) l.erase(it->second);
        l.push_front(make_pair(key, value));
        m[key] = l.begin();
        if (m.size() > cap) {
            int k = l.rbegin()->first;
            l.pop_back();
            m.erase(k);
        }
    }
    
private:
    int cap;
    list<pair<int, int>> l;
    unordered_map<int, list<pair<int, int>>::iterator> m;
};
```
<a name="pDDH8"></a>
# #150 逆波兰表达式求值
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 150 号问题：逆波兰表达式求值。题目难度为 Medium，目前通过率为 43.7% 。
<a name="UXIfA"></a>
### 题目描述
根据[逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437)，求表达式的值。<br />有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br />**说明：**

- 整数除法只保留整数部分。
- 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

**示例 1：**
```
输入: ["2", "1", "+", "3", "*"]
输出: 9
解释: ((2 + 1) * 3) = 9
```
**示例 2：**
```
输入: ["4", "13", "5", "/", "+"]
输出: 6
解释: (4 + (13 / 5)) = 6
```
**示例 3：**
```
输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
输出: 22
解释: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```
<a name="trwPe"></a>
### 题目解析
用数据结构栈来解决这个问题。

- 从前往后遍历数组
- 遇到数字则压入栈中
- 遇到符号，则把栈顶的两个数字拿出来运算，把结果再压入栈中
- 遍历完整个数组，栈顶数字即为最终答案
<a name="y8PdA"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=z5kdO&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="SQNMG"></a>
### 代码实现
```
class Solution {
public:
    int evalRPN(vector<string>& tokens) {

        stack<int> nums;
        stack<char> ops;
        for(const string& s: tokens){
            if(s == "+" || s == "-" || s == "*" || s == "/"){
                int a = nums.top();
                nums.pop();
                int b = nums.top();
                nums.pop();

                if(s == "+"){
                    nums.push(b + a);
                }else if(s == "-"){
                    nums.push(b - a);
                } else if(s == "*"){
                    nums.push(b * a);
                }else if(s == "/"){
                    nums.push(b / a);
                }
            }
            else{
                nums.push(atoi(s.c_str()));
            }
        }
        return nums.top();
    }
};
```
题目来源于LeetCode上第160号问题：相交链表。题目难度为Easy，目前通过率54.4%。<br />##题目描述<br />编写一个程序，找到两个单链表相交的起始节点。<br />如下面的两个链表：<br />![](https://cdn.nlark.com/yuque/0/2023/webp/35495747/1693722525996-64294947-91ae-4164-8ad4-05a87384723e.webp#averageHue=%23f9f9f9&clientId=u56574840-1b68-4&from=url&id=t11lK&originHeight=241&originWidth=742&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u05105813-a698-435f-907e-0838615dc09&title=)<br />在节点 c1 开始相交。<br />示例 1：<br />![](https://cdn.nlark.com/yuque/0/2023/webp/35495747/1693722526000-4bd8647f-1ae0-434e-9e5c-5bf36dff05c7.webp#averageHue=%23f9f9f9&clientId=u56574840-1b68-4&from=url&id=DTNlZ&originHeight=241&originWidth=742&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1adc9fc6-e534-477c-a922-b52a983d9de&title=)
```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```
注意：

- 如果两个链表没有交点，返回 null。
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

##题目解析<br />为满足题目时间复杂度和空间复杂度的要求，我们可以使用双指针法。

- 创建两个指针pA和pB分别指向链表的头结点headA和headB。
- 当pA到达链表的尾部时，将它重新定位到链表B的头结点headB，同理，当pB到达链表的尾部时，将它重新定位到链表A的头结点headA。
- 当pA与pB相等时便是两个链表第一个相交的结点。<br />这里其实就是相当于把两个链表拼在一起了。pA指针是按B链表拼在A链表后面组成的新链表遍历，而pB指针是按A链表拼在B链表后面组成的新链表遍历。举个简单的例子：<br />A链表：{1,2,3,4}<br />B链表：{6,3,4}<br />pA按新拼接的链表{1,2,3,4,6,3,4}遍历<br />pB按新拼接的链表{6,3,4,1,2,3,4}遍历

##动画理解<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=xHHmg&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />##代码实现
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *pA = headA;
        ListNode *pB = headB;
        while(pA != pB){
            if(pA != NULL){
                pA = pA->next;
            }else{
                pA = headB;
            }
            if(curB != NULL){
                pB = pB->next;
            }else{
                pB = headA;
            }
        }
        return pA;
    }
};
```
##复杂度分析

- 时间复杂度：O(m+n)。
- 空间复杂度：O(1)

题目来源于LeetCode上第162号问题：寻找峰值。题目难度为中等，目前通过率46.3%。<br />##题目描述<br />峰值元素是指其值大于左右相邻值的元素。<br />给定一个输入数组nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。<br />数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。<br />你可以假设 nums[-1] = nums[n] = -∞。
```
示例 1:

输入:nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。
示例 2:

输入: nums = [1,2,1,3,5,6,4]
输出: 1 或 5 
解释: 你的函数可以返回索引 1，其峰值元素为 2；或者返回索引 5， 其峰值元素为 6。
说明:
你的解法应该是 O(logN) 时间复杂度的。
```
##题目解析<br />我们从题目中可以了解到以下三个关键信息：

- nums[i] ≠ nums[i+1]，意味着数组中没有值相等的元素，要么nums[i]>nums[i+1]，要么nums[i]<nums[i+1]
- 数组可能有多个峰值，我们只需要返回任意一个峰值的索引就行了。
- 假设nums[-1] = nums[n] = -∞，因为数组两端都是负无穷，这意味着从nums[0]开始，一直找到有个值nums[i]>nums[i+1]，那么数组肯定有一个峰值，我们将他的索引返回就行了。

为了更好的理解解题思路，我们先从线性搜索方法开始解析，并且将数组分为三类，即升序数组，降序数组，无序数组。然后，由于我们只需要找到任意一个峰值，返回它的索引就行。所以我们还可以用二分查找法（**PS：凡是搜索查找类型的题，首先想到的应该是效率较高的二分查找方法**）
<a name="WqDuX"></a>
## 解法一：线性扫描
**1、假设数组是升序数组**<br />![](https://cdn.nlark.com/yuque/0/2023/webp/35495747/1693722534376-dd1df1e6-908c-420a-8f6d-d66e01c225af.webp#averageHue=%23fcfbfa&clientId=u56574840-1b68-4&from=url&id=UlhbC&originHeight=529&originWidth=1016&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3dd33e2b-2f80-476a-a608-58591aa7f97&title=)<br />那么很明显我们的峰值是最后一个元素5，因为nums[0]>nums[1]，nums[1]>nums[2]， ......，nums[3]>nums[4]，nums[4]是最后一个元素，所以它的峰值索引是4。<br />**2、假设数组是降序数组**<br />![](https://cdn.nlark.com/yuque/0/2023/webp/35495747/1693722534372-136bfefa-ebc8-4094-a7f5-f4654002da29.webp#averageHue=%23fbfafa&clientId=u56574840-1b68-4&from=url&id=zaXS6&originHeight=506&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u415656c8-8690-4912-9b16-9ce1ef298aa&title=)<br />因为nums[-1]=-∞，并且nums[0]>mums[1]，所以nums[0]就是一个峰值，返回峰值索引是0。<br />**3、假设数组是无序数组**<br />![](https://cdn.nlark.com/yuque/0/2023/webp/35495747/1693722534340-44ffc5af-c8e1-44ec-83f6-c5727cdb4d6f.webp#averageHue=%23fbfafa&clientId=u56574840-1b68-4&from=url&id=I94XH&originHeight=536&originWidth=899&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u32aede22-fda3-47b2-9329-7c9fc987885&title=)<br />同样我们从nums[0]开始往后比较大小，因为nums[0]<nums[1],mums[1]<nums[2],mums[2]<nums[3],mums[3]>mums[4]，所以可以知道mums[3]是一个峰值，返回索引是3。<br />通过以上将数组分类解析，我们可以发现只要从nums[0]开始，与后一个元素比较，直到找到 nums[i]>nums[i+1]，为止，我们就找到了一个峰值，这个峰值的索引就是i，如果一直都没有找到nums[i]>nums[i+1]的情况，那么峰值就是数组的最后一个元素，索引就是nums.length-1。<br />##动画理解<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=t02mC&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />##代码实现
```
public class Solution {
    public int findPeakElement(int[] nums) {
        for (int i = 0; i < nums.length - 1; i++) {
            if (nums[i] > nums[i + 1])
                return i;
        }
        return nums.length - 1;
    }
}
```
##复杂度分析

- 时间复杂度：O(n)，我们对长度为 n 的数组 nums 只进行一次遍历。
- 空间复杂度：O(1)，仅用了常数空间

##解法二：二分查找<br />根据二分查找原理，我们假设左边索引L=0，右边索引R=nums.length - 1，中间索引M=（L+R）/2，现在主要就是判断这个峰值是在M的左边还是右边，然后移动L或者R来进一步缩小搜索范围。<br />我们找到中间元素，然后跟方法一线性扫描一样，与中间元素的右边元素比较。

- 如果nums[M]<nums[M+1]那么可以知道中间元素M的右边肯定会有一个峰值，所以我们把L移到M+1的位置，在M的右边查找。并且重新计算M的值。
- 如果nums[M]>nums[M+1]那么可以知道中间元素M的左边肯定会有一个峰值，所以我们把R移到M的位置，在M的左边查找，并且重新计算M的值。
- 重复以上步骤，直到R=L，那么这个就是峰值元素。

##动画理解<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391648792-c994a883-c947-452d-a029-a30c5cac1f02.gif#averageHue=%23fcfbfb&from=url&id=uhPtg&originHeight=360&originWidth=480&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />##代码实现
```
public class Solution {
    public int findPeakElement(int[] nums) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int mid = (l + r) / 2;
            if (nums[mid] > nums[mid + 1])
                r = mid;
            else
                l = mid + 1;
        }
        return l;
    }
}
```
##复杂度分析

- 时间复杂度：O(log2(n))，每一步都将搜索空间减半,其中n为 nums 数组的长度。。
- 空间复杂度：O(1)，仅用了常数空间

<a name="uA3FR"></a>
# #155 最小栈
<a name="POeZk"></a>
#### 题目描述

> 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
>  
> - push(x) —— 将元素 x 推入栈中。
> - pop() —— 删除栈顶的元素。
> - top() —— 获取栈顶元素。
> - getMin() —— 检索栈中的最小元素。


```java
示例：
   	MinStack minStack = new MinStack();
	minStack.push(-2);
	minStack.push(0);
	minStack.push(-5);
	minStack.push(1)
	minStack.getMin();   --> 返回 -5.
	minStack.pop();
	minStack.top();      --> 返回 -5.
	minStack.getMin();   --> 返回 -5.
```

<a name="SSPcu"></a>
#### 题目解析

为了能在常数时间内检测到栈中的最小元素，我们可以通过"空间换时间"的方式进行实现，为栈本身（数据栈_data）增加一个辅助栈（最小值栈_min）。每一次元素入 _data 栈，则在 _min 栈中增加对应的最小值；当 _data 栈中的元素出栈，则 _min 栈也进行出栈操作

<a name="c3b51358"></a>
#### 动画理解
![](https://github.com/MisterBooo/LeetCodeAnimation/blob/master/0155-min-stack/Animation/Animation.gif#id=VRMZu&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />![Animation.gif](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693726195707-ff65c629-4130-4709-b566-61aa022a603e.gif#averageHue=%23f1f1f0&clientId=uecdb42fd-f3de-4&from=drop&id=u767c668a&originHeight=1080&originWidth=1920&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=9174885&status=done&style=none&taskId=uecc38877-20d2-4e20-89b2-501983358da&title=)
<a name="83175ad0"></a>
#### 代码实现

```java
class MinStack {

    private Stack<Integer> _data;
    private Stack<Integer> _min;

    /** initialize your data structure here. */
    public MinStack() {
        _data = new Stack<>();
        _min = new Stack<>();
    }
    
    public void push(int x) {
        _data.add(x);
        if (_min.isEmpty()){
            _min.push(x);
        }
        else{
            if (x > _min.peek()){
                x = _min.peek();
            }
            _min.push(x);
        }
    }
    
    public void pop() {
        _data.pop();
        _min.pop();
    }
    
    public int top() {
        return _data.peek();
    }
    
    public int getMin() {
        return _min.peek();
    }
}
```

<a name="arTHs"></a>
#### 复杂度分析

- 时间复杂度：O(1)。
- 空间复杂度：O(n)。
<a name="reABu"></a>
# #167 号 两数之和 II - 输入有序数组
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 167 号问题：两数之和 II - 输入有序数组。题目难度为 Easy，目前通过率为 48.2% 。
<a name="EFNwT"></a>
### 题目描述
给定一个已按照**升序排列** 的有序数组，找到两个数使得它们相加之和等于目标数。<br />函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2_。_<br />**说明:**

- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例:**
```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```
<a name="clkD7"></a>
### 题目解析
初始化左指针 left 指向数组起始，初始化右指针 right 指向数组结尾。<br />根据**已排序**这个特性，

- （1）如果 numbers[left] 与 numbers[right] 的和 tmp 小于 target ，说明应该增加 tmp ，因此 left 右移指向一个较大的值。
- （2）如果 tmp大于 target ，说明应该减小 tmp ，因此 right 左移指向一个较小的值。
- （3）tmp 等于 target ，则找到，返回 left + 1 和 right + 1。（注意以 1 为起始下标）
<a name="FvwG6"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=M4qCU&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="hoCFM"></a>
### 代码实现
<a name="ltYHB"></a>
#### C++
```
// 对撞指针
// 时间复杂度: O(n)
// 空间复杂度: O(1)
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int n = numbers.size();
        int left = 0;
        int right = n-1;
        while(left <= right)
        {
            if(numbers[left] + numbers[right] == target)
            {
                return {left + 1, right + 1};
            }
            else if (numbers[left] + numbers[right] > target)
            {
                right--;
            }
            else
            {
                left++;
            }
        }
        return {-1, -1};
    }
};
```
<a name="VOy2A"></a>
#### Java
```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int n = numbers.length;
        int left = 0;
        int right = n-1;
        while(left <= right)
        {
            if(numbers[left] + numbers[right] == target)
            {
                return new int[]{left + 1, right + 1};
            }
            else if (numbers[left] + numbers[right] > target)
            {
                right--;
            }
            else
            {
                left++;
            }
        }
        
        return new int[]{-1, -1};
    }
}
```
<a name="a0nFG"></a>
#### Python
```python
class Solution(object):
    def twoSum(self, numbers, target):
        n = len(numbers)
        left,right = 0, n-1
        while left <= right:
            if numbers[left]+numbers[right] == target:
                return [left+1, right+1]
            elif numbers[left]+numbers[right] > target:
                right -=1
            else:
                left +=1

        return [-1, -1]
```
<a name="dVctx"></a>
# #169 号 求众数
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />今天分享的题目来源于 LeetCode 上第 169 号问题：求众数（求数组中超过一半的数字）。题目难度为 Easy，目前通过率为 45.8% 。<br />最后一种解法 **Cool** ！！！
<a name="KnKBY"></a>
## 题目描述
给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。<br />你可以假设数组是非空的，并且给定的数组总是存在众数。<br />**示例 1:**
```
输入: [3,2,3]
输出: 3
```
**示例 2:**
```
输入: [2,2,1,1,1,2,2]
输出: 2
```
<a name="F9vup"></a>
## 题目解析
题目意思很好理解：给你一个数组，里面有一个数字出现的次数超过了一半，你要找到这个数字并返回。
<a name="nkJuK"></a>
### 解法一：暴力解法
遍历整个数组，同时统计每个数字出现的次数。<br />最后将出现次数大于一半的元素返回即可。
<a name="VAyx8"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=usmOY&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="LPdar"></a>
### **代码实现**
```java
class Solution {
    public int majorityElement(int[] nums) {
        int majorityCount = nums.length/2;

        for (int num : nums) {
            int count = 0;
            for (int elem : nums) {
                if (elem == num) {
                    count += 1;
                }
            }
            if (count > majorityCount) {
                return num;
            }

        }  
    }
}
```
<a name="fb12b"></a>
### 复杂度分析
**时间复杂度**：O(n2)<br />暴力解法包含两重嵌套的 for 循环，每一层 n 次迭代，因此时间复杂度为 O(n2) 。<br />**空间复杂度**：O(1)<br />暴力解法没有分配任何与输入规模成比例的额外的空间，因此空间复杂度为 O(1)。
<a name="veUnj"></a>
## 解法二：哈希表法
这个问题可以视为查找问题，对于查找问题往往可以使用时间复杂度为 O(1) 的 **哈希表**，通过以空间换时间的方式进行优化。<br />直接遍历整个 **数组** ，将每一个数字（num）与它出现的次数（count）存放在 **哈希表** 中，同时判断该数字出现次数是否是最大的，动态更新 maxCount，最后输出 maxNum。
<a name="fDk9o"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391588346-3336cd2d-55d8-4022-a957-28b863b4e816.gif#averageHue=%23ffffff&from=url&id=GI1Sx&originHeight=540&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="wKKxh"></a>
### 代码实现
```java
class Solution {
    public int majorityElement(int[] nums) {
    Map<Integer, Integer> map = new HashMap<>();
    // maxNum 表示元素，maxCount 表示元素出现的次数
    int maxNum = 0, maxCount = 0;
    for (int num: nums) {
      int count = map.getOrDefault(num, 0) + 1;
      map.put(num, count);
      if (count > maxCount) {
        maxCount = count;
        maxNum = num;
      }
    }
    return maxNum;
  }
}
```
<a name="zTN5Z"></a>
### 复杂度分析
**时间复杂度**：O(n)<br />总共有一个循环，里面哈希表的插入是常数时间的，因此时间复杂度为 O(n)。<br />**空间复杂度**：O(n)<br />哈希表占用了额外的空间 O(n)，因此空间复杂度为 O(n)。
<a name="BNLCu"></a>
## 解法三：摩尔投票法
再来回顾一下题目：寻找数组中超过一半的数字，这意味着数组中**其他数字出现次数的总和都是比不上这个数字出现的次数** 。<br />即如果把 该众数记为 +1 ，把其他数记为 −1 ，将它们全部加起来，和是大于 0 的。<br />所以可以这样操作：

- 设置两个变量 candidate 和 count，**candidate** 用来保存数组中遍历到的某个数字，**count** 表示当前数字的出现次数，一开始 **candidate** 保存为数组中的第一个数字，**count** 为 1
- 遍历整个数组
- 如果数字与之前 **candidate** 保存的数字相同，则 **count** 加 1
- 如果数字与之前 **candidate** 保存的数字不同，则 **count** 减 1
- 如果出现次数 **count** 变为 0 ，**candidate** 进行变化，保存为当前遍历的那个数字，并且同时把 **count** 重置为 1
- 遍历完数组中的所有数字即可得到结果
<a name="kVOY4"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391651448-3efd10b0-c4af-4eed-a891-f8f5e4d58be0.gif#averageHue=%23fcfcfc&from=url&id=TORv1&originHeight=552&originWidth=887&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="WOeSe"></a>
### 代码实现
```java
class Solution {
    public int majorityElement(int[] nums) {
    int candidate = nums[0], count = 1;
    for (int i = 1; i < nums.length; ++i) {
      if (count == 0) {
        candidate = nums[i];
        count = 1;
      } else if (nums[i] == candidate) {
        count++;
      } else{
        count--;
      }
    }
    return candidate;
  }
}
```
<a name="tVbyH"></a>
### 复杂度分析
**时间复杂度**：O(n)<br />总共只有一个循环，因此时间复杂度为 O(n)。<br />**空间复杂度**：O(1)<br />只需要常数级别的额外空间，因此空间复杂度为 O(1)。
<a name="Emxo6"></a>
# #172 阶乘后的零
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 172 号问题：阶乘后的零。题目难度为 Easy，目前通过率为 38.0% 。
<a name="fTwE0"></a>
### 题目描述
给定一个整数 _n_，返回 _n_! 结果尾数中零的数量。<br />**示例 1:**
```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```
**示例 2:**
```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```
**说明:** 你算法的时间复杂度应为 _O_(log _n_) 。
<a name="FAk6z"></a>
### 题目解析
题目很好理解，数阶乘后的数字末尾有多少个零。<br />最简单粗暴的方法就是先乘完再说，然后一个一个数。<br />事实上，你在使用暴力破解法的过程中就能发现规律： **这 9 个数字中只有 2（它的倍数） 与 5 （它的倍数）相乘才有 0 出现**。<br />所以，现在问题就变成了这个阶乘数中能配 **多少对 2 与 5**。<br />举个复杂点的例子：<br />10！ = 【 2 *（ 2 * 2 ）* 5 *（ 2 * 3 ）*（ 2 * 2 * 2 ）*（ 2 * 5）】<br />在 10！这个阶乘数中可以匹配两对 2 * 5 ，所以10！末尾有 2 个 0。<br />可以发现，一个数字进行拆分后 2 的个数肯定是大于 5 的个数的，所以能匹配多少对取决于 5 的个数。（好比现在男女比例悬殊，最多能有多少对异性情侣取决于女生的多少）。<br />那么问题又变成了 **统计阶乘数里有多少个 5 这个因子**。<br />需要注意的是，像 25，125 这样的不只含有一个 5 的数字的情况需要考虑进去。<br />比如 n = 15。那么在 15! 中 有 3 个 5 (来自其中的5, 10, 15)， 所以计算 n/5 就可以 。<br />但是比如 n=25，依旧计算 n/5 ，可以得到 5 个5，分别来自其中的5, 10, 15, 20, 25，但是在 25 中其实是包含 2个 5 的，这一点需要注意。<br />所以除了计算 n/5 ， 还要计算 n/5/5 , n/5/5/5 , n/5/5/5/5 , ..., n/5/5/5,,,/5直到商为0，然后求和即可。
<a name="RKNbt"></a>
### 代码实现
```java
public class Solution {
    public int trailingZeroes(int n) {
        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);
    }
}
```
<a name="p05Ar"></a>
# #189 旋转数组
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 189 号问题：旋转数组。题目难度为 Easy，目前通过率为 41.7% 。
<a name="m8rD5"></a>
### 题目描述
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br />**示例 1:**
```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```
**示例 2:**
```
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```
**说明:**

- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 要求使用空间复杂度为 O(1) 的 原地 算法。

 

<a name="n9XAV"></a>
### 题目解析
如果没有空间复杂度为 O(1) 这个限制，这道题相对来说会简单很多，需要做的仅仅复制一份数组，然后将 [n - k, n] 区间上的元素覆盖在数组的开头，接着遍历并覆盖剩下的元素即可。<br />不能使用额外的空间意味着你只能从数组本身来入手，这里我们可以使用反转数组来解决这道题，这是一个 rotate 数组的小技巧。如果仔细观察，你会发现 **数组经过 rotate 后会变成两个连续的区间段**，这两个区间段中的元素顺序和 rotate 之前的顺序是一样的。首先我们对数组当中所有的元素进行反转，然后分别对这两个区间进行反转，这样就可以保证区间内的顺序和之前一样，你可以看看动图或者自己动手尝试一下，这里并没有复杂的知识点，只是数组操作上的小技巧，了解了之后，可以运用到其他 rotate 数组的场景中。<br /> 

<a name="KqKfd"></a>
### 代码实现
```java
class Solution {
    public void rotate(int[] nums, int k) {
        if (nums.length < k) {
            k %= nums.length;
        }

        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }

    public void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int tmp = nums[start];
            nums[start] = nums[end];
            nums[end] = tmp;
        }
    }
}
```
 

<a name="F2vZG"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391654037-bdd209ec-8c5b-40d0-96a5-ecb50b7d302d.gif#averageHue=%23fefefe&from=url&id=KaP5k&originHeight=608&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br /> 

<a name="EbHrh"></a>
### 复杂度分析
空间：O(1)<br />时间：O(n)
<a name="HPI4q"></a>
# #200 岛屿数量
<a name="w4FW9"></a>
## 题目描述
给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。<br />**示例 1:**
```
输入:
11110
11010
11000
00000

输出: 1
```
**示例 2:**
```
输入:
11000
11000
00100
00011

输出: 3
```
<a name="sM7Ae"></a>
## 题目解析
这道题的主要思路是深度优先搜索。每次走到一个是 1 的格子，就搜索整个岛屿。<br />网格可以看成是一个无向图的结构，每个格子和它上下左右的四个格子相邻。如果四个相邻的格子坐标合法，且是陆地，就可以继续搜索。<br />在深度优先搜索的时候要注意避免重复遍历。我们可以把已经遍历过的陆地改成 2，这样遇到 2 我们就知道已经遍历过这个格子了，不进行重复遍历。<br />每遇到一个陆地格子就进行深度优先搜索，最终搜索了几次就知道有几个岛屿。
<a name="Jvsdn"></a>
## 动画理解
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=bBCiz&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="kkxgc"></a>
## 参考代码
```
class Solution {
    public int numIslands(char[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        
        int count = 0;
        for (int r = 0; r < grid.length; r++) {
            for (int c = 0; c < grid[0].length; c++) {
                if (grid[r][c] == '1') {
                    dfs(grid, r, c);
                    count++;
                }
            }
        }
        return count;
    }
    
    void dfs(char[][] grid, int r, int c) {
        if (!(0 <= r && r < grid.length && 0 <= c && c < grid[0].length)) {
            return;
        }
        if (grid[r][c] != '1') {
            return;
        }
        grid[r][c] = '2';
        dfs(grid, r - 1, c);
        dfs(grid, r + 1, c);
        dfs(grid, r, c - 1);
        dfs(grid, r, c + 1);
    }
}
```
<a name="CUQV7"></a>
## 复杂度分析
设网格的边长为 <br />$n$，则时间复杂度为 $O(n%5E2)$。


<a name="lXzmD"></a>
# #2201 数字范围按位与
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 201 号问题：数字范围按位与。题目难度为 Medium，目前通过率为 39.1% 。
<a name="zw9cU"></a>
### 题目描述
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。<br />**示例 1:**
```
输入: [5,7]
输出: 4
```
**示例 2:**
```
输入: [0,1]
输出: 0
```
<a name="KrBZo"></a>
### 题目解析
以 [ 26 ，30] 为例。<br />首先，将 [ 26 , 30 ] 的范围数字用二进制表示出来：<br />**11**010 **11**011 **11**100 **11**101 **11**110<br />而输出 24 的二进制是 11000 。<br />可以发现，只要找到二进制的 **左边公共部分** 即可。<br />所以，可以先建立一个 32 位都是 1 的 mask，然后每次向左移一位，比较 m 和 n 是否相同，不同再继续左移一位，直至相同，然后把 m 和 mask 相与就是最终结果。
<a name="cANQZ"></a>
### 动画描述
暂无
<a name="bchru"></a>
### 代码实现
```
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        unsigned int d = INT_MAX;
        while ((m & d) != (n & d)) {
            d <<= 1;
        }
        return m & d;
    }
};
```
<a name="opNdH"></a>
# #202 移除链表元素
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 203 号问题：移除链表元素。题目难度为 Easy，目前通过率为 55.8% 。
<a name="sIc2D"></a>
### 题目描述
删除链表中等于给定值 **val** 的所有节点。<br />**示例:**
```
输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
```
<a name="Bb2NR"></a>
### 题目解析
主要考察了基本的链表遍历和设置指针的知识点。<br />定义一个虚拟头节点dummyHead，遍历查看原链表，遇到与给定值相同的元素，将该元素的前后两个节点连接起来，然后删除该元素即可。
<a name="kRkGQ"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=gEbZF&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="rvuXr"></a>
### 代码实现
<a name="xOMMe"></a>
#### 代码一
```
// 203. Remove Linked List Elements
// https://leetcode.com/problems/remove-linked-list-elements/description/
// 使用虚拟头结点
// 时间复杂度: O(n)
// 空间复杂度: O(1)
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {

        // 创建虚拟头结点
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;

        ListNode* cur = dummyHead;
        while(cur->next != NULL){
            if(cur->next->val == val){
                ListNode* delNode = cur->next;
                cur->next = delNode->next;
                delete delNode;
            }
            else
                cur = cur->next;
        }

        ListNode* retNode = dummyHead->next;
        delete dummyHead;

        return retNode;
    }
};
```
<a name="Axjn9"></a>
#### 代码二
用递归来解。<br />通过递归调用到链表末尾，然后回来，需要删的元素，将链表next指针指向下一个元素即可。
```
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if (!head) return NULL;
        head->next = removeElements(head->next, val);
        return head->val == val ? head->next : head;
    }
};
```
<a name="SZ1jM"></a>
# #206 反转链表
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 206 号问题：反转链表。题目难度为 Easy，目前通过率为 45.8% 。
<a name="N3FPD"></a>
### 题目描述
反转一个单链表。<br />**示例:**
```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```
**进阶:**<br />你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
<a name="j0Id5"></a>
### 题目解析
设置三个节点pre、cur、next

- （1）每次查看cur节点是否为NULL，如果是，则结束循环，获得结果
- （2）如果cur节点不是为NULL，则先设置临时变量next为cur的下一个节点
- （3）让cur的下一个节点变成指向pre，而后pre移动cur，cur移动到next
- （4）重复（1）（2）（3）
<a name="fN065"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=P98VH&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="CxKc5"></a>
### 代码实现
```
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = NULL;
        ListNode* cur = head;
        while(cur != NULL){
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }

        return pre;
    }
};
```
<a name="uK2B8"></a>
# #209 长度最小的子数组
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 209 号问题：长度最小的子数组。题目难度为 Medium，目前通过率为 25.8% 。
<a name="cLyfM"></a>
### 题目描述
给定一个含有 **n** 个正整数的数组和一个正整数 **s ，**找出该数组中满足其和 **≥ s** 的长度最小的连续子数组**。**如果不存在符合条件的连续子数组，返回 0。<br />**示例:**
```
输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。
```
**进阶:**<br />如果你已经完成了_O_(_n_) 时间复杂度的解法, 请尝试 _O_(_n_ log _n_) 时间复杂度的解法。
<a name="lCWIr"></a>
### 题目解析
定义两个指针 left 和 right ，分别记录子数组的左右的边界位置。

- （1）让 right 向右移，直到子数组和大于等于给定值或者 right 达到数组末尾；
- （2）更新最短距离，将 left 像右移一位,sum 减去移去的值；
- （3）重复（1）（2）步骤，直到 right 到达末尾，且 left 到达临界位置
<a name="am8P2"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=AA0Zy&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />设置滑动窗口的长度为 0 ，位于数轴的最左端。
<a name="DNLu0"></a>
##### 1 .滑动窗口右端 R 开始移动，直到区间满足给定的条件，也就是和大于 7 ，此时停止于第三个元素 2，当前的最优长度为 4

<a name="LRyeo"></a>
##### 2. 滑动窗口左端 L 开始移动，缩小滑动窗口的大小，停止于第一个元素 3，此时区间和为 6，使得区间和不满足给定的条件（此时不大于 7）

<a name="L6Ujc"></a>
#### 3. 滑动窗口右端 R 继续移动，停止于第四个元素 4，此时和位 10 ，但最优长度仍然为 4

<a name="NDsoG"></a>
### 代码实现
```
// 滑动窗口的思路
// 时间复杂度: O(n)
// 空间复杂度: O(1)
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        int l= 0,r = -1;    // nums[l...r]为我们的滑动窗口
        int sum = 0;
        int result = nums.length + 1;
        while (l < nums.length){ // 窗口的左边界在数组范围内,则循环继续

            if( r+1 <nums.length && sum < s){
                r++;
                sum += nums[r];
            }else { // r已经到头 或者 sum >= s
                sum -= nums[l];
                l++;
            }

            if(sum >= s){
                result = (r-l+1) < result ? (r-l+1) : result ;
            }
        }
        if(result==nums.length+1){
            return 0;
        }
        return result;
    }
}
```
<a name="qINdz"></a>
# #219 存在重复元素 II
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 219 号问题：存在重复元素 II。题目难度为 Easy，目前通过率为 34.8% 。
<a name="TA6yr"></a>
### 题目描述
给定一个整数数组和一个整数 _k_，判断数组中是否存在两个不同的索引 _i_ 和 _j_，使得 **nums [i] = nums [j]**，并且 _i_ 和 _j_ 的差的绝对值最大为 _k_。<br />**示例 1:**
```
输入: nums = [1,2,3,1], k = 3
输出: true
```
**示例 2:**
```
输入: nums = [1,0,1,1], k = 1
输出: true
```
**示例 3:**
```
输入: nums = [1,2,3,1,2,3], k = 2
输出: false
```
<a name="gZXg4"></a>
### 题目解析
考虑用滑动窗口与查找表来解决。

- 设置查找表record，用来保存每次遍历时插入的元素，record的最大长度为k
- 遍历数组nums，每次遍历的时候在record查找是否存在相同的元素，如果存在则返回true，遍历结束
- 如果此次遍历在record未查找到，则将该元素插入到record中，而后查看record的长度是否为k + 1
- 如果此时record的长度是否为k + 1，则删减record的元素，该元素的值为nums[i - k]
- 如果遍历完整个数组nums未查找到则返回false
<a name="eQFzn"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=qSXKc&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="b6Y5i"></a>
### 代码实现
```
// 219. Contains Duplicate II
// https://leetcode.com/problems/contains-duplicate-ii/description/
// 时间复杂度: O(n)
// 空间复杂度: O(k)
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {

        if(nums.size() <= 1)  return false;

        if(k <= 0)  return false;
        

        unordered_set<int> record;
        for(int i = 0 ; i < nums.size() ; i ++){

            if(record.find(nums[i]) != record.end()){
                return true;
            }

            record.insert(nums[i]);

            // 保持record中最多有k个元素
            // 因为在下一次循环中会添加一个新元素,使得总共考虑k+1个元素
            if(record.size() == k + 1){
                record.erase(nums[i - k]);
            }
        }

        return false;
    }
};
```
<a name="VvKAn"></a>
# #231 的幂
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 231 号问题：2 的幂。题目难度为 Easy，目前通过率为 45.6% 。
<a name="hIEK2"></a>
### 题目描述
给定一个整数，编写一个函数来判断它是否是 2 的幂次方。<br />**示例 1:**
```
输入: 1
输出: true
解释: 2^0 = 1
```
**示例 2:**
```
输入: 16
输出: true
解释: 2^4 = 16
```
**示例 3:**
```
输入: 218
输出: false
```
<a name="T6sXS"></a>
### 题目解析
首先，先来分析一下 2 的次方数的二进制写法：<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1693722632435-d164d7b4-6a13-49b2-94a9-7e85ed931dcb.jpeg#averageHue=%23f9f9f9&clientId=u56574840-1b68-4&from=url&id=oAUrM&originHeight=190&originWidth=1630&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9ba16bd8-5056-470c-8826-0f95078e390&title=)<br />仔细观察，可以看出 2 的次方数都只有一个 1 ，剩下的都是 0 。根据这个特点，只需要每次判断最低位是否为 1 ，然后向右移位，最后统计 1 的个数即可判断是否是 2 的次方数。<br />代码很简单：
```
class Solution {
public:
    bool isPowerOfTwo(int n) {
        int cnt = 0;
        while (n > 0) {
            cnt += (n & 1);
            n >>= 1;
        }
        return cnt == 1;
    } 
};
```
该题还有一种巧妙的解法。再观察上面的表格，如果一个数是 2 的次方数的话，那么它的二进数必然是最高位为1，其它都为 0 ，那么如果此时我们减 1 的话，则最高位会降一位，其余为 0 的位现在都为变为 1，那么我们把两数相与，就会得到 0。<br />比如 2 的 3 次方为 8，二进制位 1000 ，那么 8 - 1 = 7，其中 7 的二进制位 0111。
<a name="eWHZE"></a>
### 图片描述
![](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1693722632340-3ac7271f-c9a7-428b-92ce-d2c9e9d16316.jpeg#averageHue=%23f5fbf8&clientId=u56574840-1b68-4&from=url&id=DGlMk&originHeight=466&originWidth=356&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf702cc74-129c-45e0-bdaf-13bbdcfe7b8&title=)
<a name="nV6HL"></a>
### 代码实现
利用这个性质，只需一行代码就可以搞定。
```
class Solution {
public:
    bool isPowerOfTwo(int n) {
        return (n > 0) && (!(n & (n - 1)));
    } 
};
```
<a name="WvV5Q"></a>
## LeetCode第234号问题：回文链表
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />个人博客：www.zhangxiaoshuai.fun<br />**本题选择leetcode第234题，easy难度，目前通过率41.5%**
```
题目描述：
请判断一个链表是否为回文链表。
示例 1:
    输入: 1->2
    输出: false

示例 2:
    输入: 1->2->2->1
    输出: true
```
**_这道题还有进阶版本，我们先实现这个普通版本再看。_**
<a name="P2pEY"></a>
### 题目分析
```
首先，我们先遍历一遍链表，将链表中的每个值存入数组当中，然后我们判断数组中的元素是否满足回文数条件即可。
这里因为我们不知道链表的长度，我们先使用动态数组将值存起来，然后再存到固定大小的数组中。
```
<a name="B4Pyr"></a>
### 解法一gif动画演示：
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391664163-556f73f3-0348-4974-a31d-d9e22988ab8c.gif#averageHue=%23fefefe&from=url&id=OO3CM&originHeight=480&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="IjsgG"></a>
### 代码：
```java
public boolean isPalindrome(ListNode head) {
    List<Integer> list = new ArrayList<>();
    while (head != null) {
        list.add(head.val);
        head = head.next;
    }
    int[] arr = new int[list.toArray().length];
    int temp = 0;
    for (int a : list) {
        arr[temp++] = a;
    }
    temp = 0;
    for (int i = 0;i < arr.length/2;i++) {
        if (arr[i] == arr[arr.length-i-1]) {
            temp++;
        }
    }
    if(temp == arr.length/2) return true;
    return false;
}
```
**时间复杂度：O(n) 空间复杂度：O(n)**
<a name="Nq5HE"></a>
### 进阶：
**你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？**<br />**思路分析：**我们先找到链表的中间结点，然后将中间结点后面的链表进行反转，反转之后再和前半部分链表进行比较，如果相同则表示该链表属于回文链表，返回true；否则，否则返回false
<a name="l0qMI"></a>
### 解法二gif动画演示：
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391664591-d3624222-49fc-43db-8aa7-67d508306c4a.gif#averageHue=%23fefcfb&from=url&id=XMSBQ&originHeight=480&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="C83zo"></a>
### 代码：
```java
public boolean isPalindrome(ListNode head) {
   if(head == null  || head.next == null)   return true;
   ListNode p = new ListNode(-1);
   ListNode low = p;
   ListNode fast = p;
   p.next = head;
   //使用快慢指针来确定中间结点
   while(fast != null && fast.next != null){
       low = low.next;
       fast = fast.next.next;
   }
   ListNode cur = low.next;
   ListNode pre = null;
   low.next = null;
   low = p.next;

   //反转后半部分链表
   while(cur != null){
       ListNode tmp = cur.next;
       cur.next = pre;
       pre = cur;
       cur = tmp;
   }
   //将前半部分链表和后半部分进行比较
   while(pre != null){
       if(low.val != pre.val){
           return false;
       }
       low = low.next;
       pre = pre.next;
   }
   return true;
}
```
**时间复杂度：O(n) 空间复杂度：O(1)**<br />**没错，可以看到上面的代码是完全能可以通过的，虽然我们完成了题目，但是我们改变了链表的结构，也就是说它现在不是它了；出题人应该是不希望我们破坏链表的，所以在我们完成判断之后，需要将链表恢复原样，也就是将后半部分链表反转之后接到前半部分链表的末尾。**

<a name="orPkx"></a>
# **#237 删除链表中的节点**
**本文首发于公众号「图解面试算法」，是 **[**图解 LeetCode**](https://github.com/MisterBooo/LeetCodeAnimation)** 系列文章之一。**<br />**同步博客：**[**https://www.algomooc.com**](https://www.algomooc.com)<br />**题目来源于 LeetCode 上第 237 号问题：删除链表中的节点。题目难度为 Easy，目前通过率为 72.6% 。**
<a name="BVboL"></a>
### **题目描述**
**请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。**<br />**现有一个链表 -- head = [4,5,1,9]，它可以表示为:**<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693722649965-9ca0ec83-145f-4d54-a32d-948ddc5fd5d0.png#averageHue=%23f6f6f6&clientId=u56574840-1b68-4&from=url&id=he4FC&originHeight=65&originWidth=395&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u686d7597-7777-4ad7-8170-2752540fc15&title=)<br />**示例 1:**
```
输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```
**示例 2:**
```
输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```
**说明:**

- **链表至少包含两个节点。**
- **链表中所有节点的值都是唯一的。**
- **给定的节点为非末尾节点并且一定是链表中的一个有效节点。**
- **不要从你的函数中返回任何结果。**
<a name="UAjSO"></a>
### **题目解析**
**此题注意的点是没有给我们链表的起点，只给我们了一个要删的节点，与以往处理的情况稍许不同。**<br />**这道题的处理方法是先把当前节点的值用下一个节点的值覆盖，然后我们删除下一个节点即可**
<a name="uNQRn"></a>
### **动画描述**
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=n2jH0&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="fisXL"></a>
### **代码实现**
```
class Solution {
public:
    void deleteNode(ListNode* node) {
        if (node == NULL) return;
        if (node->next == NULL) {
            delete node;
            node = NULL;
            return;
        }
        node->val = node->next->val;
        ListNode *delNode = node->next;
        node->next = delNode->next;
        
        delete delNode;
    }
};
```
<a name="YArxO"></a>
# #239 滑动窗口最大值
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 239 号问题：滑动窗口最大值。题目难度为 Hard，目前通过率为 40.5% 。
<a name="YMp9y"></a>
### 题目描述
给定一个数组 _nums_，有一个大小为 _k_ 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 _k_ 内的数字。滑动窗口每次只向右移动一位。<br />返回滑动窗口最大值。<br />**示例:**
```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```
**注意：**<br />你可以假设 _k_ 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。<br />**进阶：**<br />你能在线性时间复杂度内解决此题吗？
<a name="wITdi"></a>
### 题目解析
利用一个 **双端队列**，在队列中存储元素在数组中的位置， 并且维持队列的严格递减,，也就说维持队首元素是 **最大的 **，当遍历到一个新元素时, 如果队列里有比当前元素小的，就将其移除队列，以保证队列的递减。当队列元素位置之差大于 k，就将队首元素移除。
<a name="naHGd"></a>
### 补充：什么是双端队列（Dqueue）
Deque 的含义是 “double ended queue”，即双端队列，它具有队列和栈的性质的数据结构。顾名思义，它是一种前端与后端都支持插入和删除操作的队列。<br />Deque 继承自 Queue（队列），它的直接实现有 ArrayDeque、LinkedList 等。
<a name="BVrHu"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=mbdwd&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="mw63C"></a>
### 代码实现
```
class Solution {
   public int[] maxSlidingWindow(int[] nums, int k) {
        //有点坑，题目里都说了数组不为空，且 k > 0。但是看了一下，测试用例里面还是有nums = [], k = 0，所以只好加上这个判断
        if (nums == null || nums.length < k || k == 0) return new int[0];
        int[] res = new int[nums.length - k + 1];
        //双端队列
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < nums.length; i++) {
            //在尾部添加元素，并保证左边元素都比尾部大
            while (!deque.isEmpty() && nums[deque.getLast()] < nums[i]) {
                deque.removeLast();
            }
            deque.addLast(i);
            //在头部移除元素
            if (deque.getFirst() == i - k) {
                deque.removeFirst();
            }
            //输出结果
            if (i >= k - 1) {
                res[i - k + 1] = nums[deque.getFirst()];
            }
        }
        return res;
     }
}
```
<a name="xQsdV"></a>
# #242 有效的字母异位词
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 242 号问题：有效的字母异位词。题目难度为 Easy，目前通过率为 60.5% 。
<a name="Y3GzN"></a>
### 题目描述
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br />**示例 1:**
```
输入: s = "anagram", t = "nagaram"
输出: true
```
**示例 2:**
```
输入: s = "rat", t = "car"
输出: false
```
**说明：**<br />你可以假设字符串只包含小写字母。<br />**进阶：**<br />如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
<a name="lNeNf"></a>
### 题目解析
字母异位词的意思是，如果两个字符串互为字母异位词，那么两个字符串里的字符数量和种类都一样，不一样的是每个字符出现的位置，以及先后顺序。最简单的方法是直接将字符串按一定的规则排序，然后遍历对比即可。这种方法省空间，但是因为涉及到排序，时间复杂度就是 O(nlgn)。<br />还有一个类似计数排序的方法，就是统计一个字符串里面所有字符对应的个数，然后再拿另外一个字符串做对比，这么做可以把时间复杂度降到 O(n)，如果这道题目中的字符串仅仅包含小写字母的话，我们可以开辟一个长度是 26 的数组，这样就不需要额外的空间，但如果说输入的字符串包含 unicode 字符，由于 unicode 字符集过于庞大，常量级别的数组变得不那么可取，我们可以考虑使用散列表这样的结构进行存储，逻辑是和之前一样的，但是这里的空间复杂度就不再是 O(1)，而是 O(n)<br /> 

<a name="DhNMA"></a>
### 代码实现（排序）
```java
public boolean isAnagram(String s, String t) {
    if ((s == null) || (t == null) || (t.length() != s.length())) {
        return false;
    }
    char[] sArr1 = s.toCharArray();
    char[] sArr2 = t.toCharArray();
    Arrays.sort(sArr1);
    Arrays.sort(sArr2);
    return Arrays.equals(sArr1, sArr2);
}
```
<a name="nuT3S"></a>
### 代码实现（哈希）
```java
public boolean isAnagram(String s, String t) {
    if ((s == null) || (t == null) || (t.length() != s.length())) {
        return false;
    }
    
    int n = s.length();

    Map<Character, Integer> counts = new HashMap<>();

    for (int i = 0; i < n; ++i) {
        counts.put(s.charAt(i), counts.getOrDefault(s.charAt(i), 0) + 1);
    }

    for (int i = 0; i < n; ++i) {
        counts.put(t.charAt(i), counts.getOrDefault(t.charAt(i), 0) - 1);
        if (counts.getOrDefault(t.charAt(i), -1) < 0) {
            return false;
        }
    }

    return true;
}
```
<a name="UZXIw"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391668588-ba42a2e1-3b87-4139-b557-c3451d3c673a.gif#averageHue=%23fefefe&from=url&id=AUNHB&originHeight=608&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="Bk2tl"></a>
# #260 只出现一次的数字 III
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 260 号问题：只出现一次的数字 III。题目难度为 Medium，目前通过率为 72.1% 。
<a name="V8aRu"></a>
## 题目描述
给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。<br />**示例：**
```
输入: [1,2,1,3,2,5]
输出: [3,5]
```
**注意：**

1. 结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。
2. 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

 

<a name="s67vQ"></a>
## 题目解析
第三道题目，和第一道题目只变化了一点，就是输入数组中除了 **两** 个元素出现了一次，其余的都出现了两次。我们依然可以从第一道题目的解法去思考这道题，如果我们还是按照第一题的做法，最后我们得到的答案将会是 ele1 ^ ele2 的结果，我们需要思考如何从这个结果出发，得到 ele1 和 ele2。首先思考一个问题 ele1 ^ ele2 的结果具体是什么，或者说里面有什么样的信息，异或操作是将相同的 bit 位置 0，相异的置 1，也就是说 **ele1 和 ele2 异或的结果中为 1 的 bit 位是两个元素相异的 bit 位，再进一步讲，我们可以用这个 bit 位来区分两个元素**。于是在第一题的基础之上，用一个 bit 位作为判断条件，来决定当前遍历到的元素和那个值进行异或，因为这时我们要求的值有两个。<br />从上面这些题目中你可以看到位运算的强大，三道系列题目的时间复杂度均为 O(n)，但是位运算是更加底层的运算，实际时间消耗会比正常操作要更快一些。在理解位运算的时候，**试着把 bit 作为最小单位去思考，或许会有不一样的发现**。<br /> 

<a name="CzzKT"></a>
### 代码实现
```java
public int[] singleNumber(int[] nums) {
    if (nums == null || nums.length == 0) {
        return new int[2];
    }
    
    int different = 0;
    for (int i : nums) {
        different ^= i;
    }

    // 这个操作是取 different 从左往右最后一个为 1 的 bit 位
    different &= -different;
    int[] ans = {0, 0};
    for (int i : nums) {
        if ((different & i) == 0) {
            ans[0] ^= i;
        } else {
            ans[1] ^= i;
        }
    }
    
    return ans;
}
```
 

<a name="zzOSi"></a>
### 动画演示
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391670028-df452c77-7fb4-4471-afea-6bf2ebb3374b.gif#averageHue=%23fefefe&from=url&id=uoxLb&originHeight=608&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="wDRyI"></a>
# #279 完全平方数
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 279 号问题：完全平方数。题目难度为 Medium，目前通过率为 49.1% 。
<a name="CJQqm"></a>
### 题目描述
给定正整数 _n_，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 _n_。你需要让组成和的完全平方数的个数最少。<br />**示例 1:**
```
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
```
**示例 2:**
```
输入: n = 13
输出: 2
解释: 13 = 4 + 9.
```
<a name="zaqG9"></a>
### 题目解析
这道题目很有意思。<br />大部分文章给出的答案都是依托于一个定理：**四平方定理**。<br />四平方定理讲的就是任何一个正整数都可以表示成不超过四个整数的平方之和。也就是说，这道题的答案只有 1，2 ，3，4 这四种可能。<br />同时，还有一个非常重要的推论满足四数平方和定理的数n（这里要满足由四个数构成，小于四个不行），必定满足 n = 4a * (8b + 7)。<br />根据这个重要的推论来解决此题，首先将输入的n迅速缩小。然后再判断，这个缩小后的数是否可以通过两个平方数的和或一个平方数组成，不能的话我们返回3，能的话我们返回平方数的个数。<br />所以代码很简洁，如下：
```java
public int numSquares(int n) {
        while (n % 4 == 0){
            n /= 4;
        }
        if ( n % 8 == 7){
            return 4;
        }
        int a = 0;
        while ( (a * a) <= n){
            int b = (int)Math.pow((n - a * a),0.5);
             if(a * a + b * b == n) {
            //如果可以 在这里返回
            if(a != 0 && b != 0) {
                return 2;
            } else{
                return 1;
            }
        }
        a++;
     }
        return 3;
}
```
但因为本章是「广度优先遍历」的专栏，因此再补充一个图的广度优先遍历的答案：<br />使用广度优先搜索方法，将 n 依次减去比 n 小的所有平方数，直至 n = 0 ，此时的层数即为最后的结果。
<a name="kAn6m"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=xslRl&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="uWHgy"></a>
### 代码实现
```
import java.util.LinkedList;
import javafx.util.Pair;
class Solution {
    public int numSquares(int n) {
         if(n == 0)
            return 0;
            
        LinkedList<Pair<Integer, Integer>> queue = new LinkedList<Pair<Integer, Integer>>();
        queue.addLast(new Pair<Integer, Integer>(n, 0));

        boolean[] visited = new boolean[n+1];
        visited[n] = true;

        while(!queue.isEmpty()){
            Pair<Integer, Integer> front = queue.removeFirst();
            int num = front.getKey();
            int step = front.getValue();

            if(num == 0)
                return step;

            for(int i = 1 ; num - i*i >= 0 ; i ++){
                int a = num - i*i;
                if(!visited[a]){
                    if(a == 0) return step + 1;
                    queue.addLast(new Pair(num - i * i, step + 1));
                    visited[num - i * i] = true;
                }
            }
        }
        return 0;
    }
}
```
<a name="Wv7US"></a>
# #268 缺失数字
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />今天分享一道很简单的算法题。<br />题目来源于 LeetCode 上第 268 号问题：缺失数字。题目难度为 Easy，目前通过率为 50.2% 。
<a name="xrC7T"></a>
## 题目描述
给定一个包含 0, 1, 2, ..., n 中 _n_ 个数的序列，找出 0 .. _n_ 中没有出现在序列中的那个数。<br />**说明：**<br />你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693722722256-993a5d90-f9de-4e83-9196-9c45345effec.png#averageHue=%23fefefe&clientId=u56574840-1b68-4&from=url&id=ZZznT&originHeight=908&originWidth=1806&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8caba5b1-00a8-4ec2-94ed-f3823bdadab&title=)
<a name="uBfTi"></a>
## 题目解析
这道题目有三种解法。
<a name="zCty0"></a>
### 解法一：异或法
和之前那道 **只出现一次的数字** 很类似：<br />只出现一次的数字: 给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br />如果我们补充一个完整的数组和原数组进行组合，那所求解的问题就变成了 **只出现一次的数字**。<br />将少了一个数的数组与 0 到 n 之间完整的那个数组进行异或处理，因为相同的数字异或会变为了 0 ，那么全部数字异或后，剩下的就是少了的那个数字。<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693722722267-06c8d03f-6f0e-43dc-9228-2fd5345646b1.png#averageHue=%23fdfdfd&clientId=u56574840-1b68-4&from=url&id=zq2BB&originHeight=1094&originWidth=1938&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u877b43c9-32eb-4272-93d3-5addc397067&title=)
<a name="DVTOL"></a>
#### 代码实现1
```java
class Solution {
    public int missingNumber(int[] nums) {
        int res = 0;
        int i = 0;
        //注意数组越界情况
        for (; i < nums.length;i++){
            // i 表示完整数组中的数字，与原数组中的数字 nums[i] 进行异或，再与保存的结果异或
            res = res^i^nums[i];
        }
        //最后需要与循环中无法使用到的那个最大的数异或
        return res^i;
    }
}
```
<a name="i8vIP"></a>
#### 代码实现2
```java
class Solution {
   public int missingNumber(int[] nums) {
    int res = nums.length;
    for (int i = 0; i < nums.length; ++i){
        res ^= nums[i];
        res ^= i;
    }
    return res;
  }
}
```
<a name="W25NF"></a>
### 解法二：求和法

- 求出 0 到 n 之间所有的数字之和
- 遍历数组计算出原始数组中数字的累积和
- 两和相减，差值就是丢失的那个数字

![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=GfThQ&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
```java
//小吴之前担心会数据溢出，不过估计这题考察的不是这个，所以测试用例没写这种吧，还是能 AC 的
class Solution {
   public int missingNumber(int[] nums) {
        int n = nums.length;
        int sum = (n+0)*(n+1)/2;
        for (int i=0; i<n; i++){
            sum -= nums[i];
        }
        return sum;
 }
}
```
<a name="tulw5"></a>
### 解法三：二分法
将数组进行排序后，利用二分查找的方法来找到缺少的数字，注意搜索的范围为 0 到 n 。

- 首先对数组进行排序
- 用元素值和下标值之间做对比，如果元素值大于下标值，则说明缺失的数字在左边，此时将 right 赋为 mid ，反之则将 left 赋为 mid + 1 。

注：由于一开始进行了排序操作，因此使用二分法的性能是不如上面两种方法。
```java
public class Solution {
    public int missingNumber(int[] nums) {
        Arrays.sort(nums);
        int left = 0;
        int right = nums.length;
        while (left < right){
            int mid = (left + right) / 2;
            if (nums[mid] > mid){
                right = mid;
            }else{
                left = mid + 1;  
            }
        }
        return left;
    }
}
```
<a name="Uwt0f"></a>
# #283 移动零
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 283 号问题：移动零。题目难度为 Easy，目前通过率为 53.8% 。
<a name="BawCM"></a>
### 题目描述
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br />**示例:**
```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```
**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。
<a name="lxCXt"></a>
### 题目解析
设定一个临时变量 k = 0，遍历数组 nums ，将非零元素移动到 nums[k]位 置，同时 k++，而后将【k,….nums.size()】中的元素置零。
<a name="ca8U6"></a>
### 解法一
创建一个临时数组 nonZeroElements ，遍历 nums ，将 nums 中非 0 元素赋值到 nonZeroElements中，而后按顺序将 nonZeroElements 赋值到 nums 上，未遍历的元素置 0 ；<br />动画如下：<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722726735-8a1b8243-6606-4978-a632-02bce03c50f3.gif#averageHue=%23fefefe&clientId=u56574840-1b68-4&from=url&id=BzIYo&originHeight=203&originWidth=420&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u11babccd-e2e2-42a4-b518-e2fedf8a04a&title=)<br />代码如下：
```
// 时间复杂度: O(n)
// 空间复杂度: O(n)
class Solution {
public:
    void moveZeroes(vector<int>& nums) {

        vector<int> nonZeroElements;

        // 将vec中所有非0元素放入nonZeroElements中
        for(int i = 0 ; i < nums.size() ; i ++)
            if(nums[i])
                nonZeroElements.push_back(nums[i]);

        // 将nonZeroElements中的所有元素依次放入到nums开始的位置
        for(int i = 0 ; i < nonZeroElements.size() ; i ++)
            nums[i] = nonZeroElements[i];

        // 将nums剩余的位置放置为0
        for(int i = nonZeroElements.size() ; i < nums.size() ; i ++)
            nums[i] = 0;
    }
};
```
<a name="zaBsX"></a>
### 解法二
设定一个临时变量 k = 0，遍历数组 nums ，将非零元素移动到 nums[k] 位置，同时 k++，而后将【k,….nums.size()】中的元素置零。<br />动画如下：<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693722726725-95ed3a92-ddb9-4960-9df3-e3560ddfd01e.gif#averageHue=%23fefdfd&clientId=u56574840-1b68-4&from=url&id=SxiuM&originHeight=418&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3efb24d5-1f42-43dc-ae71-6f58dfd4ec6&title=)<br />代码如下：
```
// 原地(in place)解决该问题
// 时间复杂度: O(n)
// 空间复杂度: O(1)
class Solution {
public:
    void moveZeroes(vector<int>& nums) {

        int k = 0; // nums中, [0...k)的元素均为非0元素

        // 遍历到第i个元素后,保证[0...i]中所有非0元素
        // 都按照顺序排列在[0...k)中
        for(int i = 0 ; i < nums.size() ; i ++)
            if(nums[i])
                nums[k++] = nums[i];

        // 将nums剩余的位置放置为0
        for(int i = k ; i < nums.size() ; i ++)
            nums[i] = 0;
    }
};
```
<a name="z60vS"></a>
### 解法三
思路：设定一个临时变量 k = 0，遍历数组 nums，将非零元素与之前的零元素进行交换，维护变量k的值。<br />动画如下：<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=QcJzc&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />代码如下：
```
// 原地(in place)解决该问题
// 时间复杂度: O(n)
// 空间复杂度: O(1)
class Solution {
public:
    void moveZeroes(vector<int>& nums) {

        int k = 0; // nums中, [0...k)的元素均为非0元素

        // 遍历到第i个元素后,保证[0...i]中所有非0元素
        // 都按照顺序排列在[0...k)中
        // 同时, [k...i] 为 0
        for(int i = 0 ; i < nums.size() ; i ++)
            if(nums[i]){
                if(k != i){
                    swap(nums[k++] , nums[i]);
                }else{
                    k ++;
                }
            }
        }
};
```
<a name="qhpg3"></a>
# #295 数据流的中位数
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 295 号问题：数据流的中位数。难度级别为 Hard，目前通过率为 33.5% 。
<a name="KJNIV"></a>
### 题目描述
中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。<br />例如，<br />[2,3,4] 的中位数是 3<br />[2,3] 的中位数是 (2 + 3) / 2 = 2.5<br />设计一个支持以下两种操作的数据结构：

- void addNum(int num) - 从数据流中添加一个整数到数据结构中。
- double findMedian() - 返回目前所有元素的中位数。

**示例：**
```java
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2
```
<a name="USqi9"></a>
### 题目解析
这道题给我们一个数据流，让我们找出中位数。对于数据流这种动态（流动）的数据，如果使用数组存储，那么每次新进来一个数据都进行排序的话，效率很低。<br />处理动态数据来说一般使用的数据结构是栈、队列、二叉树、堆。<br />本题中，我们使用 **堆** 这种数据结构。<br />首先将数据分为两部分，位于 **上边最大堆** 的数据要比 **下边最小堆** 的数据都要小。<br />为了保证将数据平均分配到两个堆中，在动态的操作的过程中两个堆中数据的数目之差不能超过 1。<br />为了保证 **最大堆中的所有数据都小于最小堆中的数据**，在操作过程中，新添加进去的数据需要先和最大堆的最大值或者最小堆中的最小值进行比较。
<a name="IjYwj"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=g2ggf&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="wDnFz"></a>
### 代码实现
```java
class MedianFinder {
    public PriorityQueue<Integer> minheap, maxheap;
    public MedianFinder() {
        //维护较大的元素的最小堆
        maxheap = new PriorityQueue<Integer>(Collections.reverseOrder());
        //维护较小元素的最大堆
        minheap = new PriorityQueue<Integer>();
    }
    
    // Adds a number into the data structure.
    public void addNum(int num) {
        maxheap.add(num);
        minheap.add(maxheap.poll());
        if (maxheap.size() < minheap.size()) {
            maxheap.add(minheap.poll());
        }
    }

    // Returns the median of current data stream
    public double findMedian() {
        if (maxheap.size() == minheap.size()) {
            return (maxheap.peek() + minheap.peek()) * 0.5;
        } else {
            return maxheap.peek();
        }
    }
};
```
<a name="frCVj"></a>
# #328 奇偶链表
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 328 号问题：奇偶链表。题目难度为 Medium，目前通过率为 52.0% 。
<a name="LNlqu"></a>
### 题目描述
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。<br />请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。<br />**示例 1:**
```
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```
**示例 2:**
```
输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
```
**说明:**

- 应当保持奇数节点和偶数节点的相对顺序。
- 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。
<a name="Nrx3g"></a>
### 题目解析
这道题给了我们一个链表，让我们分开奇偶节点，所有奇节点在前，偶节点在后。

- 设定两个虚拟节点，dummyHead1用来保存奇节点，dummyHead2来保存偶节点；
- 遍历整个原始链表，将奇节点放于dummyHead1中，其余的放置在dummyHead2中
- 遍历结束后，将dummyHead2插入到dummyHead1后面
<a name="Q0faA"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=jVTX1&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="Wn8QT"></a>
### 代码实现
```
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {

        if(head == NULL || head->next == NULL || head->next->next == NULL)
            return head;

        ListNode* dummyHead1 = new ListNode(-1);
        ListNode* dummyHead2 = new ListNode(-1);
        ListNode* p1 = dummyHead1;
        ListNode* p2 = dummyHead2;
        ListNode* p = head;
        for(int i = 0; p; i ++)
            if(i % 2 == 0){
                p1->next = p;
                p = p->next;
                p1 = p1->next;
                p1->next = NULL;
            }
            else{
                p2->next = p;
                p = p->next;
                p2 = p2->next;
                p2->next = NULL;
            }

        p1->next = dummyHead2->next;
        ListNode* ret = dummyHead1->next;

        delete dummyHead1;
        delete dummyHead2;
        return ret;
    }
};
```
<a name="j6KZZ"></a>
# #324 的幂
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 342 号问题：4 的幂。题目难度为 Easy，目前通过率为 45.3% 。
<a name="vk8Q3"></a>
### 题目描述
给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。<br />**示例 1:**
```
输入: 16
输出: true
```
**示例 2:**
```
输入: 5
输出: false
```
**进阶：**<br />你能不使用循环或者递归来完成本题吗？
<a name="EkgQx"></a>
### 题目解析
这道题最直接的方法就是不停的去除以 4 ，看最终结果是否为 1 ，参见代码如下：
```java
class Solution {
    public boolean isPowerOfFour(int num) {
         while ( (num != 0)  && (num % 4 == 0)) {
            num /= 4;
        }
        return num == 1;
    }
}
```
不过这段代码使用了 **循环** ，逼格不够高。<br />对于一个整数而言，如果这个数是 4 的幂次方，那它必定也是 2 的幂次方。<br />我们先将 2 的幂次方列出来找一下其中哪些数是 4 的幂次方。

| 十进制 | 二进制 |
| --- | --- |
| 2 | 10 |
| 4 | **100** （1 在第 3 位） |
| 8 | 1000 |
| 16 | **10000**（1 在第 5 位） |
| 32 | 100000 |
| 64 | **1000000**（1 在第 7 位） |
| 128 | 10000000 |
| 256 | **100000000**（1 在第 9 位） |
| 512 | 1000000000 |
| 1024 | **10000000000**（1 在第 11 位） |

找一下规律： 4 的幂次方的数的二进制表示 1 的位置都是在**奇数位**。<br />之前在小吴的文章中判断一个是是否是 2 的幂次方数使用的是位运算 n & ( n - 1 )。同样的，这里依旧可以使用位运算：将这个数与特殊的数做位运算。<br />这个特殊的数有如下特点：

- 足够大，但不能超过 32 位，即最大为 1111111111111111111111111111111（ 31 个 1）
- 它的二进制表示中奇数位为 1 ，偶数位为 0符合这两个条件的二进制数是：
```java
1010101010101010101010101010101
```
**如果用一个 4 的幂次方数和它做与运算，得到的还是 4 的幂次方数**。<br />将这个二进制数转换成 16 进制表示：0x55555555 。有没有感觉逼格更高点。。。<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693722756887-475dbc88-ce21-49ae-b544-edb92349aee2.png#averageHue=%23f8f8f8&clientId=u56574840-1b68-4&from=url&id=Y0G7Y&originHeight=579&originWidth=892&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u189ebcca-a6c7-4c8d-acab-d90e5708771&title=)
<a name="uJKYi"></a>
### 图片描述
![](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1693722756848-bf65b79f-1d2c-4527-900d-f469eb8fdd69.jpeg#averageHue=%23f6f4f2&clientId=u56574840-1b68-4&from=url&id=Wz4EF&originHeight=768&originWidth=1024&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0dc047e1-5c2c-4e42-a463-884f2f2ba3f&title=)
<a name="sjGbI"></a>
### 代码实现
```java
class Solution {
    public boolean isPowerOfFour(int num) {
        if (num <= 0)
			return false;
        //先判断是否是 2 的幂
		if ((num & num - 1) != 0)
			return false;
        //如果与运算之后是本身则是 4 的幂
		if ((num & 0x55555555) == num)
			return true;
		return false;
    }
}
```
<a name="LzmFG"></a>
# #344 反转字符串
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 第 344 号问题：反转字符串。面试官最喜欢让你手写的一道算法题！
<a name="zGDWp"></a>
### 题目描述
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br />不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。<br />你可以假设数组中的所有字符都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符。<br />**示例 1：**
```
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```
**示例 2：**
```
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```
<a name="tehcU"></a>
### 题目解析
这道题没什么难度，直接从两头往中间走，同时交换两边的字符。注意需要白板编程写出来即可，也注意千万别回答一句使用 reverse() 这种高级函数来解决。。。
<a name="AyqNm"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=KJ1nf&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="AFL1A"></a>
### 代码实现
```
class Solution {
public:
    string reverseString(string s) {
        int i = 0, j = s.size() - 1;
        while (i < j){
            swap(s[i],s[j]);
            i++;
            j--;
        }
        return s;
    }
};
```
<a name="WYe2a"></a>
# #347 前 K 个高频元素
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />今天分享的题目来源于 LeetCode 上第 347 号问题：前 K 个高频元素。题目难度为 Medium，目前通过率为 56.9% 。
<a name="nywVw"></a>
## 题目描述
给定一个非空的整数数组，**返回其中出现频率前 k 高**的元素。<br />**示例 1:**
```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```
**示例 2:**
```
输入: nums = [1], k = 1
输出: [1]
```
**说明：**

- 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
- 你的算法的时间复杂度必须优于 O(n log n) ， n 是数组的大小。
<a name="EQUuW"></a>
### 题目解析
<a name="SJ1Jx"></a>
### 解法一：粗暴排序法
最简单粗暴的思路就是 **使用排序算法对元素按照频率由高到低进行排序**，然后再取前 k 个元素。<br />以下十种排序算法，任你挑选！<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693722776756-a0803cf4-eeac-42ae-93c7-2e3ede5d9b2e.png#averageHue=%23e5dfd8&clientId=u56574840-1b68-4&from=url&id=aveA8&originHeight=588&originWidth=966&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc8e9ebb1-6372-453a-9256-c76e1b203a4&title=)<br />可以发现，使用常规的诸如 冒泡、选择、甚至快速排序都是不满足题目要求，它们的时间复杂度都是大于或者等于 O(n log⁡n) ，而题目要求算法的时间复杂度必须优于 O(n log n) 。
<a name="CZwuu"></a>
#### 复杂度分析

- **时间复杂度**：O(nlogn)，n 表示数组长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，排序算法时间复杂度为O(nlogn) ；因此整体时间复杂度为 O(nlogn) 。
- **空间复杂度**：O(n)，最极端的情况下（每个元素都不同），用于存储元素及其频率的 Map 需要存储 n 个键值对。
<a name="l54jk"></a>
### 解法二：最小堆
题目最终需要返回的是前 k 个频率最大的元素，可以想到借助堆这种数据结构，对于 k 频率之后的元素不用再去处理，进一步优化时间复杂度。<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1693722776729-b9635a4a-198d-484f-b9a7-d615d5fedd7a.jpeg#averageHue=%23faeeeb&clientId=u56574840-1b68-4&from=url&id=bHriL&originHeight=768&originWidth=1024&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u37c753d5-4e45-44d5-afbd-eb74ad528f7&title=)<br />具体操作为：

- 借助 **哈希表** 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率
- 维护一个元素数目为 k 的最小堆
- 每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较
- 如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中
- 最终，堆中的 k 个元素即为前 k 个高频元素
<a name="PTgew"></a>
### 动画理解
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=emYBW&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="lW2P3"></a>
### 参考代码
```java
class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
        // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
        HashMap<Integer,Integer> map = new HashMap();
        for(int num : nums){
            if (map.containsKey(num)) {
               map.put(num, map.get(num) + 1);
             } else {
                map.put(num, 1);
             }
        }
        // 遍历map，用最小堆保存频率最大的k个元素
        PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer a, Integer b) {
                return map.get(a) - map.get(b);
            }
        });
        for (Integer key : map.keySet()) {
            if (pq.size() < k) {
                pq.add(key);
            } else if (map.get(key) > map.get(pq.peek())) {
                pq.remove();
                pq.add(key);
            }
        }
        // 取出最小堆中的元素
        List<Integer> res = new ArrayList<>();
        while (!pq.isEmpty()) {
            res.add(pq.remove());
        }
        return res;
    }
}
```
<a name="yQzPc"></a>
#### 复杂度分析

- **时间复杂度**：O(nlogk)， n 表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，遍历用于存储元素频率的 map，如果元素的频率大于最小堆中顶部的元素，则将顶部的元素删除并将该元素加入堆中，**这里维护堆的数目是 k **，所以这一系列操作的时间复杂度是 O(nlogk)的；因此，总的时间复杂度是 O(nlog⁡k) 。
- **空间复杂度**：O(n)，最坏情况下（每个元素都不同），map 需要存储 n 个键值对，优先队列需要存储 k个元素，因此，空间复杂度是 O(n)。
<a name="IEY4V"></a>
### 解法三：桶排序法
首先依旧使用哈希表统计频率，统计完成后，创建一个数组，将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标即可。<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1693722776799-7a6c554f-1fd6-427a-826c-577b24eea43f.jpeg#averageHue=%23e16b3a&clientId=u56574840-1b68-4&from=url&id=DbLZF&originHeight=768&originWidth=1024&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u73c2478c-7786-4c82-b901-829b2202167&title=)<br />代码实现如下：
```java
//基于桶排序求解「前 K 个高频元素」
class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
        List<Integer> res = new ArrayList();
        // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
        HashMap<Integer,Integer> map = new HashMap();
        for(int num : nums){
            if (map.containsKey(num)) {
               map.put(num, map.get(num) + 1);
             } else {
                map.put(num, 1);
             }
        }
        
        //桶排序
        //将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标
        List<Integer>[] list = new List[nums.length+1];
        for(int key : map.keySet()){
            // 获取出现的次数作为下标
            int i = map.get(key);
            if(list[i] == null){
               list[i] = new ArrayList();
            } 
            list[i].add(key);
        }
        
        // 倒序遍历数组获取出现顺序从大到小的排列
        for(int i = list.length - 1;i >= 0 && res.size() < k;i--){
            if(list[i] == null) continue;
            res.addAll(list[i]);
        }
        return res;
    }
}
```
<a name="nohND"></a>
#### 复杂度分析

- **时间复杂度**：O(n)， n 表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；桶的数量为 n + 1，所以桶排序的时间复杂度为 O(n)；因此，总的时间复杂度是 O(n)。
- **空间复杂度**：很明显为 O(n)
<a name="HxpEo"></a>
# #349 两个数组的交集
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 349 号问题：两个数组的交集。题目难度为 Easy，目前通过率为 62.3% 。
<a name="YV2lm"></a>
### 题目描述
给定两个数组，编写一个函数来计算它们的交集。<br />**示例 1:**
```
输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]
```
**示例 2:**
```
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]
```
**说明:**

- 输出结果中的每个元素一定是唯一的。
- 我们可以不考虑输出结果的顺序。
<a name="CnJEt"></a>
### 题目解析
容器类 [set](https://zh.cppreference.com/w/cpp/container/set) 的使用。

- 遍历 num1，通过 set 容器 record 存储 num1 的元素
- 遍历 num2 ，在 record 中查找是否有相同的元素，如果有，用 set 容器 resultSet 进行存储
- 将 resultSet 转换为 vector 类型
<a name="RpuF3"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=CQoz3&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="YUIN4"></a>
### 代码实现
```
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        set<int> record;
        for(int i = 0; i < nums1.size(); i ++){
            record.insert(nums1[i]);
        }
        
        set<int> resultSet;
        for(int i = 0; i < nums2.size();i++){
            if(record.find(nums2[i]) != record.end()){
                resultSet.insert(nums2[i]);
            }
        }
        
        vector<int> resultVector;
        for(set<int>::iterator iter=resultSet.begin(); iter != resultSet.end();iter++){
            resultVector.push_back(*iter);
        }
        return resultVector;
    }
};
```
<a name="j3t5a"></a>
# #350 两个数组的交集 II
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 350 号问题：两个数组的交集 II。题目难度为 Easy，目前通过率为 41.8% 。
<a name="ydew4"></a>
### 题目描述
给定两个数组，编写一个函数来计算它们的交集。<br />**示例 1:**
```
输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2,2]
```
**示例 2:**
```
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [4,9]
```
**说明：**

- 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
- 我们可以不考虑输出结果的顺序。

**进阶:**

- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 _nums1_ 的大小比 _nums2_ 小很多，哪种方法更优？
- 如果 _nums2_ 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？
<a name="sc1YV"></a>
### 题目解析
容器类 [map](https://zh.cppreference.com/w/cpp/container/map) 的使用。

- 遍历 num1，通过map容器 record 存储 num1 的元素与频率
- 遍历 num2 ，在 record 中查找是否有相同的元素（该元素的存储频率大于0），如果有，用map容器resultVector 进行存储，同时该元素的频率减一
<a name="sPqK6"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=Y3U5e&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="GL3z5"></a>
### 代码实现
```
// 350. Intersection of Two Arrays II
// https://leetcode.com/problems/intersection-of-two-arrays-ii/description/
// 时间复杂度: O(nlogn)
// 空间复杂度: O(n)
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {

        map<int, int> record;
        for(int i = 0 ; i < nums1.size() ; i ++){
             record[nums1[i]] += 1;
        }
        
        vector<int> resultVector;
        for(int i = 0 ; i < nums2.size() ; i ++){
            if(record[nums2[i]] > 0){
                resultVector.push_back(nums2[i]);
                record[nums2[i]] --;
            }
        }
        
        return resultVector;
    }
};
```
<a name="IovhL"></a>
# #387 字符串中的第一个唯一字符
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上 387题，主要涉及哈希表。
<a name="b7eir"></a>
## 题目
给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。<br />案例:
```
s = "leetcode"
返回 0.

s = "loveleetcode",
返回 2.
```
注意事项：您可以假定该字符串只包含小写字母。
<a name="BjT2n"></a>
## 题目解析
这道题不管怎么样都是要遍历一遍字符串才能保证字符是唯一，所以我们的算法如下

1. 遍历的时候把每个字符出现的次数用Map记录一下，如果这个字符是第一次出现，那么赋值为[i],如果它已经在Map里有了，那么我们给这个字符的值赋为false。
2. 再次遍历Map，找到值不为false的第一个字符，然后将它的值输出来
3. 如果值全部为false，然后返回-1
<a name="mOA9I"></a>
## 动画理解
<a name="iaZPo"></a>
## 参考代码
```
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
    let map = new Map()
    for (let i = 0; i < s.length;i++) {
        if(map.has(s[i])) {
            map.set(s[i], false)
        }else {
            map.set(s[i], [i])
        }
    }
    for(let item of map){
        if (item[1]) {
            return item[1][0]
        }
　　  }
   return -1
};
```
<a name="gn0pK"></a>
## 复杂度分析
哈希表的时间复杂度是O(n)
<a name="gPCaI"></a>
# #407 接雨水 II
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 407 号问题：接雨水 II。题目难度为 Hard，目前通过率为 38% 。
<a name="ffNUb"></a>
### 题目描述
给你一个 m x n 的矩阵，其中的值均为正整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。<br />**示例:**
```
给出如下 3x6 的高度图:
[
  [1,4,3,1,3,2],
  [3,2,1,3,2,4],
  [2,3,3,2,3,1]
]

返回 4 。
```
![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693391605747-127a4e26-b4b3-4506-990b-6c6df45cac74.png#averageHue=%23fbfafa&from=url&id=awp1v&originHeight=1084&originWidth=864&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="kBuVC"></a>
### 题目解析
在 1 个 2 维的矩阵中，每个格子都有其高度，问这个 2 维矩阵能够盛多少的水。首先我们分析，格子能够盛水的必要条件是其周围存在格子比当前格子高，这样水才能够被框得住，但是仔细一想，最外围的格子怎么办？它们是存不了水的，可以把最外围的格子想象成围栏，它们的作用就是保证里面格子的水不会流出来，所以我们就得先考虑这些格子，它们的高度直接决定了内部格子的蓄水量，但是这些格子也有局部性，一个格子的长短并不会影响矩阵当中所有的格子，但是它会影响与其相邻的格子，那么我们就需要有一个考虑的顺序，那就是优先考虑最外层最短的格子，由于每个格子都会影响到其周围的格子，内部格子也需要列入考虑范围，每次我们都考虑最短的格子，然后看其周围有没有没考虑过的比它还短的格子，于是就有了考虑的先后顺序：

1. 考虑最外层格子
2. 选出最外层最短的格子
3. 考虑该格子与其相邻的内部格子是否能盛水，并把这个内部格子也纳入考虑范围
4. 在考虑范围内的所有格子中选出最短的格子，重复步骤 3

这里需要注意的是，每次纳入考虑范围的格子是加了水之后的高度，而不是之前的高度，原因想一下应该不难理解。另外就是可以使用了 “堆” 这个数据结构来帮助实现寻找 “当前考虑范围内最短的格子” 这个操作步骤。
<a name="BzvgJ"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391685516-0d09d5ac-bad5-4f20-820d-670707467398.gif#averageHue=%23fefdfd&from=url&id=gtvjy&originHeight=608&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="CvakH"></a>
### 代码实现
```java
private class Pair {
    int x, y, h;
    Pair(int x, int y, int h) {
        this.x = x;
        this.y = y;
        this.h = h;
    }
}

private int[] dirX = {0, 0, -1, 1};
private int[] dirY = {-1, 1, 0, 0};

public int trapRainWater(int[][] heightMap) {
    if (heightMap.length == 0 || heightMap[0].length == 0) {
        return 0;
    }
    
    int m = heightMap.length;
    int n = heightMap[0].length;
    
    PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>() {
        @Override
        public int compare(Pair a, Pair b) {
            return a.h - b.h;
        }
    });
    
    boolean[][] visited = new boolean[m][n];
    
    // 优先将外围的元素加入队列中
    for (int i = 0; i < n; ++i) {
        pq.offer(new Pair(0, i, heightMap[0][i]));
        pq.offer(new Pair(m - 1, i, heightMap[m - 1][i]));
        
        visited[0][i] = true;
        visited[m - 1][i] = true;
    }
    
    for (int i = 1; i < m - 1; ++i) {
        pq.offer(new Pair(i, 0, heightMap[i][0]));
        pq.offer(new Pair(i, n - 1, heightMap[i][n - 1]));
        
        visited[i][0] = true;
        visited[i][n - 1] = true;
    }
    
    int result = 0;
    while (!pq.isEmpty()) {
        Pair cur = pq.poll();

        // 遍历当前位置上下左右四个方向
        for (int k = 0; k < 4; ++k) {
            int curX = cur.x + dirX[k];
            int curY = cur.y + dirY[k];
            
            if (curX < 0 || curY < 0 || curX >= m || curY >= n || visited[curX][curY]) {
                continue;
            }
            
            if (heightMap[curX][curY] < cur.h) {
                result += cur.h - heightMap[curX][curY];
            }
            
            pq.offer(new Pair(curX, curY, 
                              Math.max(heightMap[curX][curY], cur.h)));
            visited[curX][curY] = true;
        }
    }
    
    return result;
}
```
 

<a name="xcmO4"></a>
### 复杂度分析
因为使用了优先队列这个数据结构，每次元素出入队列的时间复杂度是 O(logn)，于是我们可以得出整体时间复杂度是 O(m*n*logm*n)，当然，需要说明的是，这是最差时间复杂度，由于并不是所有的元素都一次性加入队列，平均时间复杂度要比这个来的低，具体是什么就得看输入数据了。空间复杂度是 O(m*n)，这里也不难理解。通过这道题，堆的用法又被很好地展现了出来。
<a name="mKgMB"></a>
# #445 两数相加 II
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 445 号问题：两数相加 II。题目难度为 Medium，目前通过率为 48.8% 。
<a name="Qxmpv"></a>
### 题目描述
给定两个**非空**链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。<br />你可以假设除了数字 0 之外，这两个数字都不会以零开头。<br />**进阶:**<br />如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。<br />**示例:**
```
输入: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出: 7 -> 8 -> 0 -> 7
```
<a name="tq21c"></a>
### 题目解析
由于计算时要保证最右边的数对齐，那么很自然的想到先用**栈**存放链表中的每个值，然后依次计算。由于相加时可能产生进位，所以使用一个flag表示是否有进位。<br />提示：若栈中元素相加结束之后仍有进位，则需要新加入一个头结点。
<a name="vTMW2"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=bRYB8&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="J3bmM"></a>
### 代码实现
```python
class Solution:
    def addTwoNumbers(self, l1, l2):
        # 分别入栈
        stack1 = []
        stack2 = []
        while l1:
            stack1.append(l1.val)
            l1 = l1.next
        while l2:
            stack2.append(l2.val)
            l2 = l2.next

        flag = 0
        head = None
        while stack1 or stack2 or flag != 0:
            if stack1:
                flag += stack1.pop()
            if stack2:
                flag += stack2.pop()
            node = ListNode(flag % 10)
            node.next = head
            head = node
            flag = flag // 10
        return head
```
<a name="FqoNY"></a>
# #47 回旋镖的数量
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 447 号问题：回旋镖的数量。题目难度为 Easy，目前通过率为 45.8% 。
<a name="n2ITo"></a>
### 题目描述
给定平面上 _n_ 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（**需要考虑元组的顺序**）。<br />找到所有回旋镖的数量。你可以假设 _n_ 最大为 **500**，所有点的坐标在闭区间 **[-10000, 10000]** 中。<br />**示例:**
```
输入:
[[0,0],[1,0],[2,0]]

输出:
2

解释:
两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]
```
<a name="WQ0JH"></a>
### 题目解析
n 最大为 500，可以使用时间复杂度为 O(n^2)的算法。

- 遍历所有的点，让每个点作为一个锚点
- 然后再遍历其他的点，统计和锚点距离相等的点有多少个
- 然后分别带入 n(n-1) 计算结果并累加到res中
<a name="XDxRg"></a>
##### Tips：
<a name="RDZ9Z"></a>
###### Tip1

- 如果有一个点 a，还有两个点 b 和 c ，如果 ab 和 ac 之间的距离相等，那么就有两种排列方法 abc 和 acb；
- 如果有三个点 b，c，d都分别和a之间的距离相等，那么有六种排列方法，abc, acb, acd, adc, abd, adb；
- 如果有 n 个点和点 a 距离相等，那么排列方式为 n(n-1)。
<a name="HKBfR"></a>
###### Tip2

- 计算距离时不进行开根运算, 以保证精度；
- 只有当n大于等于2时，res值才会真正增加，因为当n=1时，增加量为1*(1-1)=0。
<a name="aXnPv"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=wkvI3&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="ZUixJ"></a>
### 代码实现
```
// 447. Number of Boomerangs
// https://leetcode.com/problems/number-of-boomerangs/description/
// 时间复杂度: O(n^2)
// 空间复杂度: O(n)
class Solution {
public:
    int numberOfBoomerangs(vector<pair<int, int>>& points) {

        int res = 0;
        for( int i = 0 ; i < points.size() ; i ++ ){

            // record中存储 点i 到所有其他点的距离出现的频次
            unordered_map<int, int> record;
            for(int j = 0 ; j < points.size() ; j ++){
                if(j != i){
                    // 计算距离时不进行开根运算, 以保证精度
                    record[dis(points[i], points[j])] += 1;
                }
            }
            
            for(unordered_map<int, int>::iterator iter = record.begin() ; iter != record.end() ; iter ++){
                res += (iter->second) * (iter->second - 1);
            }
        }
        return res;
    }

private:
    int dis(const pair<int,int> &pa, const pair<int,int> &pb){
        return (pa.first - pb.first) * (pa.first - pb.first) +
               (pa.second - pb.second) * (pa.second - pb.second);
    }
};
```
<a name="luM0s"></a>
# #454 四数相加 II
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 454 号问题：四数相加 II。题目难度为 Medium，目前通过率为 50.8% 。
<a name="Qv4PW"></a>
### 题目描述
给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。<br />为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。<br />**例如:**
```
输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

输出:
2

解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
```
<a name="A0dk6"></a>
### 题目解析
与[Two Sum](https://xiaozhuanlan.com/topic/7923618450)类似，需要用哈希表来解决问题。

- 把 A 和 B 的两两之和都求出来，在哈希表中建立两数之和与其出现次数之间的映射
- 遍历 C 和 D 中任意两个数之和，只要看哈希表存不存在这两数之和的相反数就行了
<a name="kJxEq"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=Font8&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="JN9Ln"></a>
### 代码实现
```
// 454. 4Sum II
// https://leetcode.com/problems/4sum-ii/description/
// 时间复杂度: O(n^2)
// 空间复杂度: O(n^2)
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {

        unordered_map<int,int> hashtable;
        for(int i = 0 ; i < A.size() ; i ++){
            for(int j = 0 ; j < B.size() ; j ++){
                 hashtable[A[i]+B[j]] += 1;
            }
        }
        
        int res = 0;
        for(int i = 0 ; i < C.size() ; i ++){
            for(int j = 0 ; j < D.size() ; j ++){
                if(hashtable.find(-C[i]-D[j]) != hashtable.end()){
                    res += hashtable[-C[i]-D[j]];
                }
            }
        }
    
        return res;
    }
};
```
<a name="FBjk1"></a>
### 题目描述
两个整数之间的[汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB)指的是这两个数字对应二进制位不同的位置的数目。<br />给出两个整数 x 和 y，计算它们之间的汉明距离。<br />示例 :
```
输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
```
<a name="dwjXV"></a>
### 题目解析
首先通过 异或 操作找出两个数字对应位不同的位置，然后统计这些位置的个数。<br />统计解法借鉴Java中Integer.bitCount()方法源码来进行讲解，通过固定步数得到异或后1的个数。<br />第一步：将奇数位与偶数位相加，可以得出每两位1的个数，并将个数记录在这两位空间中<br />i = i - (( i >>> 1 ) & 0x55555555 )
```
0x55555555 => 01 01 01 01 ... 01 01
i          & 0x55555555   取出奇数位的1
(i >>> 1)  & 0x55555555   取出偶数位的1
比如，两位的情况下总共就四种情况：00 11 01 10 
假设 i = 00 11 01 10 
i          & 0x55555555 = 00 11 01 10 
                          01 01 01 01
                          -----------
                          00 01 01 00
(i >>> 1)  & 0x55555555 = 00 01 10 11 
													01 01 01 01
													-----------
													00 01 00 01
将奇数位1的个数与偶数位的1求和：
00 01 01 00
00 01 00 01
-----------
00 10 01 01
结合原数字可以看出，00（00：没有1） 11（10：两个1） 01（01：1个1） 10（01：1个1） 

每两位在通过加法统计时，总共如下四种情况[i & 01 + （i>>>1) & 01]：
11: 01 + 01 = 10 = 2, 10: 00 + 01 = 01 = 1, 01: 01 + 00 = 01 = 1, 00: 00 + 00 = 00 = 0 
每两位在通过减法统计时，总共如下四种情况[i - （i>>>1) & 01]：
11: 11 - 01 = 10 = 2, 10: 10 - 01 = 01 = 1, 01: 01 - 00 = 01 = 1, 00: 00 + 00 = 00 = 0
可以发现结果是一样的，但是少了一次位运算！

在将每两位1的个数统计完之后，就可以开始两位两位、四位四位...相加求出1的总数
```
第二步：通过相邻两位1的个数相加，求出每四位包含1的个数，并将结果存储在所在的四位中<br />i = ( i & 0x33333333 ) + (( i >>> 2 ) & 0x33333333 )
```
0x55555555 => 0011 0011 0011 ... 0011 0011
继续上一步的结果向下进行：00 10 01 01
i          & 0x33333333 = 0010 0101
													0011 0011
													---------
													0010 0001
(i >>> 2)  & 0x33333333 = 0000 1001
													0011 0011
													---------
													0000 0001
												
就和得出每四位所包含1的个数
0010 0001
0000 0001
---------
0010 0010
结合原数字可以看出，0011(0010:有两个1)  0110(0010:有两个1)
```
第三步：通过相邻四位1的个数相加，求出每八位包含1的个数，并将结果存储在所在的八位中<br />i = ( i + ( i >>> 4 )) & 0x0f0f0f0f;
```
0x0f0f0f0f => 00001111 ... 00001111‬
继续上一步的结果向下进行：0010 0010
i          & 0x0f0f0f0f = 00100010
													00001111
													--------
													00000010
(i >>> 4)  & 0x0f0f0f0f = 00000010
													00001111
													--------
													00000010
就和得出每八位所包含1的个数
00000010
00000010
--------
00000100
结合原数字可以看出，00110110(00000100:有四个1)

源码中直接先将相邻四位进行相加，然后做了一次无用位清除
```
第四步：通过相邻八位1的个数相加，求出每十六位包含1的个数，并将结果存储在所在的十六位中<br />i = i + ( i >>> 8 );
```
可以理解为（ i & 0x0f0f0f0f ） + (( i  >>>  8 )  & 0x0f0f0f0f );

0x0f0f0f0f => 00000000111111110000000011111111
```
第五步：通过将int类型前十六位1的个数与后16位1的个数相加，求出int中所有1的个数<br />i = i + ( i >>> 16 );
```
可以理解为（ i & 0x0000ffff ） + (( i  >>>  8 )  & 0x0000ffff );

0x0000ffff => 00000000000000001111111111111111‬
```
第六步：去除无用的位<br />return i & 0x3f;
```
int类型32位，即最多0x100000个1，除此之外左边的位都是无用的。
0x3f => 00111111‬
```
<a name="IkM20"></a>
### 动画理解
![](https://inspidea.yuque.com/attachments/yuque/0/2023/mp4/35495747/1693391692713-7725e113-7be0-4502-9820-53117cfc3988.mp4#from=url&id=ky0Wa&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />‎⁨
<a name="vnLbi"></a>
### 参考代码
```java
class Solution {
    public int hammingDistance(int x, int y) {
        return Integer.bitCount(x ^ y); 
    }
}
```
bitCount源码：
```java
public static int bitCount(int i) {
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    i = (i + (i >>> 4)) & 0x0f0f0f0f;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    return i & 0x3f;
}
```
<a name="x8QDO"></a>
### 复杂度分析
时间复杂度：O(1)<br />空间复杂度：O(1)
<a name="IzhoE"></a>
### 题目描述
两个整数的 [汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/475174?fr=aladdin) 指的是这两个数字的二进制数对应位不同的数量。<br />计算一个数组中，任意两个数之间汉明距离的总和。<br />示例 :
```
输入: 4, 14, 2

输出: 6

解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）
所以答案为：
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
```
**注意:**

1. 数组中元素的范围为从 0到 10^9。
2. 数组的长度不超过 10^4。
<a name="Abw0M"></a>
### 题目解析
已示例为例，两两暴力计算的时间复杂度为o(n^2)，实现上肯定是没有问题，但是当数据量大的时候性能堪忧。<br />我们先将数组与结果的数字二进制写出来
```
4    0 1 0 0
14    1 1 1 0
 2    0 0 1 0
HammingDistance(4, 14) = 1 0 1 0
HammingDistance(4, 2)  = 0 1 1 0
HammingDistance(14, 2) = 1 1 0 0
```
结合结果，从左往右按列观察这三个数字的二进制与运算结果的二进制可以发现一种关系：<br />数字个数 Count = 3<br />第一列： 0 1 0 ==> 1 * (3 -1) = 2 = 1 0 1<br />本列只有1个1，说明在所有数字的第一位中，有（Count - 1）个数字的第一位与 **本数字** 不同，也就是求距离的时候结果为1， 即这一位产生1的个数为1 * (3 -1)<br />第二列： 1 1 0 ==> 2 * (3 -2) = 2 = 0 1 1<br />本列有2个1，说明在所有数字的第二位中，有（Count - 2）个数字的第二位与这 **两个数字** 不同，即这一位产生1的个数为（Count - 2）+ （Count - 2）= 2 *（3 - 2）<br />第三列同第二列<br />第四列： 0 0 0 ==> 0 * (3 -0) = 0 = 0 0 0<br />本列所有数字相同，求距离时也就不会产生1， 结果为0<br />如果是 1 1 1也一样，3 * (3 - 3)， 结果依旧为0<br />总结 ：每一列求距离产生1的个数 = 本列 1 的个数 _ （数字个数 – 本列1的个数）= 本列 1 的个数 _ 本列 0 的个数
<a name="mtI24"></a>
### 动画理解
![](https://inspidea.yuque.com/attachments/yuque/0/2023/mp4/35495747/1693391692713-7725e113-7be0-4502-9820-53117cfc3988.mp4#from=url&id=IFhzi&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />‎
<a name="ySjJC"></a>
### 参考代码
```java
class Solution {
    public int totalHammingDistance(int[] nums) {
        int len=nums.length;
        int[] bitCount = new int[32];
        if(len <= 1){
            return 0;
        }
        for(int numIndex = 0; numIndex < len; numIndex++){
            for(int bitIndex = 0; bitIndex < 32; bitIndex++){
                bitCount[bitIndex] += nums[numIndex] & 1;
                nums[numIndex] = nums[numIndex] >> 1;
                if(nums[numIndex] == 0){
                    break;
                }
            }
        }
        int oneCount = 0;
        for(int bitIndex = 0; bitIndex < 32; bitIndex++){
            oneCount += bitCount[bitIndex] * (len - bitCount[bitIndex]);
        }
        return oneCount;
    }
}
```
<a name="UJZqZ"></a>
### 复杂度分析
时间复杂度：时间复杂度：O(N log ⁡C) 其中 C是常数，表示数组中数可能的最大值。<br />空间复杂度：O(log C)

题目来源于LeetCode上第540号问题：有序数组中的单一元素。题目难度为中等，目前通过率60.2%。<br />##题目描述<br />给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。
```
示例 1:

输入: [1,1,2,3,3,4,4,8,8]
输出: 2
示例 2:

输入: [3,3,7,7,10,11,11]
输出: 10
注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。
```
##题目解析<br />我们先读题，找出题中关键词“包含整数的有序数组”、‘’元素出现两次“、”只有一个数出现一次“，这里我们可以知道：只出现一次的那个元素所在的有序数组元素个数必为奇数。这个是解题的关键。因为题目要求我们的时间复杂度为O(log n)，因此我们可以用二分搜索法。
<a name="f0uCM"></a>
## 解法一：二分搜索
首先将lo和hi分别指向数组首尾元素，mid指向中间元素，这时我们会发现中间元素与其左右两边元素分别有以下三种情况，如：（1）3、3、4，（2）3、4、3，（3）4、3、3。对于第二种情况，我们立马就找到了只出现一次的那个元素。那么对于第一种情况mid=mid-1，那么以（3、3）为界将数组一分为二，判断两边的元素个数，因为我们知道只出现一次的那个元素所在的有序数组元素个数必为奇数，如果（3、3）左边的元素个数为奇数，那么只出现一次的那个数载左边，则将hi移到mid-2位置，即（3、3）的左边，如果（3、3）右边的元素个数为奇数，那么只出现一次的那个数在右边，则将lo移到mid+1位置，即（3、3）的右边。第三种情况与第二种情况类似分析，如果（3、3）左边为奇数，则hi移到mid-1位置，如果（3、3）右边为奇数，则lo移到mid+2位置。以此类推，直到lo=hi，搜索结束。<br />##动画理解<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=PPRJC&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />##代码实现
```
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int lo = 0;
        int hi = nums.length - 1;
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            boolean halvesAreEven = (hi - mid) % 2 == 0;
            if (nums[mid + 1] == nums[mid]) {
                if (halvesAreEven) {
                    lo = mid + 2;
                } else {
                    hi = mid - 1;
                }
            } else if (nums[mid - 1] == nums[mid]) {
                if (halvesAreEven) {
                    hi = mid - 2;
                } else {
                    lo = mid + 1;
                }
            } else {
                return nums[mid];
            }
        }
        return nums[lo];
    }
}
```
##复杂度分析

- 时间复杂度：O(log n)，在每次循环迭代中，我们将搜索空间减少了一半。
- 空间复杂度：O(1)，仅用了常数空间

##解法二：仅对偶数索引进行二分搜索<br />我们发现当mid索引为偶数时，mid两边的数组元素个数是偶数，如果mid索引为奇数时，mid两边的数组元素个数为奇数。当mid索引为偶数时，如果mid=mid+1，即解法一的第三种情况，因为mid右边个数为偶数，所以mid+2到hi个数为奇数，那么只出现一次的那个元素肯定在mid的右边，将lo移动到mid+2位置。如果mid！= mid+1，那么只出现一次的那个元素肯定在mid的左边或者就是mid。如果mid 索引为奇数，那么我们为了保证mid索引为偶数，将mid移到mid-1位置，这样mid索引就变成偶数了，重复上述操作，直到hi=lo，搜索结束。<br />##动画理解<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391648792-c994a883-c947-452d-a029-a30c5cac1f02.gif#averageHue=%23fcfbfb&from=url&id=V3YP0&originHeight=360&originWidth=480&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />##代码实现
```
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int lo = 0;
        int hi = nums.length - 1;
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            if (mid % 2 == 1) mid--;
            if (nums[mid] == nums[mid + 1]) {
                lo = mid + 2;
            } else {
                hi = mid;
            }
        }
        return nums[lo];
    }
}
```
##复杂度分析

- 时间复杂度：O(log2 / n)=O(log n)，我们仅对元素的一半进行二分搜索。
- 空间复杂度：O(1)，仅用了常数空间
<a name="n0qYL"></a>
### 题目描述
两个整数之间的[汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB)指的是这两个数字对应二进制位不同的位置的数目。<br />给出两个整数 x 和 y，计算它们之间的汉明距离。<br />示例 :
```
输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
```
<a name="E0Kd4"></a>
### 题目解析
首先通过 异或 操作找出两个数字对应位不同的位置，然后统计这些位置的个数。<br />统计解法借鉴Java中Integer.bitCount()方法源码来进行讲解，通过固定步数得到异或后1的个数。<br />第一步：将奇数位与偶数位相加，可以得出每两位1的个数，并将个数记录在这两位空间中<br />i = i - (( i >>> 1 ) & 0x55555555 )
```
0x55555555 => 01 01 01 01 ... 01 01
i          & 0x55555555   取出奇数位的1
(i >>> 1)  & 0x55555555   取出偶数位的1
比如，两位的情况下总共就四种情况：00 11 01 10 
假设 i = 00 11 01 10 
i          & 0x55555555 = 00 11 01 10 
                          01 01 01 01
                          -----------
                          00 01 01 00
(i >>> 1)  & 0x55555555 = 00 01 10 11 
													01 01 01 01
													-----------
													00 01 00 01
将奇数位1的个数与偶数位的1求和：
00 01 01 00
00 01 00 01
-----------
00 10 01 01
结合原数字可以看出，00（00：没有1） 11（10：两个1） 01（01：1个1） 10（01：1个1） 

每两位在通过加法统计时，总共如下四种情况[i & 01 + （i>>>1) & 01]：
11: 01 + 01 = 10 = 2, 10: 00 + 01 = 01 = 1, 01: 01 + 00 = 01 = 1, 00: 00 + 00 = 00 = 0 
每两位在通过减法统计时，总共如下四种情况[i - （i>>>1) & 01]：
11: 11 - 01 = 10 = 2, 10: 10 - 01 = 01 = 1, 01: 01 - 00 = 01 = 1, 00: 00 + 00 = 00 = 0
可以发现结果是一样的，但是少了一次位运算！

在将每两位1的个数统计完之后，就可以开始两位两位、四位四位...相加求出1的总数
```
第二步：通过相邻两位1的个数相加，求出每四位包含1的个数，并将结果存储在所在的四位中<br />i = ( i & 0x33333333 ) + (( i >>> 2 ) & 0x33333333 )
```
0x55555555 => 0011 0011 0011 ... 0011 0011
继续上一步的结果向下进行：00 10 01 01
i          & 0x33333333 = 0010 0101
													0011 0011
													---------
													0010 0001
(i >>> 2)  & 0x33333333 = 0000 1001
													0011 0011
													---------
													0000 0001
												
就和得出每四位所包含1的个数
0010 0001
0000 0001
---------
0010 0010
结合原数字可以看出，0011(0010:有两个1)  0110(0010:有两个1)
```
第三步：通过相邻四位1的个数相加，求出每八位包含1的个数，并将结果存储在所在的八位中<br />i = ( i + ( i >>> 4 )) & 0x0f0f0f0f;
```
0x0f0f0f0f => 00001111 ... 00001111‬
继续上一步的结果向下进行：0010 0010
i          & 0x0f0f0f0f = 00100010
													00001111
													--------
													00000010
(i >>> 4)  & 0x0f0f0f0f = 00000010
													00001111
													--------
													00000010
就和得出每八位所包含1的个数
00000010
00000010
--------
00000100
结合原数字可以看出，00110110(00000100:有四个1)

源码中直接先将相邻四位进行相加，然后做了一次无用位清除
```
第四步：通过相邻八位1的个数相加，求出每十六位包含1的个数，并将结果存储在所在的十六位中<br />i = i + ( i >>> 8 );
```
可以理解为（ i & 0x0f0f0f0f ） + (( i  >>>  8 )  & 0x0f0f0f0f );

0x0f0f0f0f => 00000000111111110000000011111111
```
第五步：通过将int类型前十六位1的个数与后16位1的个数相加，求出int中所有1的个数<br />i = i + ( i >>> 16 );
```
可以理解为（ i & 0x0000ffff ） + (( i  >>>  8 )  & 0x0000ffff );

0x0000ffff => 00000000000000001111111111111111‬
```
第六步：去除无用的位<br />return i & 0x3f;
```
int类型32位，即最多0x100000个1，除此之外左边的位都是无用的。
0x3f => 00111111‬
```
<a name="QuGlI"></a>
### 动画理解
![](https://inspidea.yuque.com/attachments/yuque/0/2023/mp4/35495747/1693391692713-7725e113-7be0-4502-9820-53117cfc3988.mp4#from=url&id=K2C59&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />‎⁨
<a name="OBbSC"></a>
### 参考代码
```java
class Solution {
    public int hammingDistance(int x, int y) {
        return Integer.bitCount(x ^ y); 
    }
}
```
bitCount源码：
```java
public static int bitCount(int i) {
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    i = (i + (i >>> 4)) & 0x0f0f0f0f;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    return i & 0x3f;
}
```
<a name="y1ar3"></a>
### 复杂度分析
时间复杂度：O(1)<br />空间复杂度：O(1)
<a name="lHldK"></a>
### 题目描述
两个整数的 [汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/475174?fr=aladdin) 指的是这两个数字的二进制数对应位不同的数量。<br />计算一个数组中，任意两个数之间汉明距离的总和。<br />示例 :
```
输入: 4, 14, 2

输出: 6

解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）
所以答案为：
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
```
**注意:**

1. 数组中元素的范围为从 0到 10^9。
2. 数组的长度不超过 10^4。
<a name="xGRZz"></a>
### 题目解析
已示例为例，两两暴力计算的时间复杂度为o(n^2)，实现上肯定是没有问题，但是当数据量大的时候性能堪忧。<br />我们先将数组与结果的数字二进制写出来
```
4    0 1 0 0
14    1 1 1 0
 2    0 0 1 0
HammingDistance(4, 14) = 1 0 1 0
HammingDistance(4, 2)  = 0 1 1 0
HammingDistance(14, 2) = 1 1 0 0
```
结合结果，从左往右按列观察这三个数字的二进制与运算结果的二进制可以发现一种关系：<br />数字个数 Count = 3<br />第一列： 0 1 0 ==> 1 * (3 -1) = 2 = 1 0 1<br />本列只有1个1，说明在所有数字的第一位中，有（Count - 1）个数字的第一位与 **本数字** 不同，也就是求距离的时候结果为1， 即这一位产生1的个数为1 * (3 -1)<br />第二列： 1 1 0 ==> 2 * (3 -2) = 2 = 0 1 1<br />本列有2个1，说明在所有数字的第二位中，有（Count - 2）个数字的第二位与这 **两个数字** 不同，即这一位产生1的个数为（Count - 2）+ （Count - 2）= 2 *（3 - 2）<br />第三列同第二列<br />第四列： 0 0 0 ==> 0 * (3 -0) = 0 = 0 0 0<br />本列所有数字相同，求距离时也就不会产生1， 结果为0<br />如果是 1 1 1也一样，3 * (3 - 3)， 结果依旧为0<br />总结 ：每一列求距离产生1的个数 = 本列 1 的个数 _ （数字个数 – 本列1的个数）= 本列 1 的个数 _ 本列 0 的个数
<a name="IGwJx"></a>
### 动画理解
![](https://inspidea.yuque.com/attachments/yuque/0/2023/mp4/35495747/1693391692713-7725e113-7be0-4502-9820-53117cfc3988.mp4#from=url&id=RxA14&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />‎
<a name="wKvvg"></a>
### 参考代码
```java
class Solution {
    public int totalHammingDistance(int[] nums) {
        int len=nums.length;
        int[] bitCount = new int[32];
        if(len <= 1){
            return 0;
        }
        for(int numIndex = 0; numIndex < len; numIndex++){
            for(int bitIndex = 0; bitIndex < 32; bitIndex++){
                bitCount[bitIndex] += nums[numIndex] & 1;
                nums[numIndex] = nums[numIndex] >> 1;
                if(nums[numIndex] == 0){
                    break;
                }
            }
        }
        int oneCount = 0;
        for(int bitIndex = 0; bitIndex < 32; bitIndex++){
            oneCount += bitCount[bitIndex] * (len - bitCount[bitIndex]);
        }
        return oneCount;
    }
}
```
<a name="ibdhv"></a>
### 复杂度分析
时间复杂度：时间复杂度：O(N log ⁡C) 其中 C是常数，表示数组中数可能的最大值。<br />空间复杂度：O(log C)<br />题目来源于LeetCode上第540号问题：有序数组中的单一元素。题目难度为中等，目前通过率60.2%。<br />##题目描述<br />给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。
```
示例 1:

输入: [1,1,2,3,3,4,4,8,8]
输出: 2
示例 2:

输入: [3,3,7,7,10,11,11]
输出: 10
注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。
```
##题目解析<br />我们先读题，找出题中关键词“包含整数的有序数组”、‘’元素出现两次“、”只有一个数出现一次“，这里我们可以知道：只出现一次的那个元素所在的有序数组元素个数必为奇数。这个是解题的关键。因为题目要求我们的时间复杂度为O(log n)，因此我们可以用二分搜索法。
<a name="JoPQN"></a>
## 解法一：二分搜索
首先将lo和hi分别指向数组首尾元素，mid指向中间元素，这时我们会发现中间元素与其左右两边元素分别有以下三种情况，如：（1）3、3、4，（2）3、4、3，（3）4、3、3。对于第二种情况，我们立马就找到了只出现一次的那个元素。那么对于第一种情况mid=mid-1，那么以（3、3）为界将数组一分为二，判断两边的元素个数，因为我们知道只出现一次的那个元素所在的有序数组元素个数必为奇数，如果（3、3）左边的元素个数为奇数，那么只出现一次的那个数载左边，则将hi移到mid-2位置，即（3、3）的左边，如果（3、3）右边的元素个数为奇数，那么只出现一次的那个数在右边，则将lo移到mid+1位置，即（3、3）的右边。第三种情况与第二种情况类似分析，如果（3、3）左边为奇数，则hi移到mid-1位置，如果（3、3）右边为奇数，则lo移到mid+2位置。以此类推，直到lo=hi，搜索结束。<br />##动画理解<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=L40gk&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />##代码实现
```
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int lo = 0;
        int hi = nums.length - 1;
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            boolean halvesAreEven = (hi - mid) % 2 == 0;
            if (nums[mid + 1] == nums[mid]) {
                if (halvesAreEven) {
                    lo = mid + 2;
                } else {
                    hi = mid - 1;
                }
            } else if (nums[mid - 1] == nums[mid]) {
                if (halvesAreEven) {
                    hi = mid - 2;
                } else {
                    lo = mid + 1;
                }
            } else {
                return nums[mid];
            }
        }
        return nums[lo];
    }
}
```
##复杂度分析

- 时间复杂度：O(log n)，在每次循环迭代中，我们将搜索空间减少了一半。
- 空间复杂度：O(1)，仅用了常数空间

##解法二：仅对偶数索引进行二分搜索<br />我们发现当mid索引为偶数时，mid两边的数组元素个数是偶数，如果mid索引为奇数时，mid两边的数组元素个数为奇数。当mid索引为偶数时，如果mid=mid+1，即解法一的第三种情况，因为mid右边个数为偶数，所以mid+2到hi个数为奇数，那么只出现一次的那个元素肯定在mid的右边，将lo移动到mid+2位置。如果mid！= mid+1，那么只出现一次的那个元素肯定在mid的左边或者就是mid。如果mid 索引为奇数，那么我们为了保证mid索引为偶数，将mid移到mid-1位置，这样mid索引就变成偶数了，重复上述操作，直到hi=lo，搜索结束。<br />##动画理解<br />![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391648792-c994a883-c947-452d-a029-a30c5cac1f02.gif#averageHue=%23fcfbfb&from=url&id=uYO9i&originHeight=360&originWidth=480&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />##代码实现
```
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int lo = 0;
        int hi = nums.length - 1;
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            if (mid % 2 == 1) mid--;
            if (nums[mid] == nums[mid + 1]) {
                lo = mid + 2;
            } else {
                hi = mid;
            }
        }
        return nums[lo];
    }
}
```
##复杂度分析

- 时间复杂度：O(log2 / n)=O(log n)，我们仅对元素的一半进行二分搜索。
- 空间复杂度：O(1)，仅用了常数空间
<a name="vDSqT"></a>
# #642 设计一个搜索自动完成系统
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上第 642 号问题：设计一个搜索自动完成系统。题目难度为 Hard，目前通过率为 37.8% 。
<a name="zk9tU"></a>
### 题目描述
为搜索引擎设计一个搜索自动完成系统。用户可以输入一个句子(至少一个单词，并以一个特殊的字符'#'结尾)。对于除'#'之外的每个字符，您需要返回与已输入的句子部分前缀相同的前3个历史热门句子。具体规则如下:<br />一个句子的热度定义为用户输入完全相同句子的次数。<br />返回的前3个热门句子应该按照热门程度排序(第一个是最热的)。如果几个句子的热度相同，则需要使用ascii代码顺序(先显示较小的一个)。<br />如果少于3个热门句子，那么就尽可能多地返回。<br />当输入是一个特殊字符时，它意味着句子结束，在这种情况下，您需要返回一个空列表。<br />您的工作是实现以下功能:<br />构造函数:<br />AutocompleteSystem(String[] sentence, int[] times):这是构造函数。输入是历史数据。句子是由之前输入的句子组成的字符串数组。Times是输入一个句子的相应次数。您的系统应该记录这些历史数据。<br />现在，用户想要输入一个新句子。下面的函数将提供用户类型的下一个字符:<br />List input(char c):输入c是用户输入的下一个字符。字符只能是小写字母(“a”到“z”)、空格(“”)或特殊字符(“#”)。另外，前面输入的句子应该记录在系统中。输出将是前3个历史热门句子，它们的前缀与已经输入的句子部分相同。<br />例子:<br />操作:AutocompleteSystem(["i love you"， "island"，"ironman"， "i love leetcode"]， [5,3,2,2])<br />系统已经追踪到以下句子及其对应的时间:<br />"i love you" : 5 times<br />"island" : 3 times<br />"ironman" : 2 times<br />"i love leetcode" : 2 times<br />现在，用户开始另一个搜索:<br />操作:输入(“i”)<br />输出:["i love you"， "island"，"i love leetcode"]<br />解释:<br />有四个句子有前缀“i”。其中，《ironman》和《i love leetcode》有着相同的热度。既然“ ” ASCII码为32，“r”ASCII码为114，那么“i love leetcode”应该在“ironman”前面。此外，我们只需要输出前3个热门句子，所以“ironman”将被忽略。<br />操作:输入(' ')<br />输出:[“i love you”，“i love leetcode”]<br />解释:<br />只有两个句子有前缀“i”。<br />操作:输入(' a ')<br />输出:[]<br />解释:<br />没有以“i a”为前缀的句子。<br />操作:输入(“#”)<br />输出:[]<br />解释:<br />用户完成输入后，在系统中将句子“i a”保存为历史句。下面的输入将被计算为新的搜索。<br />注意:<br />输入的句子总是以字母开头，以“#”结尾，两个单词之间只有一个空格。<br />要搜索的完整句子不会超过100个。包括历史数据在内的每句话的长度不会超过100句。<br />在编写测试用例时，即使是字符输入，也请使用双引号而不是单引号。<br />请记住重置在AutocompleteSystem类中声明的类变量，因为静态/类变量是跨多个测试用例持久化的。详情请点击这里。
<a name="zlUGy"></a>
### 题目解析
设计一个搜索自动补全系统，它需要包含如下两个方法：
<a name="lbPOP"></a>
#### 构造方法：
AutocompleteSystem(String[] sentences, int[] times): 输入句子sentences，及其出现次数times
<a name="uXwcP"></a>
#### 输入方法：
List input(char c): 输入字符c可以是26个小写英文字母，也可以是空格，以'#'结尾。返回输入字符前缀对应频率最高的至多3个句子，频率相等时按字典序排列。
<a name="RfPug"></a>
### 思路解析：
核心点：Trie（字典树）<br />利用字典树记录所有出现过的句子集合，利用字典保存每个句子出现的次数。
<a name="bJhlr"></a>
#### 解题思路
题目的要求是补全的句子是按之前出现的频率排列的，高频率的出现在最上面，如果频率相同，就按字母顺序来显示。<br />频率 这种要求很容易想到 堆、优先队列、树、Map等知识点，这里涉及到 字典 与 树，那肯定使用 字典树 能解决。<br />所以首先构造 Trie 的 trieNode 结构以及 insert 方法，构造完 trieNode 类后，再构造一个树的根节点。<br />由于每次都要输入一个字符，我们可以用一个私有的 Node：curNode 来追踪当前的节点。<br />curNode 初始化为 root ，在每次输入完一个句子时，即输入的字符为‘#’时，我们需要将其置为root。<br />同时还需要一个 string 类型 stn 来表示当前的搜索的句子。<br />每输入一个字符，首先检查是不是结尾标识“#”，如果是的话，将当前句子加入trie树，重置相关变量，返回空数组。

- 如不是，检查当前 TrieNode 对应的 child 是否含有 c 的对应节点。如果没有，将 curNode 置为 NULL 并且返回空数组。
- 若存在，将curNode 更新为c对应的节点，并且对curNode进行dfs。

dfs 时，我们首先检查当前是不是一个完整的句子，如果是，将句子与其次数同时加入 priority_queue 中，然后对其 child 中可能存在的子节点进行 dfs 。<br />进行完 dfs 后，只需要取出前三个，需要注意的是，可能可选择的结果不满3个，所以要在 while 中多加入检测 q 为空的条件语句。<br />最后要将 q 中的所有元素都弹出。
<a name="XlIyB"></a>
### 动画描述
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=lSeu0&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="tZ8w1"></a>
### 代码实现
<a name="H6PKL"></a>
#### C++
```
class TrieNode{
  public:
    string str;
    int cnt;
    unordered_map<char, TrieNode*> child;
    TrieNode(): str(""), cnt(0){};
};

struct cmp{
    bool operator() (const pair<string, int> &p1, const pair<string, int> &p2){
        return p1.second < p2.second || (p1.second == p2.second && p1.first > p2.first);
    }
};

class AutocompleteSystem {
public:
    AutocompleteSystem(vector<string> sentences, vector<int> times) {
        root = new TrieNode();
        for(int i = 0; i < sentences.size(); i++){
            insert(sentences[i], times[i]);
        }
        curNode = root;
        stn = "";
    }
    
    vector<string> input(char c) {
        if(c == '#'){
            insert(stn, 1);
            stn.clear();
            curNode = root;
            return {};
        }
        stn.push_back(c);
        if(curNode && curNode->child.count(c)){
            curNode = curNode->child[c];
        }else{
            curNode = NULL;
            return {};
        }
        
        dfs(curNode);
        
        vector<string> ret;
        int n = 3;
        while(n > 0 && !q.empty()){
            ret.push_back(q.top().first);
            q.pop();
            n--;
        }
        while(!q.empty()) q.pop();
        
        return ret;
    }
    
    void dfs(TrieNode* n){
        if(n->str != ""){
            q.push({n->str, n->cnt});
        }
        for(auto p : n->child){
            dfs(p.second);
        }
    }
    
    void insert(string s, int cnt){
        TrieNode* cur = root;
        for(auto c : s){
            if(cur->child.count(c) == 0){
                cur->child[c] = new TrieNode();
            }
            cur = cur->child[c];
        }
        cur->str = s;
        cur->cnt += cnt;
    }
    
private:
    TrieNode *root, *curNode;
    string stn;
    priority_queue<pair<string,int>, vector<pair<string, int>>, cmp > q;
    
};
```
<a name="MDjjh"></a>
# #695 Max Area of Island
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />本题解作者：nettee
<a name="R4D2y"></a>
## 题目描述
给定一个包含了一些 0 和 1 的非空二维数组 grid。<br />一个**岛屿**是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。<br />找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0。)<br />**示例 1:**
```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```
对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。<br />**示例 2:**
```
[[0,0,0,0,0,0,0,0]]
```
对于上面这个给定的矩阵, 返回 0。<br />注意: 给定的矩阵 grid 的长度和宽度都不超过 50。
<a name="xOzsJ"></a>
## 题目解析
这道题的主要思路是深度优先搜索。每次走到一个是 1 的格子，就搜索整个岛屿，并计算当前岛屿的面积。最后返回岛屿面积的最大值。<br />网格可以看成是一个无向图的结构，每个格子和它上下左右的四个格子相邻。如果四个相邻的格子坐标合法，且是陆地，就可以继续搜索。<br />在深度优先搜索的时候要注意避免重复遍历。我们可以把已经遍历过的陆地改成 2，这样遇到 2 我们就知道已经遍历过这个格子了，不进行重复遍历。
<a name="y1jpY"></a>
## 动画理解
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391565727-49a15ffd-89f9-4601-a58c-e06216c9401e.gif#averageHue=%23fdfdfd&from=url&id=j4z2S&originHeight=481&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="SRSEh"></a>
## 参考代码
C++ 代码：
```
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int res = 0;
        for (int r = 0; r < grid.size(); r++) {
            for (int c = 0; c < grid[0].size(); c++) {
                if (grid[r][c] == 1) {
                    int a = area(grid, r, c);
                    res = max(res, a);
                }
            }
        }
        return res;
    }
    
    int area(vector<vector<int>>& grid, int r, int c) {
        if (!(inArea(grid, r, c))) {
            return 0;
        }
        if (grid[r][c] != 1) {
            return 0;
        }
        grid[r][c] = 2;
        
        return 1
            + area(grid, r - 1, c)
            + area(grid, r + 1, c)
            + area(grid, r, c - 1)
            + area(grid, r, c + 1);
    }
    
    bool inArea(vector<vector<int>>& grid, int r, int c) {
        return 0 <= r && r < grid.size()
            && 0 <= c && c < grid[0].size();
    }
};
```
Java 代码：
```
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int res = 0;
        for (int r = 0; r < grid.length; r++) {
            for (int c = 0; c < grid[0].length; c++) {
                if (grid[r][c] == 1) {
                    int a = area(grid, r, c);
                    res = Math.max(res, a);
                }
            }
        }
        return res;
    }

    int area(int[][] grid, int r, int c) {
        if (!inArea(grid, r, c)) {
            return 0;
        }
        if (grid[r][c] != 1) {
            return 0;
        }
        grid[r][c] = 2;

        return 1 
            + area(grid, r - 1, c)
            + area(grid, r + 1, c)
            + area(grid, r, c - 1)
            + area(grid, r, c + 1);
    }

    boolean inArea(int[][] grid, int r, int c) {
        return 0 <= r && r < grid.length 
            && 0 <= c && c < grid[0].length;
    }
}
```
Python 代码：
```
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        res = 0
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == 1:
                    a = self.area(grid, r, c)
                    res = max(res, a)
        return res
    
    def area(self, grid: List[List[int]], r: int, c: int) -> int:
        if not self.inArea(grid, r, c):
            return 0
        if grid[r][c] != 1:
            return 0
        grid[r][c] = 2
        
        return 1 \
            + self.area(grid, r - 1, c) \
            + self.area(grid, r + 1, c) \
            + self.area(grid, r, c - 1) \
            + self.area(grid, r, c + 1)
            
    def inArea(self, grid: List[List[int]], r: int, c: int) -> bool:
        return 0 <= r < len(grid) and 0 <= c < len(grid[0])
```
<a name="GPmeM"></a>
## 复杂度分析
设网格的边长为 n，则时间复杂度为 O(n²)。
<a name="SUOyP"></a>
# #942 增减字符串匹配
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步个人博客：www.zhangxiaoshuai.fun<br />本题在leetcode中题目序号942，属于easy级别，目前通过率为71.4%
<a name="FwlzH"></a>
## 题目描述
```
给定只含 "I"（增大）或 "D"（减小）的字符串 S ，令 N = S.length。
返回 [0, 1, ..., N] 的任意排列 A 使得对于所有 i = 0, ..., N-1，都有：
    如果 S[i] == "I"，那么 A[i] < A[i+1]
    如果 S[i] == "D"，那么 A[i] > A[i+1]

示例 1：
输出："IDID"
输出：[0,4,1,3,2]

示例 2：
输出："III"
输出：[0,1,2,3]

示例 3：
输出："DDI"
输出：[3,2,0,1]

提示：
    1 <= S.length <= 10000
    S 只包含字符 "I" 或 "D"
```
<a name="qbIuS"></a>
## 题目分析
```
题目中的意思很明确，我们只要满足给出的两个条件即可。

1.假如字符串的长度为N，那么目标数组的长度就为N+1；

2.数组中的数字都是从0~N，且没有重复；

3.遇见‘I’，要增加；遇见‘D’要减少；
```
<a name="XwaQN"></a>
## GIF动画演示
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391699114-1f8feaa3-2726-424b-894b-2fb96ec6785d.gif#averageHue=%23fdfdfd&from=url&id=k7IJs&originHeight=480&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="CAVi0"></a>
## 代码
```java
//这里搬运下官方的解法
public int[] diStringMatch(String S) {
    int N = S.length();
    int lo = 0, hi = N;
    int[] ans = new int[N + 1];
    for (int i = 0; i < N; ++i) {
        if (S.charAt(i) == 'I')
            ans[i] = lo++;
        else
            ans[i] = hi--;
    }
    ans[N] = lo;
    return ans;
}
```
**虽然上述代码很简洁，好像已经不需要我们去实现什么；但是满足条件的序列并不止一种，官方的好像只能通过一种，下面的代码虽然有些冗余，但是得出的序列是满足题意要求的，但是并不能AC；**
<a name="uA5Tf"></a>
## 思路
```
(1)如果遇见的是‘I’，那么对应数组当前位置的数字要小于它右边的第一个数字
(2)如果遇见的是‘D’，那么对应数组当前位置的数字要大于它右边的第一个数字

首先对目标数组进行初始化，赋值0~N
我们开始遍历字符串，如果遇见‘I’就判断对应数组该位置上的数是否满足（1）号条件
如果满足，跳过本次循环；如果不满足，交换两个数字的位置；
对于‘D’，也是同样的思路；
```
<a name="WVLag"></a>
## GIF动画演示
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391699520-882e6b47-ad37-4e28-89de-b3c8334667cf.gif#averageHue=%23fefefe&from=url&id=bxygi&originHeight=480&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="FJrFd"></a>
## 代码
```java
public int[] diStringMatch(String S) {
    int[] res = new int[S.length()+1];
    String[] s = S.split("");
    for (int i = 0; i < res.length; i++) {
        res[i] = i;
    }
    for (int i = 0; i < s.length; i++) {
        if (s[i].equals("I")) {
            //判断指定位置的数字是否符合条件
            if (res[i] < res[i + 1]) {
                continue;
            } else {
                //交换两个数字的位置
                res[i]   = res[i] ^ res[i+1];
                res[i+1] = res[i] ^ res[i+1];
                res[i]   = res[i] ^ res[i+1];
            }
        } else {
            if (res[i] > res[i + 1]) {
                continue;
            } else {
                res[i]   = res[i] ^ res[i+1];
                res[i+1] = res[i] ^ res[i+1];
                res[i]   = res[i] ^ res[i+1];
            }
        }
    }
    return res;
}
```
<br />
<a name="It4i5"></a>
# #994 腐烂的橘子
**本文首发于公众号「图解面试算法」，是 **[**图解 LeetCode**](https://github.com/MisterBooo/LeetCodeAnimation)** 系列文章之一。**<br />**同步个人博客：www.zhangxiaoshuai.fun**<br />**本题在leetcode中题目序号994，属于medium级别，目前通过率为50.7%**<br />**题目描述：**
```
在给定的网格中，每个单元格可以有以下三个值之一：
	值0代表空单元格；
	值1代表新鲜橘子；
	值2代表腐烂的橘子。
每分钟，任何与腐烂的橘子（在4个正方向上）相邻的新鲜橘子都会腐烂。返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回-1。

示例1：
	输入：[[2,1,1],[1,1,0],[0,1,1]]
	输出：4

示例2：
	输入：[[2,1,1],[0,1,1],[1,0,1]]
	输出：-1
	解释：左下角的橘子（第2行，第0列）永远不会腐烂，因为腐烂只会发生在4个正向上。

示例3：
	输入：[[0,2]]
	输出：0
	解释：因为0分钟时已经没有新鲜橘子了，所以答案就是0。

提示：
	1<=grid.length<=10
	1<=grid[0].length<=10
	grid[i][j]仅为0、1或2
```
**由题意：只有腐烂的橘子才可以去污染它周围四个方向上存在的新鲜橘子，且它每一分钟只能污染一次，下一次，被它腐蚀的橘子再去腐蚀自己周边的新鲜橘子，每次只有被新腐蚀的橘子才能继续向外腐蚀（因为旧的腐烂的橘子已经被“包围”了）**<br />**这就很像一个人得了传染病，只要他遇见人就会将病传染给那个人，而被传染的又会去感染别的人（不同的是，这里的橘子的位置是固定的，无法移动）**<br />**思路是非常简单的，我们通过动态图直观理解下：**<br />![](../Animation/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%9001.gif#from=url&id=qfzvs&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />**既然理清了思路，那么我们来试试代码：<br />首先，我们需要知道初始状态下的单元格中有多少腐烂的橘子，并且要将它们的位置信息保存下来，我们可以用一个队列（先入先出）将（x，y）保存下来;然后我们开始遍历整个队列，每次弹出一个保存的位置信息，将这个位置周围的新鲜橘子全部腐蚀，并且将被腐蚀的橘子的位置信息存入队列中，在下次循环中从它们的位置上再“向外延伸”（注意：为了模拟同步，我们需要将每次存入队列中的所有位置都要在下一次全部取出来）；直到队列为空，循环结束，这个时候并不能说明整个单元格中已经不存在新鲜的橘子，因为可能存在下面这种情况：**<br />![](https://cdn.nlark.com/yuque/0/2023/png/35495747/1693391700991-3ccb0a5d-84b9-4c46-96ec-31a42c2d4e71.png#averageHue=%23fcaa02&from=url&id=E9iVR&originHeight=228&originWidth=226&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />**很明显，标红的区域（新鲜橘子）永远不能被腐蚀，因为它周围唯一的两个单元格是空的。**<br />**那么针对这种情况，我们在前面遍历统计腐烂橘子的时候可以顺便统计一下新鲜橘子的数量count，后面我们每腐蚀一个橘子就从count中减去1。最终循环结束的时候，我们只需要判断count是否大于0，若是，返回-1，否则返回轮数res。**

---

<a name="YsEoZ"></a>
## 代码
```java
public static int orangesRotting02(int[][] grid){
    int row = grid.length,col = grid[0].length;
    Queue<int[]> queue = new ArrayDeque();
    int count = 0;//统计新鲜橘子的数量
    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; j++) {
            if (grid[i][j] == 2) {
                queue.add(new int[]{i,j});
            }
            if (grid[i][j] == 1) {
                count++;
            }
        }
    }
    int res = 0;
    while (count > 0 && !queue.isEmpty()) {
        res++;
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            int[] temp = queue.poll();
            int r = temp[0],c = temp[1];//(x,y)
            //上
            if (r > 0 && grid[r-1][c] == 1) {
                grid[r-1][c] = 2;
                count--;
                queue.add(new int[]{r-1,c});
            }
            //下
            if (r < grid.length-1 && grid[r+1][c] == 1) {
                grid[r+1][c] = 2;
                count--;
                queue.add(new int[]{r+1,c});
            }
            //左
            if (c > 0 && grid[r][c-1] == 1) {
                grid[r][c-1] = 2;
                count--;
                queue.add(new int[]{r,c-1});
            }
            //右
            if (c < grid[0].length-1 && grid[r][c+1] == 1) {
                grid[r][c+1] = 2;
                count--;
                queue.add(new int[]{r,c+1});
            }
        }
    }
    if (count > 0) {
        return -1;
    }
    return res;
}
```
<a name="CWYrB"></a>
# #1054 距离相等的条形码
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步个人博客：www.zhangxiaoshuai.fun<br />**本题选自leetcode第1054号问题，medium级别，目前通过率33.3%**<br />**题目描述：**
```
在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。
请你重新排列这些条形码，使其中两个相邻的条形码不能相等。
你可以返回任何满足该要求的答案，此题保证存在答案。
示例 1：
输入：[1,1,1,2,2,2]
输出：[2,1,2,1,2,1]

示例 2：
输入：[1,1,1,1,2,2,3,3]
输出：[1,3,1,3,2,1,2,1]

提示：
    1 <= barcodes.length <= 10000
    1 <= barcodes[i] <= 10000
```
<a name="yNuSG"></a>
## 题目分析
```
1.首先我们需要将每个条形码和出现的次数作一记录，为了存取方便，这里使用数组（题目中已经给出了数组的最大和最小长度）进行操作;  
2.找出其中出现最多次数的条形码，拿到该barcode和count;  
3.先将出现次数最多的条形码存入目标数组中（偶数位或者奇数位），并对记录数组作一更新；
4.随后将剩余的barcode填充进目标数组中。
```
<a name="bHV7f"></a>
## GIF动画展示
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391702312-d18226c8-0efb-4edc-882c-abaeb3be13f8.gif#averageHue=%23fefefe&from=url&id=g73zm&originHeight=480&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="Xw8Iy"></a>
## 代码
```java
public static int[] rearrangeBarcodes(int[] barcodes){
    int[] address = new int[10001];
    for (int barcode : barcodes)
        address[barcode]++;
    // 找到出现次数最多的barcode
    int maxCode = 0, maxCount = 0;
    for (int i = 0; i < address.length; i++) {
        if (maxCount < address[i]) {
            maxCode = i;
            maxCount = address[i];
        }
    }
    int index = 0;
    // 先填充最大的那一位barcode
    for (; address[maxCode] > 0; index += 2) {
        barcodes[index] = maxCode;
        address[maxCode]--;
    }
    // 继续填充剩余的条形码
    for (int i = 1; i < address.length; i++) {
        while (address[i] > 0) {
	//偶数位填充完毕
            if (index >= barcodes.length) index = 1;
            barcodes[index] = i;
            address[i]--;
            index += 2;
        }
    }
    return barcodes;
}
```
<a name="D0DbJ"></a>
# #1137 第N个泰波那契数
本文首发于公众号「图解面试算法」，是 [图解 LeetCode](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />个人博客：www.zhangxiaoshuai.fun<br />**本题选自leetcode中第1137题，easy级别，目前通过率52.4%**
<a name="W2jjI"></a>
## 题目描述
```
泰波那契序列 Tn 定义如下： 
T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2
给你整数 n，请返回第 n 个泰波那契数 Tn 的值。

示例 1：
输入：n = 4
输出：4
解释：
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4

示例 2：
输入：n = 25
输出：1389537

提示：
    0 <= n <= 37
    答案保证是一个 32 位整数，即 answer <= 2^31 - 1。
```
<a name="Q9mSH"></a>
## 题目分析
要是之前有接触过斐波那契数列的话，这道题是非常容易有解决思路的。我们有以下三种方法（正经方法两种，哈哈哈）来解决该问题：
```
1.递归（但是leetcode中是无法AC的，超出时间限制，但是还是会将代码展示出来）
2.动态规划（这种题都是已知前面的来求得未知的，使用dp再合适不过）
3.暴力（抖机灵，看一乐就可以啦）
```
<a name="STzEZ"></a>
### GIF动画演示：
![](https://cdn.nlark.com/yuque/0/2023/gif/35495747/1693391703854-7a3434b7-1a14-4c0d-b9a1-e8a06afb16f3.gif#averageHue=%23fefefe&from=url&id=Vyy0E&originHeight=480&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="V2FtV"></a>
## 代码
<a name="QzOMp"></a>
### 递归版本：
```java
public int tribonacci(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return 1;
    }
    return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n -3);
}
```
<a name="ds4Fq"></a>
### 动态规划
```java
int[] dp = new int[38];
public int tribonacci(int n) {
    if (dp[n] != 0) {
        return dp[n];
    }
    if (n == 0) {
        return 0;
    } else if (n == 1 || n == 2) {
        return 1;
    } else {
        int res = tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);
        dp[n] = res;
        return res;
    }
}
```
<a name="CuO7p"></a>
### 暴力法（十分暴力，哈哈哈哈……）
```java
public int tribonacci(int n) {
    int[] Ts = {0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 				10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 					2555757, 4700770, 8646064, 15902591, 29249425, 53798080, 98950096, 						181997601, 334745777, 615693474, 1132436852, 2082876103};
    return Ts[n];
}
```
<a name="QbaiT"></a>
# #1281 整数的各位积和之差
<a name="DQGns"></a>
## 题目描述
给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。<br />示例 1:
```
输入：n = 234
输出：15 
解释：
各位数之积 = 2 * 3 * 4 = 24 
各位数之和 = 2 + 3 + 4 = 9 
结果 = 24 - 9 = 15
```
示例 2:
```
输入：n = 4421
输出：21
解释： 
各位数之积 = 4 * 4 * 2 * 1 = 32 
各位数之和 = 4 + 4 + 2 + 1 = 11 
结果 = 32 - 11 = 21
```
**提示：**
```
1 <= n <= 10^5
```
<a name="OaBiB"></a>
## 题目解析
1、通过取模运算遍历数字每一位<br />2、通过两个变量在遍历过程中分别记录求和与求积
<a name="gLt84"></a>
## 动画理解
[Animation.mp4](https://inspidea.yuque.com/attachments/yuque/0/2023/mp4/35495747/1693726487780-196c5340-5362-4a9d-81ca-30e0a2e0fdef.mp4)
<a name="r8iA5"></a>
## 参考代码
```java
class Solution {
    public int subtractProductAndSum(int n) {
        int addResult = 0, mulResult = 1;
        while (n > 0) {
            int num = n % 10;
            n /= 10;
            addResult += num;
            mulResult *= num;
        }
        return mulResult - addResult;
    }
}
```
<a name="s4QYz"></a>
## 复杂度分析
时间复杂度：O(logN)<br />空间复杂度：O(1)

<a name="7477409c"></a>
# #1351 统计有序矩阵中的负数

本文首发于公众号「图解面试算法」，是 [图解 LeetCode ](https://github.com/MisterBooo/LeetCodeAnimation) 系列文章之一。<br />同步博客：[https://www.algomooc.com](https://www.algomooc.com)<br />题目来源于 LeetCode 上 1531 题。
<a name="5f5f8ea7"></a>
## 题目

给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。<br />请你统计并返回 grid 中 负数 的数目。

示例 1：

```
输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
输出：8
解释：矩阵中共有 8 个负数。
```

示例 2：

```
输入：grid = [[3,2],[1,0]]
输出：0
```

示例 3：

```
输入：grid = [[1,-1],[-1,-1]]
输出：3
```

示例 4：

```
输入：grid = [[-1]]
输出：1
```

提示：

m == grid.length

n == grid[i].length

1 <= m, n <= 100

-100 <= grid[i][j] <= 100

<a name="V02Zy"></a>
## 题目解析

首先审题，在一个矩阵中找出所有负数，这个很好理解，小白一开始做，可以直接暴力遍历，然后依次判断当前值是不是小于0，小于0计数加一。如果是面试的话，面试官一般都会问还没有其他办法，这时候你肯定要说怎么没有，所以我们做一道题不能仅仅限于做出了，要从多方面下手，使得复杂度越小越好。

所以我们要仔细审题，我们看到题目中有这样一句描述**矩阵中的元素无论是按行还是按列，都以非递增顺序排列**，这句话信息量很大，你品，你仔细品。

首先我们可以理解到的是：一个 m * n 的矩阵 grid，grid[i][j]<0的话，i那一行第j个到数组最后一个都是小于0，第i行开始，j到后面的列都是小于0

我们举个例子

```
[
	[4,   3,  -1,  -1],
	[3,   2,  -1,  -1],
	[1,   1,  -1,  -2],
	[-1, -1,  -2,  -3]
]
```

可以看到第一行第三列的值小于0，那么第一行及后面几行的第三列和后面的列的值都小于0。

所以我们可以进行倒序遍历，找到负数的左边界，也就是左边第一个为负数的值。

i为行遍历的指针，j为列遍历指针，count为负数的个数，len1为**当前行**的个数，len2为**当前列**的个数

```
初始值
let count = 0；
let len1 = grid.length
let len2 = grid[0].length
let i = 0；
let j = len2 - 1；
```

然后我们倒序遍历列，行还是正序遍历，以上面的例子来说，我们找到的第一个负数是grid[0][2]，然后我们能确定的负数就有如下，所以我们count就可以加上(len1 - i -1) * (len2 - j )

```
[
	[ -1,  -1],
	[ -1,  -1],
	[ -1,  -2],
	[ -2,  -3]
]
```

然后我们遍历的矩阵就变成如下，然后重复上面操作。

```
[
	[3,   2],
	[1,   1],
	[-1, -1]
]
```

所以我们每次遍历后要更新len1和len2，具体看代码和动画。

<a name="evQb9"></a>
## 动画理解
[1351.mp4](https://inspidea.yuque.com/attachments/yuque/0/2023/mp4/35495747/1693726638979-1a689d5a-2532-432f-8131-13b3c0b1d260.mp4?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Finspidea.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fmp4%2F35495747%2F1693726638979-1a689d5a-2532-432f-8131-13b3c0b1d260.mp4%22%2C%22name%22%3A%221351.mp4%22%2C%22size%22%3A8472588%2C%22ext%22%3A%22mp4%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u50f9a651-6acb-4141-b450-ac6ba0fbb18%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22video%2Fmp4%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u0dd79784%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D)
<a name="36967e2c"></a>
## 参考代码

```javascript
/**
 * @param {number[][]} arr
 * @return {number}
 */
var countNegatives = function(arr) {
    if (arr.length <= 0 ) {return 0}
    let count = 0;
    let len1 = arr.length;
    let len2 = arr[0].length;
    let i = 0;
    let j = len2 - 1;
    while(i < len1) {
        while(j >= 0) {
            if (arr[i][j] < 0) {
                if (j==0){
                    count += (len2 * (len1 - i))
                    len2 = 0
                    break
                }
                 j--
            }else {
               if (len2 == j + 1) {
                    break
                }
                count += ((len2 - j - 1) * (len1 - i))
                len2 = j + 1
                break
            }
        }
        i++
        j= len2 - 1
    }
    return count
};
```

<a name="mMaNr"></a>
## 复杂度分析

时间复杂度： O(mn)。 因为如果矩阵中所有的数都为正数，那么要遍历整个矩阵，所以时间复杂度是O(mn)。

空间复杂度：O(1)。

![](../../Pictures/qrcode.jpg#id=UeqO4&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
<a name="4a1fd065"></a>
# 
<br />

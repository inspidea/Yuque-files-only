<a name="cb022f6a"></a>
## Data Structure & Algorithm
| **黑马程序员课程笔记摘录** |
| --- |
| [02_算法分析.pdf](https://inspidea.yuque.com/attachments/yuque/0/2023/pdf/35495747/1690796588074-33c3bb7e-414c-4b7f-a858-23c4502bd6e3.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Finspidea.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F35495747%2F1690796588074-33c3bb7e-414c-4b7f-a858-23c4502bd6e3.pdf%22%2C%22name%22%3A%2202_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.pdf%22%2C%22size%22%3A821299%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u4266f912-cf46-4c61-8f32-c72949e5578%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u2097b890%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D) |
| [03_排序.pdf](https://inspidea.yuque.com/attachments/yuque/0/2023/pdf/35495747/1690796588240-52dc02c9-093e-4652-9b3d-0fcd7b5a0d44.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Finspidea.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F35495747%2F1690796588240-52dc02c9-093e-4652-9b3d-0fcd7b5a0d44.pdf%22%2C%22name%22%3A%2203_%E6%8E%92%E5%BA%8F.pdf%22%2C%22size%22%3A1323510%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u1c4b73f4-8bbf-4bb8-a74a-daf7f1a14ac%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u8c78ab5d%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D) |
| [04_线性表.pdf](https://inspidea.yuque.com/attachments/yuque/0/2023/pdf/35495747/1690796588349-f78101a1-ed52-405a-ba93-eaaad8fae71c.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Finspidea.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F35495747%2F1690796588349-f78101a1-ed52-405a-ba93-eaaad8fae71c.pdf%22%2C%22name%22%3A%2204_%E7%BA%BF%E6%80%A7%E8%A1%A8.pdf%22%2C%22size%22%3A2255155%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u3fa7c590-68d1-4f0d-b11f-c6eaf58d8aa%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u247b05ce%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D) |
| [05_符号表.pdf](https://inspidea.yuque.com/attachments/yuque/0/2023/pdf/35495747/1690796588485-c55a604f-70a7-411c-9a45-24c014f42f14.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Finspidea.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F35495747%2F1690796588485-c55a604f-70a7-411c-9a45-24c014f42f14.pdf%22%2C%22name%22%3A%2205_%E7%AC%A6%E5%8F%B7%E8%A1%A8.pdf%22%2C%22size%22%3A414418%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u579cd8db-4814-4d33-bbc5-c26215ea2ff%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u8abce2b6%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D) |
| [06_树的入门.pdf](https://inspidea.yuque.com/attachments/yuque/0/2023/pdf/35495747/1690796588578-e46699ea-a15b-41c1-bdfa-a6f8661fa0fe.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Finspidea.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F35495747%2F1690796588578-e46699ea-a15b-41c1-bdfa-a6f8661fa0fe.pdf%22%2C%22name%22%3A%2206_%E6%A0%91%E7%9A%84%E5%85%A5%E9%97%A8.pdf%22%2C%22size%22%3A1058871%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u500ce80c-dd20-4288-ae26-672d3bd0151%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22ucdb4bf25%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D) |
| [07_堆.pdf](https://inspidea.yuque.com/attachments/yuque/0/2023/pdf/35495747/1690796588717-303b26e6-d9c8-4788-a2e1-43716fdb6488.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Finspidea.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F35495747%2F1690796588717-303b26e6-d9c8-4788-a2e1-43716fdb6488.pdf%22%2C%22name%22%3A%2207_%E5%A0%86.pdf%22%2C%22size%22%3A1016013%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u1dd3fb8c-a429-43f4-81f2-f77e6c2e656%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u0118990c%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D) |
| [08_优先队列.pdf](https://inspidea.yuque.com/attachments/yuque/0/2023/pdf/35495747/1690796588849-da675651-650f-4b1c-94cf-050195734be7.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Finspidea.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F35495747%2F1690796588849-da675651-650f-4b1c-94cf-050195734be7.pdf%22%2C%22name%22%3A%2208_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.pdf%22%2C%22size%22%3A648879%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22uaf099728-c0be-4159-b718-c86cc9d3105%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22ud58329b7%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D) |
| [09_树的进阶.pdf](https://inspidea.yuque.com/attachments/yuque/0/2023/pdf/35495747/1690796588986-5b93be20-4f54-4622-a85a-7497be44f715.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Finspidea.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F35495747%2F1690796588986-5b93be20-4f54-4622-a85a-7497be44f715.pdf%22%2C%22name%22%3A%2209_%E6%A0%91%E7%9A%84%E8%BF%9B%E9%98%B6.pdf%22%2C%22size%22%3A1608612%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22uef39e48e-e88a-4fd6-ae8b-575e305b002%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u6d6c0bc2%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D) |
| [10_并查集.pdf](https://inspidea.yuque.com/attachments/yuque/0/2023/pdf/35495747/1690796589134-7da9d350-651e-4475-a09b-17a6d68e00fc.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Finspidea.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F35495747%2F1690796589134-7da9d350-651e-4475-a09b-17a6d68e00fc.pdf%22%2C%22name%22%3A%2210_%E5%B9%B6%E6%9F%A5%E9%9B%86.pdf%22%2C%22size%22%3A686489%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u7dcbbe3f-22ca-4956-985a-c8687ae4aa1%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u927e253d%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D) |
| [11_图的入门.pdf](https://inspidea.yuque.com/attachments/yuque/0/2023/pdf/35495747/1690796589245-075c84be-8fa3-4d3a-83c5-55bcf24c7a54.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Finspidea.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F35495747%2F1690796589245-075c84be-8fa3-4d3a-83c5-55bcf24c7a54.pdf%22%2C%22name%22%3A%2211_%E5%9B%BE%E7%9A%84%E5%85%A5%E9%97%A8.pdf%22%2C%22size%22%3A1173220%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22ue7726916-f12d-42b5-9ea9-6b90b2f3ca5%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u2fb556b6%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D) |
| [12_图的进阶.pdf](https://inspidea.yuque.com/attachments/yuque/0/2023/pdf/35495747/1690796589398-46eded71-8dd4-4844-8595-87e8b9e8bd31.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Finspidea.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F35495747%2F1690796589398-46eded71-8dd4-4844-8595-87e8b9e8bd31.pdf%22%2C%22name%22%3A%2212_%E5%9B%BE%E7%9A%84%E8%BF%9B%E9%98%B6.pdf%22%2C%22size%22%3A1779976%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u74a60419-a802-44b9-ad66-322730454fa%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u4bb4e5a5%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D) |

<a name="47d58b40"></a>
### 01 Analysis

把**核心操作的次数**和**输入规模**关联起来。

```java
system.currentTimeMillis()
```

<a name="cae301e1"></a>
#### 1. 算法的时间复杂度分析
<a name="802837a1"></a>
##### 1.1 算法的时间复杂度

函数调用次数规则：

1. 算法函数中的常数可以忽略；
2. 算法函数中最高次幂的常数因子可以忽略；
3. 算法函数中最高次幂越小，算法效率越高；

<a name="842a3097"></a>
##### 1.2 Big-Oh

规则：

1. 用常数1取代运行时间中的所有加法常数；
2. 在修改后的运行次数中，只保留高阶项；
3. 如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数；

```latex
算法1：3次 -> O(1) - 常数阶
算法2：n+3次 -> O(n) - 线性阶
算法3：n^2+2次 -> O(n^2) - 平方阶
算法4：log(2)n次 -> O(logn) - 对数阶 （忽略底数） 

O(1) < O(logn^(a)) < [O(n^0.5)] < O(n) < O(nlogn) < O(n^a) < O(2^n)
```

一个程序中含有**多个算法**，则分析每个算法的时间复杂度并**求和**

```latex
Theorem:  If g(n) is O(f(n)) , then for any constant  c >0  g(n) is also O(c f(n)) 
Theorem:  O(f(n) + g(n)) = O(max(f(n), g(n)))
```

![](https://i.loli.net/2021/02/27/emOEh8gNjA2TIMH.png#id=A2AbW&originHeight=660&originWidth=953&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=FJvxU&originHeight=660&originWidth=953&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)![](https://i.loli.net/2021/02/27/qpbn8wFATKhfNce.png#id=B0RgF&originHeight=620&originWidth=940&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=TSURX&originHeight=620&originWidth=940&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/02/27/jZx1KhNU4ksOVfY.png#id=YI7Ho&originHeight=709&originWidth=861&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=r9jd0&originHeight=709&originWidth=861&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/02/27/hM5vmHuTtYjVXaK.png#id=MMFOm&originHeight=638&originWidth=904&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=bNSwj&originHeight=638&originWidth=904&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="54356cda"></a>
##### 1.3 最坏情况

有一个存储了n个随机数字的数组，从中查找出指定数字：

```java
public int search(int num){
    int[] arr={11,10,8,9,7,22,23,0};
    for (int i = 0; i < arr.length; i++){
        if (num == arr[i]){
            return i
        }
    }
    return -1
}
```

最好情况：查找的第一个数字就是期望的数字，那么算法时间复杂度为O(1)；

**_最坏情况_：查找到最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n);

**平均情况**：任何数字查找的平均成本是O(n/2);



<a name="e0a83fd8"></a>
##### 时间复杂度举例分析(PNB1)

1. **常数阶O(1)**

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：

```latex
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

1. **线性阶O(n)**

这个在最开始的代码示例中就讲解过了，如：

```latex
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

1. **对数阶O(logN)**

还是先来看代码：

```latex
int i = 1;
while(i<n)
{
    i = i * 2;
}
```

从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n<br />也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：**O(logn)**

1. **线性对数阶O(nlogN)**

线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。

就拿上面的代码加一点修改来举例：

```latex
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

1. **平方阶O(n²)**

平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。<br />举例：

```latex
for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)<br />如果将其中一层循环的n改成m，即：

```latex
for(x=1; i<=m; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

那它的时间复杂度就变成了 O(m*n)

1. **立方阶O(n³)**、**K次方阶O(n^k)**

参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。

除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。



<a name="f3b6135a"></a>
#### 2. 算法的空间复杂度分析



<a name="288863a6"></a>
##### 2.1 java中常见的内存占用
| 数据类型 | 内存占用字节数 |
| --- | --- |
| byte | 1 |
| short | 2 |
| int | 4 |
| long | 8 |
| float | 4 |
| double | 8 |
| Boolean | 1 |
| char | 2 |


计算机访问内存的方式是一次一个字节

1. 一个引用（机器地址）需要8个字节表示：<br />例： Date date = new Date();
2. 创建一个对象，比如new Date()，除了Date对象内部存储的数据占用的内存，每个对象的自身开销是16个字节；
3. 一般内存的使用如不足8个字节，则自动填充为8字节；



<a name="c4312bd8"></a>
##### 2.2 算法的空间复杂度

8个字节 -> O(8) -> O(1)

O(4n+28) -> O(n)



<a name="093c9838"></a>
#### 3. 渐进性分析

```latex
对于n，f(n)≥0，g(n)≥0
渐进上界记号O：O(g(n)) = {f(n)|存在常数c和n0使得对所有n≥n0，有0< f(n) <cg(n) };
渐进下界记号Ω：Ω(g(n)) = {f(n)|存在常数c和n0使得对所有n≥n0，有0< cg(n) <f(n) };
渐进近界记号Θ：Θ(g(n)) = {f(n)|存在常数c1，c2和n0使得对所有n≥n0，有c1g(n) < f(n) < c2g(n) };
如果f(n)是集合O(g(n))中的成员，则f(n)属于O(g(n)).

f(n) = O(g(n)) -> a≤b
f(n) = Ω(g(n)) -> a≥b
f(n) = Θ(g(n)) -> a=b
f(n) = o(g(n)) -> a<b
f(n) = ω(g(n)) -> a>b
```

![](https://i.loli.net/2021/02/27/tjAVUXqLG3WR5Nl.png#id=DtEGz&originHeight=795&originWidth=1611&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=v8VBp&originHeight=795&originWidth=1611&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/02/27/xQR4NnAP1o78eqW.png#id=vYnzC&originHeight=616&originWidth=2069&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=EdwyA&originHeight=616&originWidth=2069&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="cf0274f0"></a>
### 02 - 1 Arrays*



<a name="Keywords"></a>
##### Keywords

Numbered collection of **_variables (cell)_** of the **_same type_**;   **_static_** structure;   direct acesss;   **_fixed length - capacity_**;  **_element_**; **insertion and deletion occur with moving elements**

Declare 1:

```java
elementType[] arrayName = {initialValue0,...,initialValue(N-1)}
```

Declare 2:

```java
new elementType[length]
```

**[Array]**  Methods:

```java
/**Implementation**/
public class ArrayType {
	protected Element[] array;
	public ArrayType(Element[] in_array) { …}
	public Element setElement(int index, Element e) {…}
	public Element getElement(int index) {…}
	public Element remove(int index ) {…}
	public void addElement(int index, Element e) {…}
	public int size() {…}
}

/**Operations**/
void      addElement(int index, Element e);  //insert
Element   setElement(int index, Element e);
Element   getElement(int index);
Element   remove(int index);
int       size();

/**Insertion**/
public void addElement(int index, Element e) {
	// Shift everything backward
	for (int i=array.length-1; i>index; --i ) {
	array[i] = array[i-1];
	}
	array[index] = e;
	return;
}

/**Removal**/
public Element remove(int index ) {
	Element retVal = array[index];
	// Shift everything forward
	for ( int i=index; i<array.length-1; ++i ) {
	array[i] = array[i+1];
	}
	array[array.length-1] = null;
	return retVal;
}

/**Using Array Type**/
ArrayType at = new ArrayType(new Element[10]);
at.setElement(0, new Element("CSI1120", 2019));
at.setElement(1, new Element("CSI1121", 2019));
at.setElement(2, new Element("CSI1110", 2019));
at.addElement(0, new Element("CSI2110", 2020));
for ( int i=0; i<at.size(); ++i ) { // print all elements
	Element e = at.getElement(i);
	if ( e == null ) break;
		System.out.println( e );
	}
// remove first element
at.remove(0);

/**Using Object**/
public class ArrayType {
	protected Object[] array;
	public ArrayTypeObject(Object[] in_array) {…}
	public Object setElement(int index, Object e) {…}
	public Object getElement(int index) {…}
	public Object remove(int index ) {…}
	public void addElement(int index, Object e) {…}
	public int size() {…}
}

/**Exmaple**/

// A game entry stores the name of a player and her best score so far in a game:
public class GameEntry{
    private String name;  //name of the person earning this score
    private int score;    //the score value
    /**Constructs a game entry with given parameters..*/
    public GameEntry(String n, int s){
        name = n;
        score = s;
    }
    /**Returns the name field.*/
    public String getName() {return name;}
    /**Returns the score field*/
    public int getScore() {return score;}
    /**Returns a string representation of this entry.*/
    public String toString() {
        return "(" + name + "," + score +")";
    }
}

// Keep track of players and their best scores in an array, board **The elements of board are objects of class GameEntry; **n Array board is sorted by score:

/**Class for storing high scores in an arry in decreasing order*/
public class Scoreboard{
    private int numEntries = 0;  //number of actual entries
    private GameEntry[] board;   //array of game entries(name & scores)
    /** Constructs an empty scorebard with the given capacity...*/
    public Scoreboard(int capacity){
        board = new GameEntry[capacity];
    }
    
    public void add(GameEntry e){
        int newScore = e.getScore();
        // is the new entry e really a high scores?
        if (numEntries < board.length || newScore > board[numEntries] - 1.getScore()){
            if (numEntries < board.length);       //no score drops
                numEntries++;          //so overall number increases
     // shift any lower scores rightward to make room from the new entry
            int j = numEntries - 1;
            while (j > 0 && board[j-1].getScore() < newScore){
                board[j] = board[j-1];      //shift entry from j-1 to j
                j--;                        //and decrement j
            }
            board[j] = e;                   //when done, add new entry
        }
    }
    
    /**Remove and return the high score at index i.*/
    public GameEntry remove(int i) throws IndexOutOfBoundsExceptions{
        if (i < 0 || >= numEntries){
            throw new IndexOutOfBoundsExceptions("Invalid index" + i)；}
        GameEntry temp = board[i];    //save the object to be removed
        for (int j = i; j < numEntries - 1; j++){ //count up from i
            board[j] = board[j+1];    //move one cell to the left
            board[numEntries - 1] = null;  //null out the old last score
            numEntries--;
            return temp;              //return the removed object
        }    
    }
}
```



<a name="fb34a7e7"></a>
### 02 - 2 Linked Structures*



<a name="Keyswords"></a>
##### Keyswords

**_dynamic_** structure;    sequential access;    **insertion and deletion occur without moving elements**



<a name="4fded1d9"></a>
#### Single Linked Lists

Node v: Object element, Node next

**[Single Linked List]** Methods:

```java
void    setElement(Object e);
void    SetNext(Node newNext);
Object  getElement();
Node    getNext()
    
/**A Nested Node Class**/
public class SinglyLinkedList<E>{
    //------------nested Node class-----------
    private static class Node<E>{
        private E element; //reference to the element stored at this node
        private Node<E> next;    //ref to the subsequent node in the list
        public Node(E e, Node<E> n){
            element = e;
            next = n;
        }
        public E getElement() {return element;}
        public Node<E> getNext() {return next;}
        public void setNext(Node<E> n) {next = n;}
    }//-----------end of nested Node class---------
    
    //instance variables of the SinglyLinkedList
    private Node<E> head = null;  //head node of the list
    private Node<E> tail = null;  //last node of the list
    private int size = 0;         //number of nodes in the list
    public SinglyLinkedList() {}  //constructs an initially empty list
    
/**access methods*/
    public int size() { return size;}
    public boolean isEmpty() { return size == 0;}
    public E first() {           //returns(not remove) the first element
        if (isEmpty()) return null;{
        	return head.getElement();
        }
    }
    public E last() {            //returns(not remove) the last element
                if (isEmpty()) return null;{
        	return tail.getElement();
        }
    }
    
/**Java Methods**/
    public void addFirst(E e){ //adds element e to the front of the list
        head = new Node<>(e,head);    //creat and link a new node
        if (size == 0){
            tail = head;     //special case: new node becomes tail also
        }
        size++
    }
    
    public void addLast(E e){  //adds element e to the end of the list
        Node<E> newest = new Node<>(e, null);  //node will be the tail
        if (isEmpty()){
            head = newest;     //special case: previously empty list
        }
        else {
            tail.setNext(newest);   //new node after existing tail
        }
        tail = neweast;            //new node becomes the tail
        size++
    }
    
    public E removeFirst(){      //removes and returns the first element
        if (isEmpty()) return null;  //nothing to remove
        E answer = head.getElement();
        head = head.getNext();//become null if list had only 1 node
        size--；
        if (size == 0){
                tail = null;   //special case as list is now empty
        }
        return answer;
    }
}
```



<a name="9cea5fd4"></a>
#### Double Linked Lists

**[Double Linked List]** Methods:

```java
/** A basic doubly linked list implementation.*/
public class DoublyLinkedList<E>{
    //------------nested Node class-----------
    private static class Node<E>{
        private E element; //reference to the element stored at this node
        private Node<E> prev;    //ref to the previous node in the list
        private Node<E> next;    //ref to the subsequent node in the list
        public Node(E e, Node<E> p,Node<E> n){
            element = e;
            prev = p;
            next = n;
        }
        public E getElement() {return element;}
        public Node<E> getPrev() {return prev;}
        public Node<E> getNext() {return next;}
        public void setPrev(Node<E> n) {prev = p;}
        public void setNext(Node<E> n) {next = n;}
    }//-----------end of nested Node class---------
    
    //instance variables of the DoublyLinkedList
    private Node<E> header;       //header sentinel
    private Node<E> tailer;       //trailer sentinel
    private int size = 0;         //number of nodes in the list
    /**constructs a new empty list*/
    public DoublyLinkedList() {
        header = new Node<>(null, null, null);  //create header
        trailer = new Node<>(null ,header, null); //preceded by header
        header.setNext(trailer)    //header is followed by trailer
    }  
    
/**access methods in Java*/
    public int size() { return size;}
    public boolean isEmpty() { return size == 0;}
    public E first() {           //returns(not remove) the first element
        if (isEmpty()) return null;
        //first element is beyond header
        return header.getNext().getElement(); 
    }
    public E last() {            //returns(not remove) the last element
        if (isEmpty()) return null;
        //last element is before trailer
        return tailer.getPrev().getElement(); 
    }
    
/**public update methos in Java*/
    //Adds element e to the front of the list.
    public void addFirst(E e){
        addBetween(e, header, header.getNext()); //place after header
    }
    
    //Adds elemnet e to the end of the list.
    public void addLast(E e){
        addBetween(e, trailer.getPrev(), trailer); //place before header
    }
    
    //Removes and returns the first element of the lists.
    public E removeFirst(){
        if (isEmpty()) return null;
        return remove(header.getNext());//first element is beyond header
    }
    
    //Removes and returns the last element of the lists.
    public E removeLast(){
        if (isEmpty()) return null;
        return remove(trailer.getPrev());//last element is before trailer
    }
    
    //Adds elements e to the linked list in between the given nodes.
    private void addBetween(E e, Node<E> predecessor, Node<E> successor){
        // create and link a new node
        Node<E> newest = new Node<>(e, predecessor, successor);
        predecessor,setNext(newest);
        successor.setPrev(newest);
        size++;
    }
    
    //Removes the given node from the list and returns its element.
    private E remove(Node<E> node){
        Node<E> predecessor = node.getPrev();
        Node<E> successor = node.getNext();
        predecessor.setNext(successor);
        successor.setPrev(predecessor);
        size--;
        return node.getElement();
    }
}//------------end of Doubly LinkedList class
```



<a name="21fe8789"></a>
### 03 Abstract Data Types



<a name="Keywords-1"></a>
##### Keywords

abstraction; data structure; The **ADT** specifies: **what can be stored** in the ADT; **what operations** can be done on/by the ADT



<a name="7fb85176"></a>
#### ADT Stack



<a name="Keywords-2"></a>
##### Keywords

Implementation with Arrays; Implementation with Singly Linked List

**insert(add) and removing(delete);** **last-in-first-out/LIFO**;



<a name="d7a2277c"></a>
##### Main methods

```java
• Main methods:
– push(o): Inserts object o onto top of stack
– pop(): Removes the top object of stack and returns it; 
             //if the stack is empty, an error occurs
• Support methods:
– size(): Returns the number of objects in stack
– isEmpty(): Return a boolean indicating if stack is empty.
– top(): Return the top object of the stack, without 
             //removing it; if the stack is empty, an error occurs.
```



<a name="e72df07a"></a>
##### Postfix notation

```
Evaluation of arithmetic expressions (Postfix notation)
    Infix         |       Postfix
  [A operator B   |    A B operator]
    A + B                   A B +
     a+b                    a b +
  (x – y + z)             x y – z +
(x – y – z)/(u + v)    x y – z – u v + /

x: push(x)
y: push(y)
– : pop() (we get y)       
    pop() (we get x)    // x - y =t
push(t)               
z: push(z)
– : pop() (we get z)
    pop() (we get t)    // t - z =t'
push(t')               
u: push(u)
v: push(v)
+ : pop() (we get u)
    pop() (we get v)     // u + v =t"
/ : pop() (we get t')
         Result = t'/t"
```



<a name="7b691003"></a>
##### Implementing a Stack with an Array

```java
/** The stack consists of an N-element array S and an integer variable 
t, the index of the top element in array S.*/  (pseudocode)
Algorithm size():  return t +1
Algorithm isEmpty():  return (t < 0)
Algorithm top():
 	if isEmpty() then
    	  ERROR
	return S[t]
Algorithm push(obj):
    if size() = N then 
    ERROR
    t ← t + 1
	S[t] ← obj
Algorithm pop():
	if isEmpty() then 
	ERROR
	e ← S[t]
	S[t] ← null
	t ← t-1
	return e

//Performance
Time: O(1); Space: O(n);
```



<a name="5d34df3f"></a>
##### Implementing a Stack with a Linked List

![](https://i.loli.net/2021/02/27/IUKTGPWcCDAYLvb.png#id=ACdQT&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=U540K&originHeight=196&originWidth=731&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/02/27/cAqlNS163bzT8PV.png#id=dsByn&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=NXK7o&originHeight=241&originWidth=810&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```java
/**Singly linked list plus a variable containing the 
current size of the list*/ (pseudocode)
Node:
	node.item
	node.next

Algorithm push(obj):
	n ← new Node
	n.item ← obj
	n.next ← top
	top ← n
	size++
    
Algorithm pop():
	if isEmpty() then 
	ERROR
	temp ← top.item
	top ← top.next
	size- -
	return temp
        
//Performance
Time: O(1); Space: Variable
```



<a name="678593b6"></a>
#### ADT Queue



<a name="Keywords-3"></a>
##### Keywords

**first-in-first-out (FIFO)**; The elements **can be inserted all together**, but only the element which **stayed longest**  time in the queue can be out. •Elements are inserted at the **rear (enqueued)** and removed from the **front (dequeued)**； Implementation with Arrays; Implementation with Singly Linked List



<a name="c3f057bd"></a>
##### Main Methods

```java
• Fundamental methods:
enqueue(o): Insert object o at the rear of the queue
dequeue(): Remove the object from the front of the queue and return it; //an error occurs if the queue is empty
• Support methods:
size(): Return the number of objects in the queue
isEmpty(): Return a boolean value that indicates whether the queue is empty
front(): Return, but do not remove, the front object in the queue; 
//an error occurs if the queue is empty
```



<a name="e3f4efc0"></a>
##### Implementing a Queue with an Array

![](https://i.loli.net/2021/02/27/hWEpIL4cmF6yZs8.png#id=dgvrv&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=oB6ww&originHeight=316&originWidth=900&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```java
Remove: Front = (Front+1)       mod n //(mod: modulo模除, 取余数)
Insert: Rear = (Rear+1)         mod n
• Array in a circular fashion ( “wrapped around”)
• Size ***fixed*** at the beginning 
•The queue consists of an ***N-element (size = N)*** array Q and 
***two integer variables***:
-f, index of the front element
-r, index of the element after the rear one
    
Algorithm size():
	return (N - f + r) mod N
Algorithm isEmpty():
	return (f = r)
Algorithm front():
	if isEmpty() then
		ERROR
	return Q[f]
Algorithm dequeue():
	if isEmpty() then
		ERROR
	temp ← Q[f]
	Q[f] ← null
	f ← (f + 1) mod N
	return temp
Algorithm enqueue(o):
	if size = N - 1 then
		ERROR
	Q[r] ← o
        
//Performance
Time: O(1); Space: O(N)
```



<a name="4bbcbd39"></a>
##### Implementing a Queue with a Singly  Linked List

Nodes connected in singly linked list We keep a pointer to the head and one to the tail



<a name="c3f057bd-1"></a>
##### Main Methods

```java
//As the rules of Single Linked List

//Performance
Time: O(1); Space: Variable;
```



<a name="19afa43a"></a>
#### ADT Double-Ended Queues (Deque) -- More General



<a name="Keywords-4"></a>
##### Keywords

A deque, supports insertion and deletion **from the front and  back.**



<a name="c3f057bd-2"></a>
##### Main Methods

```java
Main methods:
insertFirst(e): Insert e at the beginning of deque.
insertLast(e): Insert e at end of deque
removeFirst(): Removes and returns first element
removeLast(): Removes and returns last element
Support methods:
first()
last()
size()
isEmpty()
```



<a name="072b0e6e"></a>
##### Implement Stacks and Queues with Deques

Stakcs with Deques

```
Stakcs with Deques:
Stack Method   Deque Implementation
size();        size();
isEmpty();     isEmpty();
top();         last();
push(e);       insertLast(e);
pop();         removeLast();
```

Queues with Deques

```
Queues with Deques:
Queue Method   Deque Implementation
size();        size();
isEmpty();     isEmpty();
front();       first());
enqueue();     insertLast(e);
dequeue();     removeFirst();
```



<a name="fa361363"></a>
##### Implementation with Doubly Linked List



<a name="178482e3"></a>
##### Specialized Methods (for Deque with DLL)

```java
//A node of a doubly linked list has a next and a prev link.
•setElement(Object e)
•setNext(Object newNext)
•setPrev(Object newPrev)
•getElement()
•getNext()
•getPrev()
```



<a name="43317442"></a>
##### To overcome the  limitations of Array based Stacks and Queues



<a name="7986feb3"></a>
###### A Growable Array-Based Stack

Two strategies:

**– tight strategy (add a constant): f(N) = N + c**  ---------O(N^2)

**– growth strategy (double up): f(N) = 2N** -----------------**O(N)√**



<a name="b8a6cc51"></a>
###### Linear Algorithm

```java
/** Each index of the array
– Is pushed into the stack exactly one 
– Is popped from the stack at most once
• The statements in the while-loop are executed at most n times 
• Algorithm spans2 runs in O(n) time*/ (pseudocode)
Algorithm computeSpans2(P):
//Input: an n-element array P of numbers representing stock prices
//Output: an n-element array S of numbers such that S[i] is the span of the stock on day i, Let D be an empty stack;
for i ←0 to n - 1 do k ← 0
	done ← false
	while not(D.isEmpty() or done) do
		if P[i] ≥ P[D.top()] then
			D.pop()
		else done ← true
	if D.isEmpty() then h ← -1
	else h ← D.top()
	S[i] ← i - h
	D.push(i)
return S
```



<a name="3911b625"></a>
### 04 List



<a name="895ff1f4"></a>
#### Array-List ADT



<a name="Keywords-5"></a>
##### Keywords

- To be implemented  by arrays. Access by  “index”
- Can access any element directly, not just first or last.
- Elements are accessed by index (or rank), the number of  elements which precede them (if starting from index 0)
- Typically implemented by an array



<a name="c3f057bd-3"></a>
##### Main Methods

```java
//A sequence S (with n elements) that supports the following methods:
-get(i): 		Return the element of S with index i; 
				an error occurs if i < 0 or i > n -1
-set(i,e): 		Replace the element at index i with e 
				and return the old element; an error 
				condition occurs if i < 0 or i > n - 1
-add(i,e):		Insert a new element into S which 
				will have index i; an error occurs if 
				i< 0 or i > n
-remove(i): 	Remove from S the element at index i; 
				an error occurs if i < 0 or i > n - 1
                    
//Adapter Pattern Example: ArrayList can be adapted as a Deque
Deque                         ArrayList
getFirst(), getLast()         get(0), get(size()-1)
addFirst(e), addLast(e)       add(0,e), add(size(),e)
removeFirst(), removeLast()   remove(0), remove(size()-1)
```



<a name="4545a810"></a>
##### Performance with Array-List

-Array V of size N

- size/isEmpty/get/replace: O(1)
- insert/remove: O(n)



<a name="677b39d2"></a>
##### Class Java.util.ArrayList< E>:

```java
Class java.util.ArrayList<E>
- Inherits from
	• java.util.AbstractCollection<E> 
	• java.util.AbstractList<E>
– Implements 
	• Iterable<E>
	• Collection<E>
	• List<E>
	• RandomAccess
	• The methods 
– size(), isEmpty(), get(int) and set(int,E) in time O(1)
– add(int,E) and remove(int) in time O(n
```



<a name="354f0e89"></a>
##### Performance with Linked List

- size/isEmpty: O(1)
- get/replace/insert/remove: O(n)



<a name="75b758b8"></a>
#### Positional-List ADT

Keywords

- To be implemented by linked lists Access by “position” (or address)
- **Cannot access** any element **directly,** can **access just  first or last**.
- Elements are accessed by **"Position"(node, address, place)**



<a name="c3f057bd-4"></a>
##### Main Methods

```java
//ADT with position-based methods
• generic methods	size(), isEmpty()
• accessor methods 	first(), last()
					before(p), after(p)
• update methods	addFirst(e), addLast(e)
					addBefore(p,e), addAfter(p,e)
					set(p,e), remove(p)
```



<a name="3ebd56ed"></a>
##### Performance with Positional-List

In the implementation of the Positional-List ADT by  means of a doubly linked list

- The space used by a list with n elements is O(n)
- The space used by each position of the list is O(1)
- All the operations of the Positional-List ADT run in  O(1) time



<a name="2fd15eb7"></a>
#### Sequence ADT (More General)



<a name="Keywords-6"></a>
##### Keywords

- Combination of both



<a name="a68539d1"></a>
##### Main Methods:

```java
• ***Combines the Array-List and Positional-List ADT***
• ***Adds*** methods that bridge between index and positions
	-atIndex(i) returns a position
	-indexOf(p) returns an integer index
```



<a name="7c10ccde"></a>
##### Performance of Implementation with Array-based

- addFirst, addBefore, addAfter, remove: O(n)
- Also: add, remove based on the index:O(n)
- Other methods: O(1)



<a name="dc203fa0"></a>
##### Performance of Implementation with Doubly Linked List

- addFirst,addBefore,addAfter,add(i,e) ---- O(n)
- remove(position) remove(index) ---- O(n)
- Bridges: atIndex(i), indexOf(p): ---- O(1)
- get(i), set(i,e) ----- O(1)



<a name="fd39f9a2"></a>
##### Performance of Implementation of Sequences by  Doubly-linked lists

- addFirst,addBefore,addAfter, remove(position) ---- O(1)
- add(i,e)  remove(index) ---- O(n)
- Bridges: atIndex(i), indexOf(p): ---- O(n)
- get(i), set(i,e) ----- O(n)



<a name="5bfed8be"></a>
### 05 Trees



<a name="Keywords-7"></a>
#### Keywords

- hierarchical structure
- A tree consists of nodes  with a parent-child  relation
- ![](https://i.loli.net/2021/02/27/oAYbmKw9tG4Q3R1.png#id=uL3UU&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=eqQo1&originHeight=273&originWidth=371&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="d5abc143"></a>
#### Methods and Terminology

```java
//Terminology
Root: node without parent (A);
Subtree: tree consisting  of a node and its descendants
Internal node: node with at least  one child (A, B, C, F)；
Ancestors of a node: parent, grandparent, grand-grandparent, etc.; 
External node (leaf/leaves): node without children (E, I, J, K, G, H, D);
Descendant of a node: child, grandchild, grand-grandchild, etc.;
Distance between two nodes: number of “edges” between them
Depth of a node: number of ancestors (= **distance** from the root)
Height of a tree: maximum depth of any node (3 for the tree above)
    
//ADTs for Trees 
• generic container methods
	- size(), isEmpty(), elements()
• positional container methods
	- positions(), swapElements(p,q), replaceElement(p,e)
• query methods
	- isRoot(p), isInternal(p), isExternal(p)
• accessor methods
	- root(), parent(p), children(p)
• update methods
	- application specific
    
//Computing the depth of a node pseudocode
    Algorithm depth(T,v)
	if T.isRoot(v) then
		return 0
	else
	return 1 + depth(T, T.parent(v))
```



<a name="ec49fb38"></a>
#### Traversing a tree



<a name="c50cb34b"></a>
##### Preorder Traversal

In a preorder traversal, a node is  visited before its descendants. (Print a structured doc)

![](https://i.loli.net/2021/02/27/OXw84xyfPCSgJjG.png#id=SLtaG&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=JsjKP&originHeight=207&originWidth=644&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```java
Algorithm preOrder(v)
	visit(v)
	for each child w of v
		preorder (w)
```



<a name="12f08e87"></a>
##### Post-order Traversal

In a postorder traversal, a node  is visited after its  descendants. (Compute space used  by files in a directory and its  subdirectories)

![](https://i.loli.net/2021/02/27/ON6Guvb1k2IP935.png#id=KKqcd&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=t8R4I&originHeight=223&originWidth=633&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```java
Algorithm postOrder(v)
	for each child w of v
		postOrder (w)
	visit(v)
```



<a name="d056c032"></a>
##### In-order Traversal of a tree (Depth-first)

Let d(x) be the numberof sub-trees of node x.<br />Start: x = root<br />IN-ORDER VISIT

1. Visit the first sub-tree (inorder)
2. Visit the root
3. Visit the second sub-tree (inorder)<br />...
4. d(x)+1. Visit the d(x)th sub-tree (inorder)

![](https://i.loli.net/2021/02/27/i9V7jxsrZgX5kLq.png#id=IU17E&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=uOVnW&originHeight=241&originWidth=292&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="9cabd0bb"></a>
##### Extra Note：

- **前序遍历 (Preorder Traversal)**
- **中序遍历 (In-order Traversal)**
- **后序遍历 (Post-order Traversal)**

1. 前序遍历 (Preorder Traversal)：根节点，左子树，右子树(根在最前).<br />`[1, 2, 4, 7, 8, 5, 3, 6, 9, 10]`
2. 中序遍历 (Inorder Traversal)：左子树，根节点，右子树.<br />`[7, 4, 8, 2, 5, 1, 3, 9, 6, 10]`
3. 后序遍历 (Post-order Traversal)：左子树，右子树，根节点。<br />`[7, 8, 4, 5, 2, 9, 10, 6, 3, 1]`<br />(无子树节点，将其子树理解为空)



<a name="d952eade"></a>
#### Types of Binary Trees



<a name="c4a6024a"></a>
###### "Full" Binary Trees (or "Proper") and Perfect Binary Trees

![](https://i.loli.net/2021/02/27/YoAyCgURjJTeDui.png#id=HXe8u&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=cNUgr&originHeight=575&originWidth=745&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="be16f075"></a>
###### Complete Binary Trees

```
叶节点只能出现在最下层和次下层，且最下面一层节点都集中在该层最左侧若干位置。
```

![](https://i.loli.net/2021/02/27/kMxC6ugYFzlaroD.png#id=Z9yow&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=z7ZSh&originHeight=573&originWidth=743&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="c6f4056f"></a>
#### Examples of Binary Trees



<a name="30ce9d81"></a>
##### Decision Trees

![](https://i.loli.net/2021/02/27/1CZUzdepoYbREAQ.png#id=OEoyD&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=h5BOP&originHeight=576&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="0799ddf3"></a>
##### Arithmetic Expression Tree

![](https://i.loli.net/2021/02/27/rN9L2VKGAny1YQI.png#id=hU0AD&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=uj1FN&originHeight=574&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="e5289999"></a>
#### Properties of Binary Trees (PNB2)

The maximum number of nodes in a binary tree of height h is **2^(h+1) - 1**

The minimum number of nodes in a binary tree of height h is **h+1**

![](https://i.loli.net/2021/02/27/NiUXvMnEaKIsl4C.png#id=iXvtK&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=SKMSj&originHeight=573&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="2e8ae21d"></a>
#### Properties of Full Binary Trees

![](https://i.loli.net/2021/03/01/ArDLPpmX7noG9Oe.png#id=kLlL0&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=nkIGh&originHeight=576&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="f5428d07"></a>
###### In Perfect Binary Trees

![](https://i.loli.net/2021/03/01/dzFpIvXuSO5a3fW.png#id=K3gUY&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=W0rGU&originHeight=574&originWidth=745&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="6d2946bb"></a>
###### In Complete Binary Trees

![](https://i.loli.net/2021/03/01/6Y1qPXIRsm8bpMt.png#id=hNE6A&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=L69ml&originHeight=575&originWidth=745&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="d5abc143-1"></a>
###### Methods and Terminology

```java
• accessor methods
	-leftChild(p), rightChild(p), sibling(p)
• update methods
	-expandExternal(p), removeAboveExternal(p)
• other application specific methods
```



<a name="f6336493"></a>
#### Traversing a Binary Tree



<a name="03684fa5"></a>
##### Preorder Traversal, Postorder & Inorder(Depth-first)

```java
Algorithm preOrder(T,v)
	visit(v)
		if v is internal:
			preOrder (T,T.LeftChild(v))
			preOrder (T,T.RightChild(v))
Algorithm postOrder(T,v)
		if v is internal:
		postOrder (T,T.LeftChild(v))
		postOrder(T,T.RightChild(v))
	visit(v)
Algorithm inOrder(T,v)
		if v is internal:
		inOrder (T,T.LeftChild(v))
	visit(v)
	if v is internal:
		inOrder(T,T.RightChild(v))
```



<a name="EulerTour"></a>
#### EulerTour

```java
Algorithm eulerTour(T,v)
		visit v                       (from the left)
	if v is internal:
		eulerTour (T,T.LeftChild(v))
	visit v                           (from below)
	if v is internal:
		eulerTour(T,T.RightChild(v))
	visit v                           (from the right)
```



<a name="e97fb99e"></a>
#### Implementing Binary Trees  with a Linked Structure

![](https://i.loli.net/2021/03/01/qBdcUenotYIgAma.png#id=WUrwv&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=lHQQa&originHeight=572&originWidth=741&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```java
*leftChild(p), rightChild(p), sibling(p): Input:Position Output:Position
*swapElements(p,q) Input: 2 Positions Output: None
*replaceElement(p,e) Input: Position and an object Output: Object
*isRoot(p) Input: Position Output: Boolean
*isInternal(p) Input: Position Output: Boolean
*isExternal(p) Input: Position Output: Boolean
*BTNode
	Object Element
	BTNode left, right, parent
*leftChild(v) return v.left
*rightChild(v) return v.right
*sibling(v) 
	p ← parent(v)
	q ← leftChild(p)
	if (v = q) return rightChild(p)
	else return q
*replaceElement(v,obj) 
	temp ← v.element
	v.element ← obj
	return temp
*swapElements(v,w)
	temp ← w.element
	w.element ← v.element
	v.element ← temp
*leftChild(p), rightChild(p), sibling(p):
	SwapElements(p,q), 
	replaceElement(p,e)
	isRoot(p), isInternal(p), 
	isExternal(p)
        
/**They all have complexity O(1)*/
```



<a name="028b1546"></a>
#### Implementing Complete Binary Trees with Vectors (Array-based)

```java
*leftChild(p), rightChild(p), sibling(p):
	swapElements(p,q), 
	replaceElement(p,e)
	isRoot(p), isInternal(p), 
	isExternal(p)
/**They all have complexity O(1)*/
```



<a name="caa470fe"></a>
#### Implementing General Trees  with a Linked Structure



<a name="Keywords-8"></a>
##### Keywords

- A node is represented by an  object storing – Element – Parent node – Sequence of children  nodes
- Node objects implement  the Position ADT



<a name="9867c7f6"></a>
#### Extra Notes

![](https://i.loli.net/2021/03/01/9sFRJkAXVgHnIDC.png#id=NpgrG&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=EPHdf&originHeight=841&originWidth=1476&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="7b30fd80"></a>
### 06 PQ (Priority Queues)



<a name="Keywords-9"></a>
#### Keywords

![](https://i.loli.net/2021/03/01/ra5yHNgnC8VDMk2.png#id=wsUDS&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=SeEI2&originHeight=560&originWidth=721&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/01/TgnxfNe8lL6FWPt.png#id=shl9X&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=gfpAC&originHeight=889&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
PriorityQueue 是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator 在队列实例化的时排序。

PriorityQueue 不允许空值，而且不支持 non-comparable（不可比较）的对象，比如用户自定义的类。优先队列要求使用 Java Comparable 和 Comparator 接口给对象排序，并且在排序时会按照优先级处理其中的元素。

PriorityQueue 的大小是不受限制的，但在创建时可以指定初始大小。当我们向优先队列增加元素的时候，队列大小会自动增加。

PriorityQueue 是非线程安全的，所以 Java 提供了 PriorityBlockingQueue（实现 BlockingQueue接口）用于Java 多线程环境。

PriorityQueue和Queue的区别在于，它的出队顺序与元素的优先级有关，对PriorityQueue调用remove()或poll()方法，返回的总是优先级最高的元素。

要使用PriorityQueue，我们就必须给每个元素定义“优先级”。
```



<a name="729fff44"></a>
#### Main Method

```java
//A priority queue P supports the following methods:
-size():			Return the number of elements in P
-isEmpty(): 		Test whether P is empty
-insertItem(k,e):	Insert a new element e with key k into P
-minElement(): 		Return (but don’t remove) an element of Pwith 		 					 smallest key; an error occurs if P is empty.
-minKey(): 			Return the smallest key in P; an error occurs 
    				if P is empty
-removeMin(): 		Remove from P and return an element with the smallest 					  key;an error condition occurs if P is empty.
                        
//A Priority Queue P can be used for sorting a sequence S by:
– inserting the elements of S into P with a series of 
	insertItem(k, e) operations
– removing the elements from P in increasing order and 
	putting them back into S with a series of removeMin() operations
                        
Algorithm PriorityQueueSort(S, P):
	Input: A sequence S storing n elements, on which a 
		total order relation is defined, and a Priority Queue P 
		that compares keys with the same relation
	Output: The Sequence S sorted by the total order relation
	while !S.isEmpty() do
		e ← S.removeFirst()
		P.insertItem(e, e)
	while P is not empty do
		e ← P.removeMin()
	S.insertLast(e)
```



<a name="359ef62d"></a>
#### Comparator ADT

```java
The comparator ADT includes:
-isLessThan(a, b)
-isLessThanOrEqualTo(a,b)
-isEqualTo(a, b)
-isGreaterThan(a,b)
-isGreaterThanOrEqualTo(a,b)
-isComparable(a)
```



<a name="c137f132"></a>
##### Implementation with an Unsorted Sequence

```java
- The elements of S are a composition of two elements; 
  （k, the key, and e, the element.） 
  insertItem() = insertLast() on the sequence. O(1) time.
- The sequence is not ordered .
  For minElement(), minKey(), and removeMin(),
  we need to look at all the elements of S in the worstcase. O(n) time.
  insertItem： O(1);
  minKey, minElement: O(n);
  removeMin: O(n).
```



<a name="c137f132-1"></a>
##### Implementation with an Unsorted Sequence

```java
- Use a Sequence S, sorted by increasing keys
  minElement(), minKey(), and removeMin() take O(1) time
- To implement insertItem(), we must scan through the entire sequence in 
  the worst case. Thus insertItem() runs in O(n) time.
  insertItem: O(n);
  minKey, minElement: O(1);
  removeMin: O(1)
```



<a name="9867c7f6-1"></a>
##### Extra Notes

![](https://i.loli.net/2021/03/02/rNHD9wM4SAVc7fd.png#id=OtUqi&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=winoc&originHeight=312&originWidth=1284&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/02/Pxf5gCDc4I1v2UH.png#id=tlap2&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=O2DOc&originHeight=1062&originWidth=1232&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/02/y2irfpLAl1NgjRD.png#id=NizCO&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=Wh5SN&originHeight=661&originWidth=1264&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="24b16e84"></a>
##### Extra Codes

```java
public class PriorityQueueTest {

    public static void main(String[] args) {
        Queue<Integer> queue1 = new PriorityQueue<Integer>();
        queue1.add(2);
        queue1.add(1);
        queue1.add(3);

        while (!queue1.isEmpty()) {
            Integer i = queue1.poll();
            System.out.println(i);
        }

        Comparator<Student> comparator = new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                return (o1.id - o2.id);
            }
        };

        Queue<Student> queue2 = new PriorityQueue<Student>(comparator);
        queue2.add(new Student(2, "B"));
        queue2.add(new Student(1, "A"));
        queue2.add(new Student(3, "C"));

        while (!queue2.isEmpty()) {
            Student s = queue2.poll();
            System.out.println(s.toString());
        }
    }

    public static class Student {
        private int id;
        private String name;

        public Student(int id, String name) {
            this.id = id;
            this.name = name;
        }

        public String toString() {
            return id + "-" + name;
        }
    }
}

/**
Output: 
1
2
3
1-A
2-B
3-C
*/
```



<a name="0e7532cb"></a>
### [07 Heaps](C:\Users\zljn\OneDrive\Steve's Files\D - Academic\1 - CSI2110D\07-heaps.pdf)



<a name="Keywords-10"></a>
#### Keywords

**Complete binary tree** that stores a collection of keys  (or key-element pairs) at its **internal** nodes and that satisfies  **the additional property**:

**Min-heap: key(parent) <= key(child)  -> removeMin():

Max-heap: key(parent) >= key(child)



<a name="947c4c14"></a>
#### Height of a Heap

![](https://i.loli.net/2021/03/02/ic8vRjELAP9odOQ.png#id=ZyHkX&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=iirIA&originHeight=917&originWidth=1192&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="9e18b8ac"></a>
#### Analysis of Heap Construction -- O(n)

![](https://i.loli.net/2021/03/02/TbFUdWvesI9xj4Z.png#id=CfVDT&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=Tocv8&originHeight=1137&originWidth=1456&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/02/K6RLykG8W72xdE4.png#id=mN3KL&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=NJRyL&originHeight=1134&originWidth=1441&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="84229916"></a>
#### Down Heap

![](https://i.loli.net/2021/03/02/UxYMnXEsTDGhHIQ.png#id=v8eNN&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=zKUgq&originHeight=1105&originWidth=1449&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/02/JL2lNHqbKTdgcRf.png#id=oeGT5&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=VDTHU&originHeight=1112&originWidth=1441&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

In-space sorting

![](https://i.loli.net/2021/03/02/djBtyHVgWXU584p.png#id=xEHww&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=UylgV&originHeight=1419&originWidth=1342&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="9867c7f6-2"></a>
#### Extra Notes

![](https://i.loli.net/2021/03/02/KbE9j7JCntsyB42.png#id=qalpX&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=aACZy&originHeight=1069&originWidth=1210&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="e6a438de"></a>
##### Insert/O(log n)

![](https://i.loli.net/2021/03/02/vDusE1xp46TOq5P.png#id=T19sN&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=wkU9P&originHeight=1632&originWidth=1179&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/02/eRdwIu3j91NXCD2.png#id=kXgdd&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=CS4Pt&originHeight=134&originWidth=1183&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/04/cTCMH91VnpFksaL.png#id=yi03J&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=l3435&originHeight=451&originWidth=1181&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="Delete-Max"></a>
##### Delete-Max

![](https://i.loli.net/2021/03/04/koMj5z6UVEtPZrX.png#id=Aiejv&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=s9ic4&originHeight=1626&originWidth=1213&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/04/Um9oRIbkYLepwfg.png#id=lMzPa&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=n1Hk7&originHeight=173&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/04/u3mWGx1rtgZKdRM.png#id=SffSc&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=SlBCj&originHeight=902&originWidth=1197&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="Max-Heap"></a>
##### Max-Heap

- Heap是一种数据结构具有以下的特点：<br />1）**完全二叉树**；<br />2）heap中存储的值是**偏序**；
- **Min-heap**: 父节点的值小于或等于子节点的值；<br />**Max-heap**: 父节点的值大于或等于子节点的值；

![](https://i.loli.net/2021/03/01/UcIDS596GAC71ov.png#id=dtjTD&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=Y8JWc&originHeight=407&originWidth=659&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="Down-heap"></a>
##### Down-heap

![](https://i.loli.net/2021/03/04/Q6CIVtwf1xc9GlS.jpg#id=FTvuj&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=ofqlm&originHeight=4741&originWidth=844&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="Operations"></a>
##### Operations

1. **堆的存储：**<br />一般都用数组来表示堆，i结点的父结点下标就为(i–1)/2。它的左右子结点下标分别为2 _ i + 1和2 _ i + 2。如第0个结点左右子结点下标分别为1和2。<br />![](https://i.loli.net/2021/03/04/BV2Xd4Wzp35SrTs.gif#id=LNRGs&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=ElcO7&originHeight=166&originWidth=410&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
2. **堆的操作：insert**<br />插入一个元素：新元素被加入到heap的末尾，然后更新树以恢复堆的次序。<br />每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于直接插入排序中将一个数据并入到有序区间中。<br />![](https://i.loli.net/2021/03/04/A8CWnbfl3e9jJ2R.png#id=cc6GZ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=Ku4ws&originHeight=338&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
3. **堆的操作：RemoveMax**<br />按定义，堆中每次都删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最大的，如果父结点比这个最小的子结点还大说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。<br />![](https://i.loli.net/2021/03/04/yNMQJAPja9u5Dro.png#id=kzD24&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=AUgq5&originHeight=431&originWidth=653&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
4. **堆的操作：buildHeap 堆化数组**<br />对于叶子节点，不用调整次序，根据满二叉树的性质，叶子节点比内部节点的个数多1.所以i=n/2 -1 ，不用从n开始。<br />![](https://i.loli.net/2021/03/04/e5r3DSkACBNpULc.png#id=cKO8R&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=Wk0mj&originHeight=496&originWidth=730&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
5. **堆排序**<br />堆建好之后堆中第0个数据是堆中最大的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最大的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。



<a name="260a981e"></a>
### [08 Dictionary BinarySearchTrees](C:\Users\zljn\OneDrive\Steve's Files\D - Academic\1 - CSI2110D\08-Dictionary binarySearchTrees.pdf)



<a name="Keywords-11"></a>
#### Keywords

“左小右大”

![](https://i.loli.net/2021/03/04/jOEV9G78ulgwa1F.jpg#id=UpuDK&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=RGoK5&originHeight=884&originWidth=2156&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="21934204"></a>
#### Extra Note

```java
1.4.3 二叉查找树实现
- 插入方法put实现思想：
1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用
2.如果当前树不为空，则从根结点开始：
 2.1如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；
 2.2如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；
 2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。
- 查询方法get实现思想：
从根节点开始：
 1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；
 2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；
 3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。
- 删除方法delete实现思想：
 1.找到被删除结点；
 2.找到被删除结点右子树中的最小结点minNode
 3.删除右子树中的最小结点
 4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子
树
 5.让被删除结点的父节点指向最小结点minNode
```

二叉查找树（Binary Search Tree），也称二叉搜索树、有序二叉树（ordered binary tree），排序二叉树（orted binary tree），是指一棵空树或者具有下列性质的二叉树：

- 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
- 任意节点的左、右子树也分别为二叉查找树；
- **没有键值相等的节点**

二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低,均为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。



<a name="1dfb5acb"></a>
##### **常用操作**

定义树的节点如下：

```python
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None12345
```



<a name="c8b7d763"></a>
##### 1. 查找

在二叉搜索树bb中查找xx的过程为：

1. 若b是空树，则搜索失败，否则：
2. 若x等于b的根节点的数据域之值，则查找成功；否则：
3. 若x小于b的根节点的数据域之值，则递归搜索左子树；否则:
4. 递归查找右子树

使用python实现如下：

```python
def search(root, val):
    if root == None:
        return False, None
    elif val > root.val:
        return search(root.right, val)
    elif val < root.val:
        return search(root.left, val)
    else:
        return True, root123456789
```



<a name="752485e3"></a>
##### 2. 插入

向一个二叉搜索树bb中插入一个节点ss的算法，过程为：

- 若b是空树，则将s所指结点作为根节点插入，否则：
- 若s.val等于b的根节点的数据域之值，则返回，否则：
- 若s.val小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：
- 把s所指节点插入到右子树中**（新插入节点总是叶子节点）**

```python
def insert(self, root, node):
    """insert inplace"""
    if root ==  None:
        root = node
        return
    if node.val == root.val:
        return
    elif node.val > root.val:
        self.insert(root.right, node)
    else:
        self.insert(root.left, node)1234567891011
```



<a name="c728e84d"></a>
##### 3. 删除

二叉搜索树的删除操作分三种情况讨论:<br />\1. 如果待删除的节点是叶子节点，那么可以立即被删除，如下图所示：<br />例：删除数据为16的节点，是叶子节点，可以直接删除<br />![](https://i.loli.net/2021/03/04/ml4M2TJ7sCLgydD.jpg#id=qSj1N&originHeight=428&originWidth=1174&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=QBe3P&originHeight=428&originWidth=1174&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />\2. 如果有一个子节点，要将下一个子节点上移到当前节点，即替换之<br />例：删除数据为25的节点，它下面有唯一一个子节点35, 上移到替换之<br />![](https://i.loli.net/2021/03/04/IBChuAx34qyNXKv.jpg#id=tpuAh&originHeight=426&originWidth=1188&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=vpUhZ&originHeight=426&originWidth=1188&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />\3. 如果有两个子节点，则将其右子树的最小数据代替此节点的数据，并将其右子树的最小数据删除，如下图所示<br />例：删除节点数据为5的节点，找到被删除节点右子树的最小节点。需要一个临时变量successor，将11节点下面的子节点进行查询，找到右子树最小节点7，并把右子树最小节点7替换被删除节点，维持二叉树结构。如下图<br />![](https://i.loli.net/2021/03/04/MGWiQobZcp9y4hd.jpg#id=R1Hr3&originHeight=530&originWidth=1164&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=Chahm&originHeight=530&originWidth=1164&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```python
class solution:
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        if root == None:
            return None
        if key < root.val:
            root.left = self.deleteNode(root.left, key)
        elif key > root.val:
            root.right = self.deleteNode(root.right, key)
        else:
            if root.left == None:
                return root.right
            elif root.right == None:
                return root.left
            else:
                min_node = self.findMinNode(root.right)
                root.val = min_node.val
                root.right = self.deleteNode(root.right, root.val)
        return root

    def findMinNode(self, node):
        while node.left:
            node = node.left
        return node12345678910111213141516171819202122232425262728
```



<a name="ccf26142"></a>
##### 4. 遍历

可以采用前序，中序，后序来遍历该二叉搜索树，或者使用广度优先搜索的方式。这里用中序遍历来实现，可以保证按从小到大的顺序打印。

```python
def traverse_binary_tree(root):
    if root is None:
        return
    traverse_binary_tree(root.left)
    print(root.value)
    traverse_binary_tree(root.right)123456
```



<a name="879bf55a"></a>
##### 5. 构造一颗二叉查找树

用一组数值建造一棵二叉查找树的同时，也把这组数值进行了排序。其最差时间复杂度为 O(n2)O(n2)。例如，若该组数值经是有序的（从小到大），则建造出来的二叉查找树的所有节点，都没有左子树

```python
def build_binary_tree(values):
    tree = None
    for v in values:
        tree = insert(tree, Node(v))
    return tree12345
```



<a name="7d9781d2"></a>
##### **性能分析**

查找：最佳情况Olog(n)Olog(n), 最坏情况O(n)O(n)<br />插入：最佳情况Olog(n)Olog(n), 最坏情况O(n)O(n)<br />删除：最佳情况Olog(n)Olog(n), 最坏情况O(n)



<a name="93de1847"></a>
### 09 AVL Trees

---



<a name="79e6b3c0"></a>
### Data Structure Summary / Java

```
/**
 * Data Structure 数据结构/Java中文教程
 *
 * 【Stack 栈 -- size】：
 * 特点：先进后出，出口入口为同一个，位于顶部，如：子弹弹夹；[size]
 *
 * 【Queue 队列 -- size】；
 * 特点：先进先出，出口入口不同，分别在左右两侧，如：排队安检；
 *
 * 【Array 数组】：
 * 特点：
 * 1. 查询快：数组的地址是连续的，我们通过数组的首地址可以找到数组，通过数组的索引可以快速查找某一个元素；
 * 2. 增删慢：数组的长度是固定的，我们想要增加/删除一个元素，必须创建一个新数组，把原数组的数组进行复制；
 *    删除元素时，要创建一个长度为原数组长度-1（Array.length-1)的数组，把其他数据复制过来并删除原数组；
 *
 * 【LinkedList 链表 -- length】：
 * 特点：
 * 1. 查询慢：链表中地址不是连续的，每次查询元素，都必须从头开始查询；
 * 2. 增删快：链表结构，增加/删除一个元素，对链表的整体结构没有影响；
 *
 * 单向列表：链表中只有一条链，不能保证元素的顺序（存储元素和取出元素的顺序可能不一致）；
 * 双向链表：链表中有两条链子，其中一条是专门记录元素的顺序的，是一个有序的集合；
 * (图示：DoubleLinkedList.jpg）
 *
 * 链表中的每一个元素也称之为一个【节点Node】，一个节点包含了【1个数据元】和【2个指针域(存储地址)】；
 * 分别代表了：自身的数据，自身的地址和下一个(Next)节点的地址
 *
 *  【Tree 树 (Computer)】：
 *  （图示：Tree.jpg)
 * 【BinaryTree 二叉树】；
 *  二叉树是红黑树的一种特殊形式；
 *  二叉树的每个节点向下的分支不能超过两个；
 *
 * 【Binary Sort Tree 二叉排序树/Binary Search Tree 二叉查找树】；
 *  在二叉树的基础上，元素是有大小顺序的，左子树小，右子树大；
 *  例如：猜数字游戏，1-100之间的数字，从50开始猜（比大小），每次减去一半剩余数字；
 *
 * 【Balanced Binary Tree 平衡二叉树（AVL树）】
 *  一棵AVL树是其每个结点的左子树和右子树的高度最多相差1的二叉查找树(空树的高度为-1)，这个差值也称为平衡因子
 *  （图示：BalancedTree。jpg)
 *
 *  【Red-BlackTree 红黑树】：
 *   特点：趋近于平衡树，查询的速度非常快，查询叶子结点的最大次数和最小次数比值不能超过两倍；
 *   约束：
 *   1. 节点可以是红色的或黑色的；
 *   2. 根节点是黑色的；
 *   3. 叶子节点(空节点)是黑色的；
 *   4. 每个红色的结点的子节点都是黑色的；
 *   5. 任意一个节点到其每一个叶子节点的所有路径上黑色节点数量相同；
 *   （图示：Red-BlackTree.jpg)
 *
 *
 *
 */
```

```java
代码中主要两个方法：

1、将待排序数组构造成一个大根堆（元素上升）

2、固定一个最大值，将剩余的数再构造成一个大根堆（元素下降）

    //堆排序
    public static void heapSort(int[] arr) {
        //构造大根堆
        heapInsert(arr);
        int size = arr.length;
        while (size > 1) {
            //固定最大值
            swap(arr, 0, size - 1);
            size--;
            //构造大根堆
            heapify(arr, 0, size);
 
        }
 
    }
 
    //构造大根堆（通过新插入的数上升）
    public static void heapInsert(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            //当前插入的索引
            int currentIndex = i;
            //父结点索引
            int fatherIndex = (currentIndex - 1) / 2;
            //如果当前插入的值大于其父结点的值,则交换值，并且将索引指向父结点
            //然后继续和上面的父结点值比较，直到不大于父结点，则退出循环
            while (arr[currentIndex] > arr[fatherIndex]) {
                //交换当前结点与父结点的值
                swap(arr, currentIndex, fatherIndex);
                //将当前索引指向父索引
                currentIndex = fatherIndex;
                //重新计算当前索引的父索引
                fatherIndex = (currentIndex - 1) / 2;
            }
        }
    }
    //将剩余的数构造成大根堆（通过顶端的数下降）
    public static void heapify(int[] arr, int index, int size) {
        int left = 2 * index + 1;
        int right = 2 * index + 2;
        while (left < size) {
            int largestIndex;
            //判断孩子中较大的值的索引（要确保右孩子在size范围之内）
            if (arr[left] < arr[right] && right < size) {
                largestIndex = right;
            } else {
                largestIndex = left;
            }
            //比较父结点的值与孩子中较大的值，并确定最大值的索引
            if (arr[index] > arr[largestIndex]) {
                largestIndex = index;
            }
            //如果父结点索引是最大值的索引，那已经是大根堆了，则退出循环
            if (index == largestIndex) {
                break;
            }
            //父结点不是最大值，与孩子中较大的值交换
            swap(arr, largestIndex, index);
            //将索引指向孩子中较大的值的索引
            index = largestIndex;
            //重新计算交换之后的孩子的索引
            left = 2 * index + 1;
            right = 2 * index + 2;
        }
 
    }
    //交换数组中两个元素的值
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
```



<a name="Exercise"></a>
### Exercise

![](https://i.loli.net/2021/03/04/naIUDRBH7FPsbO4.png#id=v3Cef&originHeight=559&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=TfnRM&originHeight=559&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/04/CnVqdSopHfQ1Bax.png#id=rY7S6&originHeight=1398&originWidth=1302&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=j2AYd&originHeight=1398&originWidth=1302&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/04/vSfCsuqteGab18k.png#id=fvnB6&originHeight=477&originWidth=994&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=BSKx3&originHeight=477&originWidth=994&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/04/fO56q7Bpmzjs3ot.png#id=daBvO&originHeight=457&originWidth=931&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=m9G9g&originHeight=457&originWidth=931&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="f86689f4"></a>
## Problem Notes



<a name="9ce232d6"></a>
### 1. Code - Complexities



<a name="e6fbfca2"></a>
#### Problem 1

![](https://i.loli.net/2021/03/01/41TYupKcymoF5sJ.png#id=NTxrL&originHeight=1661&originWidth=1450&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=ag3DA&originHeight=1661&originWidth=1450&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/01/41TYupKcymoF5sJ.png#id=DwX5w&originHeight=1661&originWidth=1450&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=H3ngY&originHeight=1661&originWidth=1450&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/01/czdUY3lBxtJbXNo.png#id=SMsYH&originHeight=693&originWidth=1232&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=Xftm3&originHeight=693&originWidth=1232&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/01/t4qmcVQ6TxLMnv3.png#id=Mnt2P&originHeight=638&originWidth=916&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=RonN8&originHeight=638&originWidth=916&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/01/d2Rl67jwupoiq4c.png#id=a3scD&originHeight=555&originWidth=1031&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=A4FJ7&originHeight=555&originWidth=1031&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="b4d43ed5"></a>
#### Analysis 1

1. <br />



<a name="9f477918"></a>
##### **常数阶O(1)**

2. <br />

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：

```latex
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

1. <br />



<a name="29459a21"></a>
##### **线性阶O(n)**

2. <br />

这个在最开始的代码示例中就讲解过了，如：

```latex
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

1. <br />



<a name="83a2a47b"></a>
##### ** **对数阶O(logN)**

2. <br />

还是先来看代码：

```latex
int i = 1;
while(i<n)
{
    i = i * 2;
}
```

从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n<br />也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：**O(logn)**

1. <br />



<a name="df7f2031"></a>
##### **线性对数阶O(nlogN)**

2. <br />

线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。

就拿上面的代码加一点修改来举例：

```latex
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

1. <br />



<a name="24aa44fa"></a>
##### **平方阶O(n²)**

2. <br />

平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。<br />举例：

```latex
for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)<br />如果将其中一层循环的n改成m，即：

```latex
for(x=1; i<=m; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

那它的时间复杂度就变成了 O(m*n)

1. <br />



<a name="d52c69d8"></a>
##### **立方阶O(n³)**、**K次方阶O(n^k)**

2. <br />

参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。

```java
O(1) < O(logn^(a)) < [O(n^0.5)] < O(n) < O(nlogn) < O(n^a) < O(2^n)
```

```java
条件代码：
Best Case：（局部）算法第一次执行即符合退出条件（如：A[0] 即找到所找元素）-- （局部）算法复杂度：O(1)；Worst Case：执行到最后一个元素才符合退出条件 -- O(n).
```



<a name="eb1addf5"></a>
### ***2. Method - complexities



<a name="501b74ce"></a>
#### Problem 2

![](https://i.loli.net/2021/03/01/7fHTOM6JCIrvmux.png#id=ttbyK&originHeight=461&originWidth=1075&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=wqb0g&originHeight=461&originWidth=1075&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/01/pqm2IMyvjTw9thK.png#id=HSE9l&originHeight=363&originWidth=994&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=fl9Kl&originHeight=363&originWidth=994&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/01/KjIsxBYv6pqNyXg.png#id=hT8LZ&originHeight=1198&originWidth=1130&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=sx2RX&originHeight=1198&originWidth=1130&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```java
In which of the following data structures containing n elements, the worst case complexity of 
searching for an element with a given key k is O(log n)?
A) a heap
B) a binary search tree
√ C) a sorted array
D) a queue
E) more than answer above


n which of the following data structures containing n elements, deleting the element with 
minimum key has worst-case complexity O(log n)?
A) a sorted array (sorted in increasing order)
B) an unsorted doubly linked list
C) a binary search tree
D) a queue
√ E) none of the above.
(All θ(n))

Give the exact asymptotic complexity for the best case running time and worst case running 
time of mySort as a function of the number of elements n of the input array:
A) best case: Θ(n2), worst case: Θ(n2)
B) best case: Θ(n), worst case: Θ(n log n) 
C) best case: Θ(log n), worst case: Θ(n log n)
√ D) best case: Θ(n), worst case: Θ(n2)
E) none of the above
```



<a name="7cdf891e"></a>
#### Analysis 2

```java
***Refer to table 2 in Appendix
```



<a name="2d2ea6f7"></a>
### 3. Binary Tree - Node Counting



<a name="2465587f"></a>
#### Problem 3

![](https://i.loli.net/2021/03/01/yDJK79sC3pFm2Ia.png#id=PlsAh&originHeight=402&originWidth=1339&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=pVOMY&originHeight=402&originWidth=1339&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/01/txi1Lhwgs9CMc2G.png#id=yYJhu&originHeight=348&originWidth=1144&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=kcwp8&originHeight=348&originWidth=1144&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/01/APh9vCeIFfGKOco.png#id=Nn1pe&originHeight=345&originWidth=1119&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=nZbae&originHeight=345&originWidth=1119&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="c4bc83c9"></a>
#### Analysis 3

```java
Full Binary Tree:

internal nodes:        e = i+1  -> i = e - 1 
external nodes/leaves: n = 2e-1 -> e = (n+1)/2
h with n and e given:  h <= (n-1)/2 ; h >= log2e

Binary Tree:
The maximum number of nodes in a binary tree of height： h = 2^(h+1) - 1
The minimum number of nodes in a binary tree of height： h = h+1
    
Complete Binary Tree:
??一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。

叶节点只能出现在最下层和次下层，且最下面一层节点都集中在该层最左侧若干位置。
```

```java
**Height: Level -1
    
     a complete binary tree with 
n nodes:
[log n]
```

![image-20210223010005207](C:\Users\zljn\OneDrive\Steve's Files\F - Typpra Images\image-20210223010005207.png)



<a name="60d7a209"></a>
### 4. Binary Tree - Visited Element Counting



<a name="0ff7c209"></a>
#### Problem 4

![](https://i.loli.net/2021/03/01/wbqf5Q6nxCshvT2.png#id=VjCLV&originHeight=323&originWidth=986&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=E2xqm&originHeight=323&originWidth=986&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="c0537794"></a>
#### Analysis 4

```
in a leaf：bottom
```



<a name="69b8a39f"></a>
### 5. Big-Oh Calc



<a name="b5cf3313"></a>
#### problem 5

![](https://i.loli.net/2021/03/01/Upul9weaXAV8cZY.png#id=eNQpt&originHeight=1233&originWidth=1064&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=ZXeuV&originHeight=1233&originWidth=1064&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/02/NVKmzDAESF7Uk8R.png#id=TSYqq&originHeight=655&originWidth=975&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=sWfeH&originHeight=655&originWidth=975&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="c866a1f5"></a>
#### Analysis 5

```java
O(1) < O(logn^(a)) < [O(n^0.5)] < O(n) < O(nlogn) < O(n^a) < O(2^n)
```

![](https://i.loli.net/2021/03/02/gQMqueHOr3xaXZy.png#id=wunfv&originHeight=660&originWidth=953&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=Cgftf&originHeight=660&originWidth=953&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/02/Xglqj7ksB8H1TYw.png#id=TSVfT&originHeight=709&originWidth=861&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=AQjp4&originHeight=709&originWidth=861&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/02/kNpIZbd9erKg25z.png#id=cxQPi&originHeight=638&originWidth=904&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=WLCdD&originHeight=638&originWidth=904&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="c3dd8b7b"></a>
### 6. Max-Heap - Operations and sorting



<a name="b5c53236"></a>
#### Problem 6

![](https://i.loli.net/2021/03/02/Evc9uYAfH6357zU.png#id=d2XHx&originHeight=792&originWidth=872&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=yC6XP&originHeight=792&originWidth=872&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/02/4vAXHNq75txKBfM.png#id=cC8d9&originHeight=1204&originWidth=1077&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=i40EL&originHeight=1204&originWidth=1077&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/02/NlbfvIJHCjk7P1M.png#id=IkF3f&originHeight=864&originWidth=1008&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=GRFBb&originHeight=864&originWidth=1008&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="103b2389"></a>
#### Analysis 6

```
RemoveMax: 把顶点（最大值）元素与最后一个（The farthest right node）元素交换

按定义，堆中每次都删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最大的，如果父结点比这个最小的子结点还大说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。
```

Insert：插入后降序排序

![](https://i.loli.net/2021/03/02/q2Y58MHI64yWzdK.jpg#id=quMFo&originHeight=4741&originWidth=844&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=V1exT&originHeight=4741&originWidth=844&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="85c9c251"></a>
### 7. Traversals



<a name="ddc90808"></a>
#### Problem 7

![image-20210223022108346](C:\Users\zljn\OneDrive\Steve's Files\F - Typpra Images\image-20210223022108346.png)

![image-20210223023550617](C:\Users\zljn\OneDrive\Steve's Files\F - Typpra Images\image-20210223023550617.png)

![image-20210223022624090](C:\Users\zljn\OneDrive\Steve's Files\F - Typpra Images\image-20210223022624090.png)



<a name="4c9525bc"></a>
#### Analysis 7

- **前序遍历 (Preorder Traversal)**
- **中序遍历 (In-order Traversal)**
- **后序遍历 (Post-order Traversal)**

1. 前序遍历 (Preorder Traversal)：根节点，左子树，右子树(根在最前).<br />`[1, 2, 4, 7, 8, 5, 3, 6, 9, 10]`
2. 中序遍历 (Inorder Traversal)：左子树，根节点，右子树.<br />`[7, 4, 8, 2, 5, 1, 3, 9, 6, 10]`
3. 后序遍历 (Post-order Traversal)：左子树，右子树，根节点。<br />`[7, 8, 4, 5, 2, 9, 10, 6, 3, 1]`<br />(无子树节点，将其子树理解为空)

```
Hints：Pre第一个元素 -> 根节点 -> 分割左右子树
```



<a name="c51653b5"></a>
### 8. In-place Insertion Sorting with Array



<a name="8c3124d7"></a>
#### Problem 8

![](https://i.loli.net/2021/03/04/wPkHW5RqgzcdYJQ.png#id=u7Tex&originHeight=586&originWidth=1236&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=ve2Ow&originHeight=586&originWidth=1236&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/04/SmYCzEsxihFP6Kk.png#id=OsBtj&originHeight=1333&originWidth=1055&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=PHOUT&originHeight=1333&originWidth=1055&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/04/HGf6yLNWiQ5UbP7.png#id=iBWHM&originHeight=1263&originWidth=969&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=v1Ud1&originHeight=1263&originWidth=969&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="a0ae56dd"></a>
#### Analysis 8

```
1. 还原二叉树结构
2. （MaxHeap排序：关注bottom-up/top-down）
***？ 3. in-place排序：最大的元素排入最后，而后两两对比大的元素置于最前
```



<a name="91d71080"></a>
### 9. Binary Search Tree



<a name="e357d3e9"></a>
#### Problem 9

![](../F%20-%20Typpra%20Images/image-20210223022329563.png#id=EkvwL&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=cG8yA&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/05/IdPjNoQ1CXiSAq9.png#id=WpJ31&originHeight=1039&originWidth=915&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=vZypB&originHeight=1039&originWidth=915&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="65b573c4"></a>
#### Analysis 9

```
“左小右大找一侧”
```



<a name="c8b7d763-1"></a>
###### 1. 查找

在二叉搜索树bb中查找xx的过程为：

1. 若b是空树，则搜索失败，否则：
2. 若x等于b的根节点的数据域之值，则查找成功；否则：
3. 若x小于b的根节点的数据域之值，则递归搜索左子树；否则:
4. 递归查找右子树

使用python实现如下：

```python
def search(root, val):
    if root == None:
        return False, None
    elif val > root.val:
        return search(root.right, val)
    elif val < root.val:
        return search(root.left, val)
    else:
        return True, root123456789
```



<a name="752485e3-1"></a>
###### 2. 插入

向一个二叉搜索树bb中插入一个节点ss的算法，过程为：

- 若b是空树，则将s所指结点作为根节点插入，否则：
- 若s.val等于b的根节点的数据域之值，则返回，否则：
- 若s.val小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：
- 把s所指节点插入到右子树中**（新插入节点总是叶子节点）**

```python
def insert(self, root, node):
    """insert inplace"""
    if root ==  None:
        root = node
        return
    if node.val == root.val:
        return
    elif node.val > root.val:
        self.insert(root.right, node)
    else:
        self.insert(root.left, node)1234567891011
```



<a name="c728e84d-1"></a>
###### 3. 删除

二叉搜索树的删除操作分三种情况讨论:<br />\1. 如果待删除的节点是叶子节点，那么可以立即被删除，如下图所示：<br />例：删除数据为16的节点，是叶子节点，可以直接删除<br />![](https://i.loli.net/2021/03/05/FkQ5DbRgudjxiMH.jpg#id=UIYdL&originHeight=428&originWidth=1174&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=Yb4KN&originHeight=428&originWidth=1174&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />\2. 如果有一个子节点，要将下一个子节点上移到当前节点，即替换之<br />例：删除数据为25的节点，它下面有唯一一个子节点35, 上移到替换之<br />![](https://i.loli.net/2021/03/05/NorbkjAinZGF6gX.jpg#id=N7Rq1&originHeight=426&originWidth=1188&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=Nbexb&originHeight=426&originWidth=1188&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />\3. 如果有两个子节点，则将其右子树的最小数据代替此节点的数据，并将其右子树的最小数据删除，如下图所示<br />例：删除节点数据为5的节点，找到被删除节点右子树的最小节点。需要一个临时变量successor，将11节点下面的子节点进行查询，找到右子树最小节点7，并把右子树最小节点7替换被删除节点，维持二叉树结构。如下图<br />![](https://i.loli.net/2021/03/05/nuRdhLIc6pH5AwM.jpg#id=fCAVF&originHeight=530&originWidth=1164&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=VRWuo&originHeight=530&originWidth=1164&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```python
class solution:
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        if root == None:
            return None
        if key < root.val:
            root.left = self.deleteNode(root.left, key)
        elif key > root.val:
            root.right = self.deleteNode(root.right, key)
        else:
            if root.left == None:
                return root.right
            elif root.right == None:
                return root.left
            else:
                min_node = self.findMinNode(root.right)
                root.val = min_node.val
                root.right = self.deleteNode(root.right, root.val)
        return root

    def findMinNode(self, node):
        while node.left:
            node = node.left
        return node12345678910111213141516171819202122232425262728
```



<a name="ccf26142-1"></a>
###### 4. 遍历

可以采用前序，中序，后序来遍历该二叉搜索树，或者使用广度优先搜索的方式。这里用中序遍历来实现，可以保证按从小到大的顺序打印。

```python
def traverse_binary_tree(root):
    if root is None:
        return
    traverse_binary_tree(root.left)
    print(root.value)
    traverse_binary_tree(root.right)123456
```



<a name="d41d8cd9"></a>
##### 



<a name="1adb1aaf"></a>
### 10. pseudocode or Java program excerpt



<a name="dfbb6977"></a>
#### Problem 10

![](https://i.loli.net/2021/03/05/dp4AUloMB1nXDWE.png#id=DKHch&originHeight=1027&originWidth=1051&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=q2H4D&originHeight=1027&originWidth=1051&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/05/13NyUqa8uVMrIT5.png#id=X8U3D&originHeight=1444&originWidth=1095&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=TIdgX&originHeight=1444&originWidth=1095&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/05/f6PLKjcqeDCyzM8.png#id=PU7is&originHeight=1013&originWidth=1109&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=Xz2eH&originHeight=1013&originWidth=1109&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](https://i.loli.net/2021/03/05/hTdb8UtrSslEzuR.png#id=uHtia&originHeight=1273&originWidth=1078&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=dhIyq&originHeight=1273&originWidth=1078&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="Appendix"></a>
## Appendix



<a name="d6c2ac75"></a>
### 00-A Vocabulary
| English | Chinese |
| --- | --- |
| pseudocode | 伪代码 |
| ADT Queue | 抽象数据类型：队列 |
| ADT Stack | 抽象数据类型：栈 |
| ADT Double-Ended Queues (Deque) | 抽象数据类型：双端队列 |
| hierarchical | 等级制 |
| terminology | 术语 |
| descendants | 后人 |
| ancestor | 祖先 |
| Reflexive | 自反性 |
| Anti-symetric | 反对称 |
| Transitive | 过渡性 |




<a name="e433c5b8"></a>
### 00-B Complexity



<a name="295bea63"></a>
#### Table 1

![](https://i.loli.net/2021/03/05/MBmnuxALhzZ5V1T.png#id=PlufI&originHeight=2707&originWidth=1766&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=#id=qg4KM&originHeight=2707&originWidth=1766&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)



<a name="d6a5ad9b"></a>
#### Table 2

```java
PQ With an unsorted sequence…
removeMin() always takes O(n). That is, 
these methods runs in Ω(n) time even in the best case. -> Θ(n)
But with a sorted sequence…
insertItem() takes at most O(n)
```
| Method | ADT | Worst Case |  |
| --- | --- | --- | --- |
| insert | priority queue (unsorted array) | θ(1) |  |
| removeMin | priority queue (unsorted array) | θ(n) |  |
| min | priority queue (unsorted array) | θ(n) |  |
| Selection Sort | priority queue (unsorted array) |  | O(n^2) |
| Insertion Sort | priority queue (unsorted array) |  | O(n^2) |
| insert | priority queue (min-heap) | θ(log n) |  |
| removeMin | priority queue (min-heap) | θ(log n) |  |
| min | priority queue (min-heap) | θ(1) |  |
| (deleteMin) | sorted array | θ(n) |  |
| (deleteMin) | unsorted doubly linked list | θ(n) |  |
| (deleteMin) | binary search tree | θ(n) |  |
| (deleteMin) | queue | θ(n) |  |
| get(k) | MAP (unsorted linked list) | θ(n) |  |
| get(k) | MAP (sorted array) | θ(log n) |  |
| get(k) | MAP (Binary Search Tree) | θ(n) |  |
| put(k,v) | MAP (unsorted linked list) | θ(n) |  |
| put(k,v) | MAP (sorted array) | θ(n) |  |
| put(k,v) | MAP (Binary Search Tree) | θ(n) |  |
| remove(k) | MAP (unsorted linked list) | θ(n) |  |
| remove(k) | MAP (sorted array) | θ(n) |  |
| remove(k) | MAP (Binary Search Tree) | θ(n) |  |
| delete(k) | min heap | O(n) |  |
| delete(k) | AVL Tree | O(log n) |  |
| delete(k) | hash Table | O(n) |  |
| delete(k) | sorted Sequence | O(n) |  |
| search | a heap | θ(n) |  |
| search | a binary search tree | θ(n) |  |
| search | a sorted array | θ(log n) |  |
| search | a queue | θ(n) |  |
|  |  |  |  |
|  |  |  |  |
|  |  |  |  |


对于同一个数据结构来说，底层实现的不同往往会呈现出不同的时间复杂度。以数组为例：

| . | 普通数组实现 | 顺序数组实现 | 二分搜索树（平衡） |
| --- | --- | --- | --- |
| 插入 | O(1) | O(n) | O(logn) |
| 查找 | O(n) | O(logn) | O(logn) |
| 删除 | O(n) | O(n) | O(logn) |




<a name="Diagrams"></a>
#### Diagrams

![Array](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795470140-a7c0a6aa-2ddb-4193-abc9-a9a60c1223ff.jpeg#averageHue=%23f2f2f2&clientId=uea9b4b03-0995-4&from=drop&id=ued8cc974&originHeight=398&originWidth=1374&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=44170&status=done&style=none&taskId=uc06f2aa8-ceda-44c2-893d-afb71f19911&title=Array#averageHue=%23f2f2f2&id=d9iV6&originHeight=398&originWidth=1374&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Array "Array")![Array_add1](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795484081-5ef155a0-9158-476f-87a0-cdcc87060fd5.jpeg#averageHue=%23f5f4f4&clientId=uea9b4b03-0995-4&from=drop&id=ua4e19731&originHeight=1026&originWidth=1212&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=120942&status=done&style=none&taskId=u63cf425e-344f-4e0a-872e-d942471e7c6&title=Array_add1#averageHue=%23f5f4f4&id=zqXDD&originHeight=1026&originWidth=1212&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Array_add1 "Array_add1")![Array_add2](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795494407-91f901c5-4be1-4dac-91ef-21823721cf77.jpeg#averageHue=%23f4f3f2&clientId=uea9b4b03-0995-4&from=drop&id=u9a8f8f36&originHeight=1022&originWidth=1286&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=167041&status=done&style=none&taskId=u0965839c-83b7-46a3-9e1a-6545ad321fd&title=Array_add2#averageHue=%23f4f3f2&id=gaz0E&originHeight=1022&originWidth=1286&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Array_add2 "Array_add2")<br />![Array_remove](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795511252-8bec5bc2-8f98-4181-8ddd-70e2d174d151.jpeg#averageHue=%23f5f4f4&clientId=uea9b4b03-0995-4&from=drop&id=ucdfd6282&originHeight=1028&originWidth=1288&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=130031&status=done&style=none&taskId=uc4b8854a-a814-4647-9c50-f303028b466&title=Array_remove#averageHue=%23f5f4f4&id=qbBzi&originHeight=1028&originWidth=1288&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Array_remove "Array_remove")<br />![BalancedTree](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795513126-e5e8b702-24c8-4aee-8812-dd3a482f58e3.jpeg#averageHue=%23f3f3f2&clientId=uea9b4b03-0995-4&from=drop&id=u8ea4f490&originHeight=664&originWidth=1318&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=172208&status=done&style=none&taskId=u02fd6caf-0a45-41bd-8216-b7f2fc9bdfb&title=BalancedTree#averageHue=%23f3f3f2&id=w76ec&originHeight=664&originWidth=1318&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=BalancedTree "BalancedTree")<br />![BinaryTree_5forms](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795538200-23f772a4-1452-433b-95b8-be5f9149e592.jpeg#averageHue=%23f4f4f4&clientId=uea9b4b03-0995-4&from=drop&id=uc3a1ba3e&originHeight=896&originWidth=1388&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=129106&status=done&style=none&taskId=ud841b52b-e8e7-49e9-b538-c8c6f1d8d65&title=BinaryTree_5forms#averageHue=%23f4f4f4&id=hp9Wi&originHeight=896&originWidth=1388&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=BinaryTree_5forms "BinaryTree_5forms")<br />![BinaryTree_Full](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795545105-08d8687e-e638-4834-8959-1d0113e660df.jpeg#averageHue=%23f3f3f3&clientId=uea9b4b03-0995-4&from=drop&id=u6fa0d031&originHeight=810&originWidth=1520&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=154276&status=done&style=none&taskId=ucdce4039-214f-4d07-83b3-062c7dd4c20&title=BinaryTree_Full#averageHue=%23f3f3f3&id=QD0kd&originHeight=810&originWidth=1520&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=BinaryTree_Full "BinaryTree_Full")<br />![CircularDoubleLinkedList](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795554900-9bd2f9d0-f99f-4d9a-b783-8626bd43499d.jpeg#averageHue=%23f3f2f2&clientId=uea9b4b03-0995-4&from=drop&id=ua9bc87ea&originHeight=686&originWidth=1304&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=96657&status=done&style=none&taskId=ud93462ea-040c-4e38-ab8d-3f150f24004&title=CircularDoubleLinkedList#averageHue=%23f3f2f2&id=YpQmt&originHeight=686&originWidth=1304&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=CircularDoubleLinkedList "CircularDoubleLinkedList")![CircularDoubleLinkedList_add](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795558755-368e9370-ce87-4d9f-a9e2-49ddd3fb9752.jpeg#averageHue=%23f2f1f1&clientId=uea9b4b03-0995-4&from=drop&id=ue727cc74&originHeight=1072&originWidth=1394&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=185114&status=done&style=none&taskId=u9eb41898-76be-4b5e-94c2-c9967e8b6a0&title=CircularDoubleLinkedList_add#averageHue=%23f2f1f1&id=kiqNp&originHeight=1072&originWidth=1394&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=CircularDoubleLinkedList_add "CircularDoubleLinkedList_add")<br />![CircularDoubleLinkedList_remove](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795569867-eb4f9f2b-0212-440b-b475-bcdc9669e849.jpeg#averageHue=%23f3f2f2&clientId=uea9b4b03-0995-4&from=drop&id=ub294bfc2&originHeight=1246&originWidth=1288&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=206715&status=done&style=none&taskId=u45d5ba76-0d0b-42cb-8a2d-ce826940422&title=CircularDoubleLinkedList_remove#averageHue=%23f3f2f2&id=TQcfR&originHeight=1246&originWidth=1288&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=CircularDoubleLinkedList_remove "CircularDoubleLinkedList_remove")<br />![CircularSingleLinkedList](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795580079-101686d4-4d06-47ac-b1e4-75073b455083.jpeg#averageHue=%23f4f3f3&clientId=uea9b4b03-0995-4&from=drop&id=ue8ca9546&originHeight=742&originWidth=1322&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=107480&status=done&style=none&taskId=u7602f4fb-7ff3-4435-8e91-1eba2fec0f7&title=CircularSingleLinkedList#averageHue=%23f4f3f3&id=xNDNG&originHeight=742&originWidth=1322&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=CircularSingleLinkedList "CircularSingleLinkedList")<br />![DoubleLinkedList](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795634425-38fd9509-4fc9-4223-b5b8-7e15e9b4f1a8.jpeg#averageHue=%23f5f4f4&clientId=uea9b4b03-0995-4&from=drop&id=u62689747&originHeight=686&originWidth=1266&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=89866&status=done&style=none&taskId=ud3bbb01a-1d39-4d2d-8bf3-14244248780&title=DoubleLinkedList#averageHue=%23f5f4f4&id=z6tMU&originHeight=686&originWidth=1266&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=DoubleLinkedList "DoubleLinkedList")<br />![DoubleLinkedList_add](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795658123-e615a4ba-e842-404a-a3fc-685fed70f15f.jpeg#averageHue=%23f4f3f3&clientId=uea9b4b03-0995-4&from=drop&id=u1fd2d612&originHeight=1098&originWidth=1376&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=197650&status=done&style=none&taskId=ud1e2bae8-8897-4d44-83ed-de0f096f36e&title=DoubleLinkedList_add#averageHue=%23f4f3f3&id=VQ10r&originHeight=1098&originWidth=1376&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=DoubleLinkedList_add "DoubleLinkedList_add")![DoubleLinkedList_get](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795667301-6b46d0e3-22e4-4fea-a32e-9c64e449d512.jpeg#averageHue=%23f4f2f1&clientId=uea9b4b03-0995-4&from=drop&id=u1573b7f3&originHeight=382&originWidth=1148&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=61826&status=done&style=none&taskId=uaace8003-77bb-47cf-b4af-58c6412d76c&title=DoubleLinkedList_get#averageHue=%23f4f2f1&id=oCnYz&originHeight=382&originWidth=1148&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=DoubleLinkedList_get "DoubleLinkedList_get")![DoubleLinkedList_remove](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795671766-9ba0a31f-0f29-42d5-84e2-d2ee2942c1d3.jpeg#averageHue=%23f4f3f3&clientId=uea9b4b03-0995-4&from=drop&id=uef7e8a3c&originHeight=1044&originWidth=1240&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=182428&status=done&style=none&taskId=uca8f84ad-4be7-41a0-b825-f3760d7578a&title=DoubleLinkedList_remove#averageHue=%23f4f3f3&id=H6mxm&originHeight=1044&originWidth=1240&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=DoubleLinkedList_remove "DoubleLinkedList_remove")![Queue](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795679012-43b8affe-6b1a-4ff1-8c3b-f88c6a3c8026.jpeg#averageHue=%23f5f4f4&clientId=uea9b4b03-0995-4&from=drop&id=ub19fc144&originHeight=552&originWidth=1276&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=61611&status=done&style=none&taskId=u290a35df-14ec-407e-b09b-0ff9f658b77&title=Queue#averageHue=%23f5f4f4&id=X5YFx&originHeight=552&originWidth=1276&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Queue "Queue")![Queue_add1](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795684548-e8ca409b-6c44-4282-b48c-0ebf177dcbd0.jpeg#averageHue=%23f3f2f2&clientId=uea9b4b03-0995-4&from=drop&id=u114e6100&originHeight=1114&originWidth=1434&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=212548&status=done&style=none&taskId=ue855267a-dbbe-4b89-879b-4a50b805467&title=Queue_add1#averageHue=%23f3f2f2&id=aKfIN&originHeight=1114&originWidth=1434&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Queue_add1 "Queue_add1")![Queue_add2](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795692857-cb6f0ed8-9086-4727-83eb-040f13447619.jpeg#averageHue=%23f2f1f1&clientId=uea9b4b03-0995-4&from=drop&id=uc5b4a92e&originHeight=1052&originWidth=1450&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=209280&status=done&style=none&taskId=u00a5f6dc-3f39-4f94-8b5c-1b9305be478&title=Queue_add2#averageHue=%23f2f1f1&id=cEIti&originHeight=1052&originWidth=1450&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Queue_add2 "Queue_add2")![Red-BlackTree](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795700132-2155ce03-116f-46a4-8921-96775c6350ae.jpeg#averageHue=%23efebeb&clientId=uea9b4b03-0995-4&from=drop&id=uf87a8472&originHeight=813&originWidth=2065&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=81269&status=done&style=none&taskId=u2909d243-4930-489b-8dda-f3850d32794&title=Red-BlackTree#averageHue=%23efebeb&id=TgsDy&originHeight=813&originWidth=2065&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Red-BlackTree "Red-BlackTree")![SingleLinkedList](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795706323-cd26d72a-e98e-4177-8683-2a3f1352a2e1.jpeg#averageHue=%23f4f4f4&clientId=uea9b4b03-0995-4&from=drop&id=udf4b973b&originHeight=576&originWidth=1350&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=57814&status=done&style=none&taskId=uef0ca968-f536-4d7c-8159-412c7afa792&title=SingleLinkedList#averageHue=%23f4f4f4&id=SfcAu&originHeight=576&originWidth=1350&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList "SingleLinkedList")![SingleLinkedList_add1](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795712665-6ee83868-9c6a-4fcb-b16a-7dacf5f41537.jpeg#averageHue=%23f5f2f2&clientId=uea9b4b03-0995-4&from=drop&id=ub90f5408&originHeight=218&originWidth=1006&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=32817&status=done&style=none&taskId=u67bedd6d-1246-411e-a236-38ce89b7b87&title=SingleLinkedList_add1#averageHue=%23f5f2f2&id=cFwQl&originHeight=218&originWidth=1006&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_add1 "SingleLinkedList_add1")![SingleLinkedList_add2](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795719146-98f8b6f7-bf86-486d-b4c9-c0f923c7caa2.jpeg#averageHue=%23f4f0ef&clientId=uea9b4b03-0995-4&from=drop&id=uebbc2e14&originHeight=536&originWidth=1354&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=132416&status=done&style=none&taskId=udd72a051-dfa5-493b-8945-5dd872690f4&title=SingleLinkedList_add2#averageHue=%23f4f0ef&id=k8gAl&originHeight=536&originWidth=1354&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_add2 "SingleLinkedList_add2")![SingleLinkedList_add3](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795727672-d46c30bd-54ff-48a2-b4a6-a8796fed0dfc.jpeg#averageHue=%23f4f3f2&clientId=uea9b4b03-0995-4&from=drop&id=u92c2ef93&originHeight=1052&originWidth=1448&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=206346&status=done&style=none&taskId=u50b26469-4bf3-4060-9099-cd27653fba6&title=SingleLinkedList_add3#averageHue=%23f4f3f2&id=Caz98&originHeight=1052&originWidth=1448&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_add3 "SingleLinkedList_add3")![SingleLinkedList_add4](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795734429-73133242-2a0c-43aa-8105-40d3b4781870.jpeg#averageHue=%23f4f3f2&clientId=uea9b4b03-0995-4&from=drop&id=ubdefb8e4&originHeight=620&originWidth=1432&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=117575&status=done&style=none&taskId=ud1089977-4254-4446-93c6-19ccb211e79&title=SingleLinkedList_add4#averageHue=%23f4f3f2&id=H5lyE&originHeight=620&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_add4 "SingleLinkedList_add4")![SingleLinkedList_get](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795745072-0c294fe8-be48-42fa-bffc-5bfab79b0869.jpeg#averageHue=%23f3f2f1&clientId=uea9b4b03-0995-4&from=drop&id=ueabd20ea&originHeight=1032&originWidth=1612&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=291620&status=done&style=none&taskId=u47d30fc3-85f0-4e20-9a19-20783fd8e5f&title=SingleLinkedList_get#averageHue=%23f3f2f1&id=oZKou&originHeight=1032&originWidth=1612&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_get "SingleLinkedList_get")![SingleLinkedList_remove1](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795754642-60ae0a49-4b03-4cea-9c85-606784be9c02.jpeg#averageHue=%23f4f3f3&clientId=uea9b4b03-0995-4&from=drop&id=ud5cce253&originHeight=424&originWidth=1384&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=74873&status=done&style=none&taskId=u065c96a9-3bb9-45cf-9bfe-1d9652e1d9a&title=SingleLinkedList_remove1#averageHue=%23f4f3f3&id=HFEvb&originHeight=424&originWidth=1384&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_remove1 "SingleLinkedList_remove1")![SingleLinkedList_remove2](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795784687-bcb52865-102b-4f18-8f54-6b51da0d9787.jpeg#averageHue=%23f4f2f2&clientId=uea9b4b03-0995-4&from=drop&id=ua71f9056&originHeight=360&originWidth=1220&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=60926&status=done&style=none&taskId=ue76f1112-01de-4a91-84bf-277ac1eae38&title=SingleLinkedList_remove2#averageHue=%23f4f2f2&id=k9zFU&originHeight=360&originWidth=1220&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_remove2 "SingleLinkedList_remove2")<br />![SingleLinkedList_remove3](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795793907-a900df0c-b414-401b-a39a-bcc9007bba42.jpeg#averageHue=%23f4f3f3&clientId=uea9b4b03-0995-4&from=drop&id=uacdba16b&originHeight=448&originWidth=1290&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=68994&status=done&style=none&taskId=u75de2adc-1f2a-433b-88c5-a86376c659b&title=SingleLinkedList_remove3#averageHue=%23f4f3f3&id=xBNXN&originHeight=448&originWidth=1290&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_remove3 "SingleLinkedList_remove3")![SingleLinkedList_withHead](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795805995-ae656ae7-fdc6-44f5-bf56-404757499ada.jpeg#averageHue=%23f4f3f3&clientId=uea9b4b03-0995-4&from=drop&id=u1759694b&originHeight=230&originWidth=950&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=25491&status=done&style=none&taskId=ud05a5fcd-5676-4362-aa1b-86d3710cf1a&title=SingleLinkedList_withHead#averageHue=%23f4f3f3&id=StRe7&originHeight=230&originWidth=950&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_withHead "SingleLinkedList_withHead")![SingleLinkedList_withHead_add](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795921565-3ed4dc13-f126-43bc-a32d-e0d4b3433f43.jpeg#averageHue=%23f4f2f2&clientId=uea9b4b03-0995-4&from=drop&id=u6775b3db&originHeight=386&originWidth=1376&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=73105&status=done&style=none&taskId=uc384563b-6b85-4789-82f6-11bf5d2782b&title=SingleLinkedList_withHead_add#averageHue=%23f4f2f2&id=wKstu&originHeight=386&originWidth=1376&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_withHead_add "SingleLinkedList_withHead_add")<br />![SingleLinkedList_withHead_endAdd](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795929848-c8b28d7e-6e57-4e31-a8f5-ae9755879149.jpeg#averageHue=%23f4f2f2&clientId=uea9b4b03-0995-4&from=drop&id=uf0540540&originHeight=462&originWidth=1414&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=84948&status=done&style=none&taskId=u5f39731f-af61-46d2-8885-e6b3cdf7b70&title=SingleLinkedList_withHead_endAdd#averageHue=%23f4f2f2&id=CT6ik&originHeight=462&originWidth=1414&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_withHead_endAdd "SingleLinkedList_withHead_endAdd")<br />![SingleLinkedList_withHead_endRear](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795937620-16a6a535-2260-4dde-a8ef-9be2c08d25e1.jpeg#averageHue=%23f4f3f3&clientId=uea9b4b03-0995-4&from=drop&id=uf23baaf8&originHeight=378&originWidth=1392&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=60721&status=done&style=none&taskId=u98353bce-c5a4-468f-b5f1-fac55a0dd67&title=SingleLinkedList_withHead_endRear#averageHue=%23f4f3f3&id=YCiNV&originHeight=378&originWidth=1392&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_withHead_endRear "SingleLinkedList_withHead_endRear")![SingleLinkedList_withHead_remove](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795946634-7dd649fb-2056-4482-adfe-96dd471b83bf.jpeg#averageHue=%23f4f3f3&clientId=uea9b4b03-0995-4&from=drop&id=u5cf6ee71&originHeight=404&originWidth=1366&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=64908&status=done&style=none&taskId=udded0787-5075-4d87-a02d-0b287119c6b&title=SingleLinkedList_withHead_remove#averageHue=%23f4f3f3&id=ZvTtf&originHeight=404&originWidth=1366&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_withHead_remove "SingleLinkedList_withHead_remove")![SingleLinkedList_withHead_traversal](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690795953769-cbfb3695-87e4-463e-addf-c1b5388a92a1.jpeg#averageHue=%23f4f3f3&clientId=uea9b4b03-0995-4&from=drop&id=ud803fbd0&originHeight=404&originWidth=1396&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=63633&status=done&style=none&taskId=ufa8d52db-6929-46f5-b9dd-29e3be4bc47&title=SingleLinkedList_withHead_traversal#averageHue=%23f4f3f3&id=UHGfD&originHeight=404&originWidth=1396&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SingleLinkedList_withHead_traversal "SingleLinkedList_withHead_traversal")<br />![Stack](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690796391899-d6e48cf3-4060-4260-a643-dfccefcc8fdd.jpeg#averageHue=%23f5f4f4&clientId=uea9b4b03-0995-4&from=drop&id=u71223053&originHeight=762&originWidth=1594&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=97664&status=done&style=none&taskId=u63fab6a6-cc1d-42a2-9a7f-54ce6a91dbf&title=#averageHue=%23f5f4f4&id=MrQD7&originHeight=762&originWidth=1594&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Stack "Stack")<br />![Tree](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690796687706-b03d56a2-0af4-4706-84b4-0e8a7f622f86.jpeg#averageHue=%23f4f4f4&clientId=u4f989441-1d5b-4&from=drop&id=u19092d9a&originHeight=976&originWidth=1410&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=145680&status=done&style=none&taskId=u105a51a3-f29c-4580-9b53-5f37b1b4ecf&title=Tree "Tree")
<a name="PRREL"></a>
#### Data Structure
<a name="zNov8"></a>
##### 1. 动态数组

对于一个基于Java E[]实现的动态数组Array来说，它的时间复杂度如下：

- 增：O(n)
- 删：O(n)
- 改：已知索引 O(1)；未知索引 O(n)
- 查：已知索引 O(1)；未知索引 O(n)
- resize：通过均摊复杂度分析得 O(1)
<a name="c628e100"></a>
##### 2. 数组栈

对于一个基于动态数组Array实现的数组栈ArrayStack来说，它的时间复杂度如下：

- void push(E): O(1) 均摊
- E pop(): O(1) 均摊
- E peek(): O(1)
- int getSize(): O(1)
- boolean isEmpty(): O(1)

<a name="e3186da2"></a>
##### 3. 数组队列

对于一个基于动态数组Array实现的数组队列ArrayQueue来说，它的时间复杂度如下：

- void enqueue(E): O(1) 均摊
- E dequeue(): O(n)
- E front(): O(1)
- int getSize(): O(1)
- boolean isEmpty(): O(1)

<a name="edb651ca"></a>
##### 4. 循环数组队列

对于一个基于Java E[]实现的循环队列LoopQueue来说，它的时间复杂度如下：

- void enqueue(E): O(1) 均摊
- E dequeue(): O(1) 均摊
- E front(): O(1)
- int getSize(): O(1)
- boolean isEmpty(): O(1)

<a name="hR5jH"></a>
##### 数组和链表

数组最大的优点：支持随机访问、快速查询。<br />数组最好用于索引有语义的情况。

链表最大的优点：动态。<br />链表不适合用于索引有语义的情况。

<a name="ff561641"></a>
##### 5. 链表

- 增：O(n)
- 删：O(n)
- 改：O(n)
- 查：O(n)

链表不适合修改操作；<br />如果只对链表头进行增删查操作：O(1)

<a name="1d0c5811"></a>
##### 6. 链表栈

- 与数组栈各操作的时间复杂度上是同一量级 O(1)。
- 时间上的差异可能在于：数组栈在分配空间方面；链表栈在new寻找内存空间方面。
- <br />
<a name="nvg1R"></a>
##### 7. 链表队列

- 与数组队列各操作的时间复杂度上是同一量级 O(1)。
- 特别的，链表的head容易做增、删操作，而tail只容易做增操作，故tail端入队，head端出队。

链表是天然的递归结构。递归调用是有代价的：函数调用+系统栈空间。<br />递归函数的调试：添加一个递归深度变量depth作为函数参数。

<a name="cDx5x"></a>
##### 8. 双链表
<a name="abb360fe"></a>
##### 9. 循环链表
<a name="9af78021"></a>
##### 10. 数组链表

<a name="a1256b50"></a>
##### 11. 集合
| . | LinkedListSet | BSTreeSet | BSTreeSet最优 | BSTreeSet最差 |
| --- | --- | --- | --- | --- |
| 增add | O(n) | O(h) | O(logn) | O(n) |
| 删remove | O(n) | O(h) | O(logn) | O(n) |
| 查contains | O(n) | O(h) | O(logn) | O(n) |


基于搜索树的实现：有序集合<br />基于哈希表的实现：无序集合

多重集合：集合中的元素可以重复

<a name="599393d1"></a>
##### 12. 映射
| . | LinkedListMap | BSTreeMap | BSTreeMap最优 | BSTreeMap最差 |
| --- | --- | --- | --- | --- |
| 增add | O(n) | O(h) | O(logn) | O(n) |
| 删remove | O(n) | O(h) | O(logn) | O(n) |
| 改set | O(n) | O(h) | O(logn) | O(n) |
| 查contains | O(n) | O(h) | O(logn) | O(n) |
| 查get | O(n) | O(h) | O(logn) | O(n) |


基于搜索树的实现：有序映射<br />基于哈希表的实现：无序映射

多重映射：映射中的键可以重复

<a name="70b99a82"></a>
##### 13. 优先队列
| . | 入队 | 出队（拿出最大元素） |
| --- | --- | --- |
| 普通线性结构 | O(1) | O(n) |
| 顺序线性结构 | O(n) | O(1) |
| 堆 | O(logn) | O(logn) |


<a name="bdf0f45d"></a>
##### 14. 最大堆
| 操作 | 时间复杂度 |
| --- | --- |
| add, Sift Up | O(logn) |
| extractMax, Sift Down | O(logn) |


- replace：取出最大元素后，放入一个新元素

> 实现1：先extractMax，再add，两次O(logn)<br />实现2：先将堆顶元素替换，再Sift Down，一次O(logn)


- heapify：将任意数组整理成堆的形状

> 实现1：将n个元素逐个插入到一个空堆中，O(nlogn)<br />实现2：从最后一个非叶子节点往堆顶遍历，不断进行Sift Down，O(n)：证明略。




<a name="feb6cc8a"></a>
##### 15. 线段树

- 线段树不是完全二叉树，线段树和堆都是平衡二叉树。<br />| 操作 | 使用数组实现 | 使用线段树 |<br />| --- | --- | --- |<br />| 更新 | O(n) | O(logn) |<br />| 查询 | O(n) | O(logn) |

<a name="fb8315f4"></a>
##### 16. Trie前缀树

应用：查询一个字符串字典，例如通讯录。

| 操作 | 使用树状字典 | 使用Trie |
| --- | --- | --- |
| 查询 | O(logn) | O(w) |


如果有100万个条目（2^20），logn约为20；<br />Trie中w为查询单词的长度，大多数单词的长度小于10。

<a name="e8e7f393"></a>
##### 17. 并查集

数组实现，数组结构的Quick Find版：<br />查看元素p和元素q是否所属一个集合，时间复杂度是O(1)<br />合并元素p和元素q所属的集合，时间复杂度是O(n)

数组实现，树状结构的Quick Union版（由孩子指向父亲的特殊树结构）：<br />查看元素p和元素q是否所属一个集合，时间复杂度是O(h)<br />合并元素p和元素q所属的集合，时间复杂度是O(h)

路径压缩有的并查集：时间复杂度为O(log*n) -> iterated logarithm<br />比O(logn)要快，略慢于O(1)

<a name="638f5086"></a>
##### 18. AVL树

名称来源：发明者的名字开头字母。<br />1962年提出，最早的自平衡二分搜索树结构。

平衡二叉树：对于任意一个节点，左子树和右子树的高度差不能超过1（平衡因子绝对值不超过1）

真正的O(logn)

<a name="848982fd"></a>
##### 19. 2-3树

是一种绝对平衡的搜索树。即根节点到任意一个叶子节点所经过的节点数量一定相同。

<a name="c67ebc91"></a>
##### 20. 红黑树

是一种保持“黑平衡”的二叉树。<br />不是平衡二叉树，最大高度为2logn，时间复杂度都是O(logn)<br />与AVL树的对比：<br />增删操作：红黑树更快，因为维持平衡的时间消耗少<br />查询操作：AVL更快

<a name="263e1efc"></a>
##### 21. 哈希表

链地址法解决哈希冲突时，总共有M个地址，如果放入哈希表的元素为N：<br />（1）每个地址用链表实现，则时间复杂度：O(N/M)<br />（2）每个地址用平衡树实现，则时间复杂度：O(log(N/M))

动态空间的哈希表：均摊复杂度是O(1)

We have a sequence with n numbers in increasing order. If we insert an element one after the other to build a binary search tree, it will make the tree with height n. Make an algorithm (pseudocode or JAVA code) to construct a balanced binary search tree. A tree is balanced if, for each node in the tree, the number of nodes in its left and right subtree differ by at most one.

![JavaDataType.jpeg](https://cdn.nlark.com/yuque/0/2023/jpeg/35495747/1690798366142-a5e1d61e-44ac-4479-8bf9-816dde14c17f.jpeg#clientId=u15cfc2e9-1c00-4&from=drop&height=18389&id=u3917a69e&originHeight=18389&originWidth=1232&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=2020603&status=done&style=none&taskId=u95ead0d5-0061-48a9-8020-a17d1655738&title=&width=1232)
